/*************************************************************/
/* Copyright (C) 2018 OSS Nokalva, Inc.  All rights reserved.*/
/*************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OSS NOKALVA, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OSS NOKALVA, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED.
 * THIS COPYRIGHT STATEMENT MAY NOT BE REMOVED. */

/* This file was generated by a TRIAL version of the OSS ASN.1 Tools.
 * Applications built using this file can be executed only on the machine
 * on which you run the OSS ASN.1 compiler. */

/* Generated for: UC Berkeley (Trial), License 76702Z 76702Z. */
/* Abstract syntax: objects */
/* Created: Tue Apr 17 19:03:42 2018 */
/* ASN.1/C++ compiler version: 6.6 */
/* Code generated for runtime version 6.6 or later */
/* Compiler operating system: Linux with 64-bit support */
/* Compiler machine type: Intel 64 or AMD64 */
/* Target operating system: Linux with 64-bit support */
/* Target machine type: Intel 64 or AMD64 */
/* C++ compiler options required: -m64 */
/* ASN.1 compiler options and file names specified:
 * -der -allow universaltags objects.asn
 */

#define OSS_COMPILER_API_LEVEL 37
#define _OSS_CODE_FILE
#define OSS_TOED_BER
#include "objects.h"
#include "string.h"

#include "osstype.h"

#if OSSDEBUG > 1
#define OSS_CNTX_INIT _Context_Element _element;  _element._occurrence = 0;
#define OSS_CNTX_INITZERO _Context_Element _element = {NULL, NULL, 0};
#define OSS_CNTX_ZEROOCC  _element._occurrence = 0;
#define OSS_CNTX_INCOCC  _element._occurrence++;
#define OSS_CNTX_SETOCC(OCC) _element._occurrence = OCC;
#define OSS_CNTX_DEF _Context_Element _element;
#define OSS_CNTX_POP(OSSCNAME) OSSCNAME->_oss_context_anchor._last = _element._parent;
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_SET(CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];
#define OSS_CNTX_NEW(OSSCNAME,CNTXID) _Context_Element _element;\
    _element._occurrence = 0;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) \
    _element._parent = _oss_c->_oss_context_anchor._last;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _oss_c->_oss_context_anchor._last = &_element;\
    if (!_oss_c->_oss_context_anchor._pdu_number) {\
        _oss_c->_oss_context_anchor._pdu_number = PDU;\
        _oss_c->_oss_context_anchor._pdu_id = _element._id;\
    }
#define OSS_CNTX_OSSC_DEF _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#else
#define OSS_CNTX_INIT
#define OSS_CNTX_INITZERO
#define OSS_CNTX_ZEROOCC
#define OSS_CNTX_INCOCC
#define OSS_CNTX_SETOCC(OCC)
#define OSS_CNTX_DEF
#define OSS_CNTX_POP(OSSCNAME)
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID)
#define OSS_CNTX_SET(CNTXID)
#define OSS_CNTX_NEW(OSSCNAME,CNTXID)
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) _oss_c->_oss_context_anchor._pdu_number = 0;
#endif
/* Control table object */

class objects_TableType : public OssControlTable {
public:
    static void *internal;
    objects_TableType();
    int destroy(void *data, OssTypeIndex typeindex);
    int copy(void *src, void **dst, OssTypeIndex typeindex);
    int equal(void *data1, void *data2, OssTypeIndex typeindex);
};

objects_TableType::objects_TableType() : OssControlTable(internal) {
}

int objects_TableType::destroy(void *data, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    delete (WaveWireObject *)data;
	    break;
	case 2:
	    delete (WaveAttestation *)data;
	    break;
	case 3:
	    delete (AttestationBody *)data;
	    break;
	case 4:
	    delete (WaveEntity *)data;
	    break;
	case 5:
	    delete (WaveEntitySecret *)data;
	    break;
	case 6:
	    delete (EntityKeyring *)data;
	    break;
	case 7:
	    delete (EntityKeyringEntry *)data;
	    break;
	case 8:
	    delete (WaveExplicitProof *)data;
	    break;
	case 9:
	    delete (RTreePolicy *)data;
	    break;
	case 10:
	    delete (HashSha3_256 *)data;
	    break;
	case 11:
	    delete (HashSha_256 *)data;
	    break;
	case 12:
	    delete (HashKeccak_256 *)data;
	    break;
	case 13:
	    delete (LocationURL *)data;
	    break;
	case 14:
	    delete (LocationEthereum *)data;
	    break;
	case 15:
	    delete (PSKBodyCiphertext *)data;
	    break;
	case 16:
	    delete (WR1BodyCiphertext *)data;
	    break;
	case 17:
	    delete (WR1Envelope *)data;
	    break;
	case 18:
	    delete (WR1ProverBody *)data;
	    break;
	case 19:
	    delete (WR1VerifierBody *)data;
	    break;
	case 20:
	    delete (Ed25519OuterSignature *)data;
	    break;
	case 21:
	    delete (SignedOuterKey *)data;
	    break;
	case 22:
	    delete (TrustLevel *)data;
	    break;
	case 23:
	    delete (CommitmentRevocationOption *)data;
	    break;
	case 24:
	    delete (AVKeyAES128_GCM *)data;
	    break;
	case 25:
	    delete (Private_Ed25519 *)data;
	    break;
	case 26:
	    delete (Private_Curve25519 *)data;
	    break;
	case 27:
	    delete (Private_BN256_OAQUE *)data;
	    break;
	case 28:
	    delete (Private_BN256_IBE *)data;
	    break;
	case 29:
	    delete (Master_BN256_OAQUE *)data;
	    break;
	case 30:
	    delete (Master_BN256_IBE *)data;
	    break;
	case 31:
	    delete (Public_Ed25519 *)data;
	    break;
	case 32:
	    delete (Public_Curve25519 *)data;
	    break;
	case 33:
	    delete (Public_OAQUE *)data;
	    break;
	case 34:
	    delete (Params_BN256_OAQUE *)data;
	    break;
	case 35:
	    delete (Params_BN256_IBE *)data;
	    break;
	case 36:
	    delete (Public_BN256_IBE *)data;
	    break;
	case 37:
	    delete (KeyringAESCiphertext *)data;
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    return 0;
}

int objects_TableType::copy(void *src, void **dst, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    *dst = new WaveWireObject(*(WaveWireObject *)src);
	    break;
	case 2:
	    *dst = new WaveAttestation(*(WaveAttestation *)src);
	    break;
	case 3:
	    *dst = new AttestationBody(*(AttestationBody *)src);
	    break;
	case 4:
	    *dst = new WaveEntity(*(WaveEntity *)src);
	    break;
	case 5:
	    *dst = new WaveEntitySecret(*(WaveEntitySecret *)src);
	    break;
	case 6:
	    *dst = new EntityKeyring(*(EntityKeyring *)src);
	    break;
	case 7:
	    *dst = new EntityKeyringEntry(*(EntityKeyringEntry *)src);
	    break;
	case 8:
	    *dst = new WaveExplicitProof(*(WaveExplicitProof *)src);
	    break;
	case 9:
	    *dst = new RTreePolicy(*(RTreePolicy *)src);
	    break;
	case 10:
	    *dst = new HashSha3_256(*(HashSha3_256 *)src);
	    break;
	case 11:
	    *dst = new HashSha_256(*(HashSha_256 *)src);
	    break;
	case 12:
	    *dst = new HashKeccak_256(*(HashKeccak_256 *)src);
	    break;
	case 13:
	    *dst = new LocationURL(*(LocationURL *)src);
	    break;
	case 14:
	    *dst = new LocationEthereum(*(LocationEthereum *)src);
	    break;
	case 15:
	    *dst = new PSKBodyCiphertext(*(PSKBodyCiphertext *)src);
	    break;
	case 16:
	    *dst = new WR1BodyCiphertext(*(WR1BodyCiphertext *)src);
	    break;
	case 17:
	    *dst = new WR1Envelope(*(WR1Envelope *)src);
	    break;
	case 18:
	    *dst = new WR1ProverBody(*(WR1ProverBody *)src);
	    break;
	case 19:
	    *dst = new WR1VerifierBody(*(WR1VerifierBody *)src);
	    break;
	case 20:
	    *dst = new Ed25519OuterSignature(*(Ed25519OuterSignature *)src);
	    break;
	case 21:
	    *dst = new SignedOuterKey(*(SignedOuterKey *)src);
	    break;
	case 22:
	    *dst = new TrustLevel(*(TrustLevel *)src);
	    break;
	case 23:
	    *dst = new CommitmentRevocationOption(*(CommitmentRevocationOption *)src);
	    break;
	case 24:
	    *dst = new AVKeyAES128_GCM(*(AVKeyAES128_GCM *)src);
	    break;
	case 25:
	    *dst = new Private_Ed25519(*(Private_Ed25519 *)src);
	    break;
	case 26:
	    *dst = new Private_Curve25519(*(Private_Curve25519 *)src);
	    break;
	case 27:
	    *dst = new Private_BN256_OAQUE(*(Private_BN256_OAQUE *)src);
	    break;
	case 28:
	    *dst = new Private_BN256_IBE(*(Private_BN256_IBE *)src);
	    break;
	case 29:
	    *dst = new Master_BN256_OAQUE(*(Master_BN256_OAQUE *)src);
	    break;
	case 30:
	    *dst = new Master_BN256_IBE(*(Master_BN256_IBE *)src);
	    break;
	case 31:
	    *dst = new Public_Ed25519(*(Public_Ed25519 *)src);
	    break;
	case 32:
	    *dst = new Public_Curve25519(*(Public_Curve25519 *)src);
	    break;
	case 33:
	    *dst = new Public_OAQUE(*(Public_OAQUE *)src);
	    break;
	case 34:
	    *dst = new Params_BN256_OAQUE(*(Params_BN256_OAQUE *)src);
	    break;
	case 35:
	    *dst = new Params_BN256_IBE(*(Params_BN256_IBE *)src);
	    break;
	case 36:
	    *dst = new Public_BN256_IBE(*(Public_BN256_IBE *)src);
	    break;
	case 37:
	    *dst = new KeyringAESCiphertext(*(KeyringAESCiphertext *)src);
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    if (*dst == 0)
	return OSS_NO_MEMORY;
    return 0;
}

int objects_TableType::equal(void *data1, void *data2, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    return *(WaveWireObject *)data1 == *(WaveWireObject *)data2;
	case 2:
	    return *(WaveAttestation *)data1 == *(WaveAttestation *)data2;
	case 3:
	    return *(AttestationBody *)data1 == *(AttestationBody *)data2;
	case 4:
	    return *(WaveEntity *)data1 == *(WaveEntity *)data2;
	case 5:
	    return *(WaveEntitySecret *)data1 == *(WaveEntitySecret *)data2;
	case 6:
	    return *(EntityKeyring *)data1 == *(EntityKeyring *)data2;
	case 7:
	    return *(EntityKeyringEntry *)data1 == *(EntityKeyringEntry *)data2;
	case 8:
	    return *(WaveExplicitProof *)data1 == *(WaveExplicitProof *)data2;
	case 9:
	    return *(RTreePolicy *)data1 == *(RTreePolicy *)data2;
	case 10:
	    return *(HashSha3_256 *)data1 == *(HashSha3_256 *)data2;
	case 11:
	    return *(HashSha_256 *)data1 == *(HashSha_256 *)data2;
	case 12:
	    return *(HashKeccak_256 *)data1 == *(HashKeccak_256 *)data2;
	case 13:
	    return *(LocationURL *)data1 == *(LocationURL *)data2;
	case 14:
	    return *(LocationEthereum *)data1 == *(LocationEthereum *)data2;
	case 15:
	    return *(PSKBodyCiphertext *)data1 == *(PSKBodyCiphertext *)data2;
	case 16:
	    return *(WR1BodyCiphertext *)data1 == *(WR1BodyCiphertext *)data2;
	case 17:
	    return *(WR1Envelope *)data1 == *(WR1Envelope *)data2;
	case 18:
	    return *(WR1ProverBody *)data1 == *(WR1ProverBody *)data2;
	case 19:
	    return *(WR1VerifierBody *)data1 == *(WR1VerifierBody *)data2;
	case 20:
	    return *(Ed25519OuterSignature *)data1 == *(Ed25519OuterSignature *)data2;
	case 21:
	    return *(SignedOuterKey *)data1 == *(SignedOuterKey *)data2;
	case 22:
	    return *(TrustLevel *)data1 == *(TrustLevel *)data2;
	case 23:
	    return *(CommitmentRevocationOption *)data1 == *(CommitmentRevocationOption *)data2;
	case 24:
	    return *(AVKeyAES128_GCM *)data1 == *(AVKeyAES128_GCM *)data2;
	case 25:
	    return *(Private_Ed25519 *)data1 == *(Private_Ed25519 *)data2;
	case 26:
	    return *(Private_Curve25519 *)data1 == *(Private_Curve25519 *)data2;
	case 27:
	    return *(Private_BN256_OAQUE *)data1 == *(Private_BN256_OAQUE *)data2;
	case 28:
	    return *(Private_BN256_IBE *)data1 == *(Private_BN256_IBE *)data2;
	case 29:
	    return *(Master_BN256_OAQUE *)data1 == *(Master_BN256_OAQUE *)data2;
	case 30:
	    return *(Master_BN256_IBE *)data1 == *(Master_BN256_IBE *)data2;
	case 31:
	    return *(Public_Ed25519 *)data1 == *(Public_Ed25519 *)data2;
	case 32:
	    return *(Public_Curve25519 *)data1 == *(Public_Curve25519 *)data2;
	case 33:
	    return *(Public_OAQUE *)data1 == *(Public_OAQUE *)data2;
	case 34:
	    return *(Params_BN256_OAQUE *)data1 == *(Params_BN256_OAQUE *)data2;
	case 35:
	    return *(Params_BN256_IBE *)data1 == *(Params_BN256_IBE *)data2;
	case 36:
	    return *(Public_BN256_IBE *)data1 == *(Public_BN256_IBE *)data2;
	case 37:
	    return *(KeyringAESCiphertext *)data1 == *(KeyringAESCiphertext *)data2;
    }
    return 0;
}

static objects_TableType objects_Table;

/* Representation types */

HashSchemes_Type::HashSchemes_Type()
{
}

HashSchemes_Type::HashSchemes_Type(const HashSchemes_Type & that)
{
    operator =(that);
}

HashSchemes_Type::~HashSchemes_Type()
{
    cleanup_decoded();
}

HashSchemes_Type & HashSchemes_Type::operator = (const HashSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int HashSchemes_Type::operator == (const HashSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int HashSchemes_Type::operator != (const HashSchemes_Type & that) const
{
    return !(operator ==(that));
}

int HashSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int HashSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int HashSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int HashSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int HashSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

HashSha3_256 *HashSchemes_Type::get_HashSha3_256()
{
    if (pdunum == 10)
	return (HashSha3_256 *)decoded;
    else
	return NULL;
}

const HashSha3_256 *HashSchemes_Type::get_HashSha3_256() const
{
    if (pdunum == 10)
	return (const HashSha3_256 *)decoded;
    else
	return NULL;
}

void HashSchemes_Type::set_HashSha3_256(const HashSha3_256 & data)
{
    void *copy;

    copy = new HashSha3_256(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 10;
	decoded = copy;
    }
}

HashSha3_256 *HashSchemes_Type::release_HashSha3_256()
{
    pdunum = 0;
    decoded = NULL;
    return get_HashSha3_256();
}

void HashSchemes_Type::set_HashSha3_256(HashSha3_256 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 10;
    decoded = data;
}

HashKeccak_256 *HashSchemes_Type::get_HashKeccak_256()
{
    if (pdunum == 12)
	return (HashKeccak_256 *)decoded;
    else
	return NULL;
}

const HashKeccak_256 *HashSchemes_Type::get_HashKeccak_256() const
{
    if (pdunum == 12)
	return (const HashKeccak_256 *)decoded;
    else
	return NULL;
}

void HashSchemes_Type::set_HashKeccak_256(const HashKeccak_256 & data)
{
    void *copy;

    copy = new HashKeccak_256(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 12;
	decoded = copy;
    }
}

HashKeccak_256 *HashSchemes_Type::release_HashKeccak_256()
{
    pdunum = 0;
    decoded = NULL;
    return get_HashKeccak_256();
}

void HashSchemes_Type::set_HashKeccak_256(HashKeccak_256 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 12;
    decoded = data;
}

HashSha_256 *HashSchemes_Type::get_HashSha_256()
{
    if (pdunum == 11)
	return (HashSha_256 *)decoded;
    else
	return NULL;
}

const HashSha_256 *HashSchemes_Type::get_HashSha_256() const
{
    if (pdunum == 11)
	return (const HashSha_256 *)decoded;
    else
	return NULL;
}

void HashSchemes_Type::set_HashSha_256(const HashSha_256 & data)
{
    void *copy;

    copy = new HashSha_256(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 11;
	decoded = copy;
    }
}

HashSha_256 *HashSchemes_Type::release_HashSha_256()
{
    pdunum = 0;
    decoded = NULL;
    return get_HashSha_256();
}

void HashSchemes_Type::set_HashSha_256(HashSha_256 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 11;
    decoded = data;
}

void HashSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__shared1::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared1::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared1::__shared1() {
    memset(this, 0, sizeof(__shared1));
}

__shared1::__shared1(const __shared1 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__shared1)
}

__shared1::__shared1(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__shared1)
}

__shared1 & __shared1::operator = (const __shared1 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __shared1::operator == (const __shared1 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __shared1::operator != (const __shared1 & that) const {
    return !(operator ==(that));
}

__shared1::type_id & __shared1::get_type_id() {
    return type_id_field;
}

const __shared1::type_id & __shared1::get_type_id() const {
    return type_id_field;
}

void __shared1::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__shared1::value & __shared1::get_value() {
    return value_field;
}

const __shared1::value & __shared1::get_value() const {
    return value_field;
}

void __shared1::set_value(const value & value_val) {
    value_field = value_val;
}

void *LocationURL::operator new(size_t size) {
    return ossNewFunc(size);
}

void LocationURL::operator delete(void *ptr) {
    asn1Free(ptr);
}

LocationURL::LocationURL() {
    memset(this, 0, sizeof(LocationURL));
}

LocationURL::LocationURL(const LocationURL & that) {
    OSSTRY {
	value_field = that.value_field;
	apiVersion_field = that.apiVersion_field;
    } OSSCLEAN(LocationURL)
}

LocationURL::LocationURL(const value & value_val, apiVersion apiVersion_val) {
    OSSTRY {
	value_field = value_val;
	apiVersion_field = apiVersion_val;
    } OSSCLEAN(LocationURL)
}

LocationURL & LocationURL::operator = (const LocationURL & that) {
    if (this == &that)
	return *this;
    value_field = that.value_field;
    apiVersion_field = that.apiVersion_field;
    return *this;
}

int LocationURL::operator == (const LocationURL & that) const {
    if (value_field != that.value_field)
	return 0;
    if (apiVersion_field != that.apiVersion_field)
	return 0;
    return 1;
}

int LocationURL::operator != (const LocationURL & that) const {
    return !(operator ==(that));
}

LocationURL::value & LocationURL::get_value() {
    return value_field;
}

const LocationURL::value & LocationURL::get_value() const {
    return value_field;
}

void LocationURL::set_value(const value & value_val) {
    value_field = value_val;
}

LocationURL::apiVersion & LocationURL::get_apiVersion() {
    return apiVersion_field;
}

LocationURL::apiVersion LocationURL::get_apiVersion() const {
    return apiVersion_field;
}

void LocationURL::set_apiVersion(apiVersion apiVersion_val) {
    apiVersion_field = apiVersion_val;
}

void *LocationEthereum::operator new(size_t size) {
    return ossNewFunc(size);
}

void LocationEthereum::operator delete(void *ptr) {
    asn1Free(ptr);
}

LocationEthereum::LocationEthereum() {
    memset(this, 0, sizeof(LocationEthereum));
}

LocationEthereum::LocationEthereum(const LocationEthereum & that) {
    OSSTRY {
	chainID_field = that.chainID_field;
	contractAddress_field = that.contractAddress_field;
    } OSSCLEAN(LocationEthereum)
}

LocationEthereum::LocationEthereum(chainID chainID_val, contractAddress contractAddress_val) {
    OSSTRY {
	chainID_field = chainID_val;
	contractAddress_field = contractAddress_val;
    } OSSCLEAN(LocationEthereum)
}

LocationEthereum & LocationEthereum::operator = (const LocationEthereum & that) {
    if (this == &that)
	return *this;
    chainID_field = that.chainID_field;
    contractAddress_field = that.contractAddress_field;
    return *this;
}

int LocationEthereum::operator == (const LocationEthereum & that) const {
    if (chainID_field != that.chainID_field)
	return 0;
    if (contractAddress_field != that.contractAddress_field)
	return 0;
    return 1;
}

int LocationEthereum::operator != (const LocationEthereum & that) const {
    return !(operator ==(that));
}

LocationEthereum::chainID & LocationEthereum::get_chainID() {
    return chainID_field;
}

LocationEthereum::chainID LocationEthereum::get_chainID() const {
    return chainID_field;
}

void LocationEthereum::set_chainID(chainID chainID_val) {
    chainID_field = chainID_val;
}

LocationEthereum::contractAddress & LocationEthereum::get_contractAddress() {
    return contractAddress_field;
}

LocationEthereum::contractAddress LocationEthereum::get_contractAddress() const {
    return contractAddress_field;
}

void LocationEthereum::set_contractAddress(contractAddress contractAddress_val) {
    contractAddress_field = contractAddress_val;
}

LocationSchemes_Type::LocationSchemes_Type()
{
}

LocationSchemes_Type::LocationSchemes_Type(const LocationSchemes_Type & that)
{
    operator =(that);
}

LocationSchemes_Type::~LocationSchemes_Type()
{
    cleanup_decoded();
}

LocationSchemes_Type & LocationSchemes_Type::operator = (const LocationSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int LocationSchemes_Type::operator == (const LocationSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int LocationSchemes_Type::operator != (const LocationSchemes_Type & that) const
{
    return !(operator ==(that));
}

int LocationSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int LocationSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int LocationSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int LocationSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int LocationSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

LocationURL *LocationSchemes_Type::get_LocationURL()
{
    if (pdunum == 13)
	return (LocationURL *)decoded;
    else
	return NULL;
}

const LocationURL *LocationSchemes_Type::get_LocationURL() const
{
    if (pdunum == 13)
	return (const LocationURL *)decoded;
    else
	return NULL;
}

void LocationSchemes_Type::set_LocationURL(const LocationURL & data)
{
    void *copy;

    copy = new LocationURL(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 13;
	decoded = copy;
    }
}

LocationURL *LocationSchemes_Type::release_LocationURL()
{
    pdunum = 0;
    decoded = NULL;
    return get_LocationURL();
}

void LocationSchemes_Type::set_LocationURL(LocationURL *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 13;
    decoded = data;
}

LocationEthereum *LocationSchemes_Type::get_LocationEthereum()
{
    if (pdunum == 14)
	return (LocationEthereum *)decoded;
    else
	return NULL;
}

const LocationEthereum *LocationSchemes_Type::get_LocationEthereum() const
{
    if (pdunum == 14)
	return (const LocationEthereum *)decoded;
    else
	return NULL;
}

void LocationSchemes_Type::set_LocationEthereum(const LocationEthereum & data)
{
    void *copy;

    copy = new LocationEthereum(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 14;
	decoded = copy;
    }
}

LocationEthereum *LocationSchemes_Type::release_LocationEthereum()
{
    pdunum = 0;
    decoded = NULL;
    return get_LocationEthereum();
}

void LocationSchemes_Type::set_LocationEthereum(LocationEthereum *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 14;
    decoded = data;
}

void LocationSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *Location::operator new(size_t size) {
    return ossNewFunc(size);
}

void Location::operator delete(void *ptr) {
    asn1Free(ptr);
}

Location::Location() {
    memset(this, 0, sizeof(Location));
}

Location::Location(const Location & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(Location)
}

Location::Location(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(Location)
}

Location & Location::operator = (const Location & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int Location::operator == (const Location & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int Location::operator != (const Location & that) const {
    return !(operator ==(that));
}

Location::type_id & Location::get_type_id() {
    return type_id_field;
}

const Location::type_id & Location::get_type_id() const {
    return type_id_field;
}

void Location::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

Location::value & Location::get_value() {
    return value_field;
}

const Location::value & Location::get_value() const {
    return value_field;
}

void Location::set_value(const value & value_val) {
    value_field = value_val;
}

/* Auxiliary data structures and functions for class __seqof1 */

class __seqof1_member {
public:
    __seqof1_member *next;
    __seqof1::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof1_member();
    __seqof1_member(const __seqof1::component & val);
};

void *__seqof1_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof1_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof1_member::__seqof1_member() {
}

__seqof1_member::__seqof1_member(const __seqof1::component & val) {
    value = val;
}

static void *__seqof1_copy(void *that) {
    return new __seqof1_member(((__seqof1_member *)that)->value);
}

static void __seqof1_destroy(void *that) {
    delete (__seqof1_member *)that;
}

static int __seqof1_compare(void *val1, void *val2) {
    return (((__seqof1_member *)val1)->value == ((__seqof1_member *)val2)->value);
}

/* Constructors */

__seqof1::__seqof1() {
}

__seqof1::__seqof1(const __seqof1 & that) {
    OSSTRY {
	do_copy(that, &__seqof1_copy);
    } OSSCLEAN(__seqof1)
}

/* Destructor */

__seqof1::~__seqof1() {
    do_destroy(&__seqof1_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof1 & __seqof1::operator = (const __seqof1 & that) {
    do_destroy(&__seqof1_destroy);
    do_copy(that, &__seqof1_copy);
    return *this;
}

int __seqof1::operator == (const __seqof1 & that) const {
    return do_compare(that, &__seqof1_compare);
}

int __seqof1::operator != (const __seqof1 & that) const {
    return !do_compare(that, &__seqof1_compare);
}

/* Locate ("At" etc) methods */

__seqof1::component *__seqof1::at(OssIndex pos) {
    return &((__seqof1_member *)pos)->value;
}

const __seqof1::component *__seqof1::at(OssIndex pos) const {
    return &((__seqof1_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof1::prepend(const component & val) {
    __seqof1_member *newrec = new __seqof1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof1::prepend(__seqof1 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof1::insert_after(OssIndex pos, const component & val) {
    __seqof1_member *newrec = new __seqof1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof1::insert_after(OssIndex pos, __seqof1 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof1::remove_front() {
    __seqof1_member *extr = (__seqof1_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof1_destroy(extr);
    return 0;
}

int __seqof1::remove_after(OssIndex pos) {
    __seqof1_member *extr = (__seqof1_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof1_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof1 *__seqof1::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof1 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __shared2 */

class __shared2_member {
public:
    __shared2_member *next;
    __shared2::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared2_member();
    __shared2_member(const __shared2::component & val);
};

void *__shared2_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared2_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared2_member::__shared2_member() {
}

__shared2_member::__shared2_member(const __shared2::component & val) {
    value = val;
}

static void *__shared2_copy(void *that) {
    return new __shared2_member(((__shared2_member *)that)->value);
}

static void __shared2_destroy(void *that) {
    delete (__shared2_member *)that;
}

static int __shared2_compare(void *val1, void *val2) {
    return (((__shared2_member *)val1)->value == ((__shared2_member *)val2)->value);
}

/* Constructors */

__shared2::__shared2() {
}

__shared2::__shared2(const __shared2 & that) {
    OSSTRY {
	do_copy(that, &__shared2_copy);
    } OSSCLEAN(__shared2)
}

/* Destructor */

__shared2::~__shared2() {
    do_destroy(&__shared2_destroy);
}

/* Operators: assignment, equality, inequality */

__shared2 & __shared2::operator = (const __shared2 & that) {
    do_destroy(&__shared2_destroy);
    do_copy(that, &__shared2_copy);
    return *this;
}

int __shared2::operator == (const __shared2 & that) const {
    return do_compare(that, &__shared2_compare);
}

int __shared2::operator != (const __shared2 & that) const {
    return !do_compare(that, &__shared2_compare);
}

/* Locate ("At" etc) methods */

__shared2::component *__shared2::at(OssIndex pos) {
    return &((__shared2_member *)pos)->value;
}

const __shared2::component *__shared2::at(OssIndex pos) const {
    return &((__shared2_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared2::prepend(const component & val) {
    __shared2_member *newrec = new __shared2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared2::prepend(__shared2 *seq) {
    return do_prepend(seq);
}

OssIndex __shared2::insert_after(OssIndex pos, const component & val) {
    __shared2_member *newrec = new __shared2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared2::insert_after(OssIndex pos, __shared2 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared2::remove_front() {
    __shared2_member *extr = (__shared2_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared2_destroy(extr);
    return 0;
}

int __shared2::remove_after(OssIndex pos) {
    __shared2_member *extr = (__shared2_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared2_destroy(extr);
    return 0;
}

/* Extract methods */

__shared2 *__shared2::extract_after(OssIndex begin, OssIndex end) {
    return (__shared2 *)do_extract_after(begin, end);
}

void *__seq5::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq5::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq5::__seq5() {
    memset(this, 0, sizeof(__seq5));
}

__seq5::__seq5(const __seq5 & that) {
    OSSTRY {
	notBefore_field = that.notBefore_field;
	notAfter_field = that.notAfter_field;
    } OSSCLEAN(__seq5)
}

__seq5::__seq5(const notBefore & notBefore_val, const notAfter & notAfter_val) {
    OSSTRY {
	notBefore_field = notBefore_val;
	notAfter_field = notAfter_val;
    } OSSCLEAN(__seq5)
}

__seq5 & __seq5::operator = (const __seq5 & that) {
    if (this == &that)
	return *this;
    notBefore_field = that.notBefore_field;
    notAfter_field = that.notAfter_field;
    return *this;
}

int __seq5::operator == (const __seq5 & that) const {
    if (notBefore_field != that.notBefore_field)
	return 0;
    if (notAfter_field != that.notAfter_field)
	return 0;
    return 1;
}

int __seq5::operator != (const __seq5 & that) const {
    return !(operator ==(that));
}

__seq5::notBefore & __seq5::get_notBefore() {
    return notBefore_field;
}

const __seq5::notBefore & __seq5::get_notBefore() const {
    return notBefore_field;
}

void __seq5::set_notBefore(const notBefore & notBefore_val) {
    notBefore_field = notBefore_val;
}

__seq5::notAfter & __seq5::get_notAfter() {
    return notAfter_field;
}

const __seq5::notAfter & __seq5::get_notAfter() const {
    return notAfter_field;
}

void __seq5::set_notAfter(const notAfter & notAfter_val) {
    notAfter_field = notAfter_val;
}

void *TrustLevel::operator new(size_t size) {
    return ossNewFunc(size);
}

void TrustLevel::operator delete(void *ptr) {
    asn1Free(ptr);
}

TrustLevel::TrustLevel() {
    memset(this, 0, sizeof(TrustLevel));
}

TrustLevel::TrustLevel(const TrustLevel & that) {
    OSSTRY {
	trust_field = that.trust_field;
    } OSSCLEAN(TrustLevel)
}

TrustLevel::TrustLevel(trust trust_val) {
    OSSTRY {
	trust_field = trust_val;
    } OSSCLEAN(TrustLevel)
}

TrustLevel & TrustLevel::operator = (const TrustLevel & that) {
    if (this == &that)
	return *this;
    trust_field = that.trust_field;
    return *this;
}

int TrustLevel::operator == (const TrustLevel & that) const {
    if (trust_field != that.trust_field)
	return 0;
    return 1;
}

int TrustLevel::operator != (const TrustLevel & that) const {
    return !(operator ==(that));
}

TrustLevel::trust & TrustLevel::get_trust() {
    return trust_field;
}

TrustLevel::trust TrustLevel::get_trust() const {
    return trust_field;
}

void TrustLevel::set_trust(trust trust_val) {
    trust_field = trust_val;
}

/* Auxiliary data structures and functions for class __seqof15 */

class __seqof15_member {
public:
    __seqof15_member *next;
    __seqof15::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof15_member();
    __seqof15_member(const __seqof15::component & val);
};

void *__seqof15_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof15_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof15_member::__seqof15_member() {
}

__seqof15_member::__seqof15_member(const __seqof15::component & val) {
    value = val;
}

static void *__seqof15_copy(void *that) {
    return new __seqof15_member(((__seqof15_member *)that)->value);
}

static void __seqof15_destroy(void *that) {
    delete (__seqof15_member *)that;
}

static int __seqof15_compare(void *val1, void *val2) {
    return (((__seqof15_member *)val1)->value == ((__seqof15_member *)val2)->value);
}

/* Constructors */

__seqof15::__seqof15() {
}

__seqof15::__seqof15(const __seqof15 & that) {
    OSSTRY {
	do_copy(that, &__seqof15_copy);
    } OSSCLEAN(__seqof15)
}

/* Destructor */

__seqof15::~__seqof15() {
    do_destroy(&__seqof15_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof15 & __seqof15::operator = (const __seqof15 & that) {
    do_destroy(&__seqof15_destroy);
    do_copy(that, &__seqof15_copy);
    return *this;
}

int __seqof15::operator == (const __seqof15 & that) const {
    return do_compare(that, &__seqof15_compare);
}

int __seqof15::operator != (const __seqof15 & that) const {
    return !do_compare(that, &__seqof15_compare);
}

/* Locate ("At" etc) methods */

__seqof15::component *__seqof15::at(OssIndex pos) {
    return &((__seqof15_member *)pos)->value;
}

const __seqof15::component *__seqof15::at(OssIndex pos) const {
    return &((__seqof15_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof15::prepend(const component & val) {
    __seqof15_member *newrec = new __seqof15_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof15::prepend(__seqof15 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof15::insert_after(OssIndex pos, const component & val) {
    __seqof15_member *newrec = new __seqof15_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof15::insert_after(OssIndex pos, __seqof15 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof15::remove_front() {
    __seqof15_member *extr = (__seqof15_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof15_destroy(extr);
    return 0;
}

int __seqof15::remove_after(OssIndex pos) {
    __seqof15_member *extr = (__seqof15_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof15_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof15 *__seqof15::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof15 *)do_extract_after(begin, end);
}

void *RTreePolicy::operator new(size_t size) {
    return ossNewFunc(size);
}

void RTreePolicy::operator delete(void *ptr) {
    asn1Free(ptr);
}

RTreePolicy::RTreePolicy() {
    memset(this, 0, sizeof(RTreePolicy));
}

RTreePolicy::RTreePolicy(const RTreePolicy & that) {
    OSSTRY {
	RTreePolicy_namespace_field = that.RTreePolicy_namespace_field;
	indirections_field = that.indirections_field;
	statements_field = that.statements_field;
    } OSSCLEAN(RTreePolicy)
}

RTreePolicy::RTreePolicy(const RTreePolicy_namespace & RTreePolicy_namespace_val, 
    indirections indirections_val, const statements & statements_val) {
    OSSTRY {
	RTreePolicy_namespace_field = RTreePolicy_namespace_val;
	indirections_field = indirections_val;
	statements_field = statements_val;
    } OSSCLEAN(RTreePolicy)
}

RTreePolicy & RTreePolicy::operator = (const RTreePolicy & that) {
    if (this == &that)
	return *this;
    RTreePolicy_namespace_field = that.RTreePolicy_namespace_field;
    indirections_field = that.indirections_field;
    statements_field = that.statements_field;
    return *this;
}

int RTreePolicy::operator == (const RTreePolicy & that) const {
    if (RTreePolicy_namespace_field != that.RTreePolicy_namespace_field)
	return 0;
    if (indirections_field != that.indirections_field)
	return 0;
    if (statements_field != that.statements_field)
	return 0;
    return 1;
}

int RTreePolicy::operator != (const RTreePolicy & that) const {
    return !(operator ==(that));
}

RTreePolicy::RTreePolicy_namespace & RTreePolicy::get_RTreePolicy_namespace() {
    return RTreePolicy_namespace_field;
}

const RTreePolicy::RTreePolicy_namespace & RTreePolicy::get_RTreePolicy_namespace() const {
    return RTreePolicy_namespace_field;
}

void RTreePolicy::set_RTreePolicy_namespace(const RTreePolicy_namespace & RTreePolicy_namespace_val) {
    RTreePolicy_namespace_field = RTreePolicy_namespace_val;
}

RTreePolicy::indirections & RTreePolicy::get_indirections() {
    return indirections_field;
}

RTreePolicy::indirections RTreePolicy::get_indirections() const {
    return indirections_field;
}

void RTreePolicy::set_indirections(indirections indirections_val) {
    indirections_field = indirections_val;
}

RTreePolicy::statements & RTreePolicy::get_statements() {
    return statements_field;
}

const RTreePolicy::statements & RTreePolicy::get_statements() const {
    return statements_field;
}

void RTreePolicy::set_statements(const statements & statements_val) {
    statements_field = statements_val;
}

PolicySchemes_Type::PolicySchemes_Type()
{
}

PolicySchemes_Type::PolicySchemes_Type(const PolicySchemes_Type & that)
{
    operator =(that);
}

PolicySchemes_Type::~PolicySchemes_Type()
{
    cleanup_decoded();
}

PolicySchemes_Type & PolicySchemes_Type::operator = (const PolicySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int PolicySchemes_Type::operator == (const PolicySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int PolicySchemes_Type::operator != (const PolicySchemes_Type & that) const
{
    return !(operator ==(that));
}

int PolicySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int PolicySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int PolicySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int PolicySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int PolicySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

TrustLevel *PolicySchemes_Type::get_TrustLevel()
{
    if (pdunum == 22)
	return (TrustLevel *)decoded;
    else
	return NULL;
}

const TrustLevel *PolicySchemes_Type::get_TrustLevel() const
{
    if (pdunum == 22)
	return (const TrustLevel *)decoded;
    else
	return NULL;
}

void PolicySchemes_Type::set_TrustLevel(const TrustLevel & data)
{
    void *copy;

    copy = new TrustLevel(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 22;
	decoded = copy;
    }
}

TrustLevel *PolicySchemes_Type::release_TrustLevel()
{
    pdunum = 0;
    decoded = NULL;
    return get_TrustLevel();
}

void PolicySchemes_Type::set_TrustLevel(TrustLevel *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 22;
    decoded = data;
}

RTreePolicy *PolicySchemes_Type::get_RTreePolicy()
{
    if (pdunum == 9)
	return (RTreePolicy *)decoded;
    else
	return NULL;
}

const RTreePolicy *PolicySchemes_Type::get_RTreePolicy() const
{
    if (pdunum == 9)
	return (const RTreePolicy *)decoded;
    else
	return NULL;
}

void PolicySchemes_Type::set_RTreePolicy(const RTreePolicy & data)
{
    void *copy;

    copy = new RTreePolicy(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 9;
	decoded = copy;
    }
}

RTreePolicy *PolicySchemes_Type::release_RTreePolicy()
{
    pdunum = 0;
    decoded = NULL;
    return get_RTreePolicy();
}

void PolicySchemes_Type::set_RTreePolicy(RTreePolicy *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 9;
    decoded = data;
}

void PolicySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq6::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq6::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq6::__seq6() {
    memset(this, 0, sizeof(__seq6));
}

__seq6::__seq6(const __seq6 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq6)
}

__seq6::__seq6(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq6)
}

__seq6 & __seq6::operator = (const __seq6 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq6::operator == (const __seq6 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq6::operator != (const __seq6 & that) const {
    return !(operator ==(that));
}

__seq6::type_id & __seq6::get_type_id() {
    return type_id_field;
}

const __seq6::type_id & __seq6::get_type_id() const {
    return type_id_field;
}

void __seq6::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq6::value & __seq6::get_value() {
    return value_field;
}

const __seq6::value & __seq6::get_value() const {
    return value_field;
}

void __seq6::set_value(const value & value_val) {
    value_field = value_val;
}

void *__seq11::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq11::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq11::__seq11() {
    memset(this, 0, sizeof(__seq11));
}

__seq11::__seq11(const __seq11 & that) {
    OSSTRY {
	outerSignatureScheme_field = that.outerSignatureScheme_field;
	verifyingKey_field = that.verifyingKey_field;
    } OSSCLEAN(__seq11)
}

__seq11::__seq11(const outerSignatureScheme & outerSignatureScheme_val, const verifyingKey & verifyingKey_val) {
    OSSTRY {
	outerSignatureScheme_field = outerSignatureScheme_val;
	verifyingKey_field = verifyingKey_val;
    } OSSCLEAN(__seq11)
}

__seq11 & __seq11::operator = (const __seq11 & that) {
    if (this == &that)
	return *this;
    outerSignatureScheme_field = that.outerSignatureScheme_field;
    verifyingKey_field = that.verifyingKey_field;
    return *this;
}

int __seq11::operator == (const __seq11 & that) const {
    if (outerSignatureScheme_field != that.outerSignatureScheme_field)
	return 0;
    if (verifyingKey_field != that.verifyingKey_field)
	return 0;
    return 1;
}

int __seq11::operator != (const __seq11 & that) const {
    return !(operator ==(that));
}

__seq11::outerSignatureScheme & __seq11::get_outerSignatureScheme() {
    return outerSignatureScheme_field;
}

const __seq11::outerSignatureScheme & __seq11::get_outerSignatureScheme() const {
    return outerSignatureScheme_field;
}

void __seq11::set_outerSignatureScheme(const outerSignatureScheme & outerSignatureScheme_val) {
    outerSignatureScheme_field = outerSignatureScheme_val;
}

__seq11::verifyingKey & __seq11::get_verifyingKey() {
    return verifyingKey_field;
}

const __seq11::verifyingKey & __seq11::get_verifyingKey() const {
    return verifyingKey_field;
}

void __seq11::set_verifyingKey(const verifyingKey & verifyingKey_val) {
    verifyingKey_field = verifyingKey_val;
}

void *SignedOuterKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void SignedOuterKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

SignedOuterKey::SignedOuterKey() {
    memset(this, 0, sizeof(SignedOuterKey));
}

SignedOuterKey::SignedOuterKey(const SignedOuterKey & that) {
    OSSTRY {
	tbs_field = that.tbs_field;
	signature_field = that.signature_field;
    } OSSCLEAN(SignedOuterKey)
}

SignedOuterKey::SignedOuterKey(const tbs & tbs_val, const signature & signature_val) {
    OSSTRY {
	tbs_field = tbs_val;
	signature_field = signature_val;
    } OSSCLEAN(SignedOuterKey)
}

SignedOuterKey & SignedOuterKey::operator = (const SignedOuterKey & that) {
    if (this == &that)
	return *this;
    tbs_field = that.tbs_field;
    signature_field = that.signature_field;
    return *this;
}

int SignedOuterKey::operator == (const SignedOuterKey & that) const {
    if (tbs_field != that.tbs_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    return 1;
}

int SignedOuterKey::operator != (const SignedOuterKey & that) const {
    return !(operator ==(that));
}

SignedOuterKey::tbs & SignedOuterKey::get_tbs() {
    return tbs_field;
}

const SignedOuterKey::tbs & SignedOuterKey::get_tbs() const {
    return tbs_field;
}

void SignedOuterKey::set_tbs(const tbs & tbs_val) {
    tbs_field = tbs_val;
}

SignedOuterKey::signature & SignedOuterKey::get_signature() {
    return signature_field;
}

const SignedOuterKey::signature & SignedOuterKey::get_signature() const {
    return signature_field;
}

void SignedOuterKey::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

OuterSignatureBindingSchemes_Type::OuterSignatureBindingSchemes_Type()
{
}

OuterSignatureBindingSchemes_Type::OuterSignatureBindingSchemes_Type(const OuterSignatureBindingSchemes_Type & that)
{
    operator =(that);
}

OuterSignatureBindingSchemes_Type::~OuterSignatureBindingSchemes_Type()
{
    cleanup_decoded();
}

OuterSignatureBindingSchemes_Type & OuterSignatureBindingSchemes_Type::operator = (const OuterSignatureBindingSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int OuterSignatureBindingSchemes_Type::operator == (const OuterSignatureBindingSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int OuterSignatureBindingSchemes_Type::operator != (const OuterSignatureBindingSchemes_Type & that) const
{
    return !(operator ==(that));
}

int OuterSignatureBindingSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int OuterSignatureBindingSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int OuterSignatureBindingSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int OuterSignatureBindingSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int OuterSignatureBindingSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

SignedOuterKey *OuterSignatureBindingSchemes_Type::get_SignedOuterKey()
{
    if (pdunum == 21)
	return (SignedOuterKey *)decoded;
    else
	return NULL;
}

const SignedOuterKey *OuterSignatureBindingSchemes_Type::get_SignedOuterKey() const
{
    if (pdunum == 21)
	return (const SignedOuterKey *)decoded;
    else
	return NULL;
}

void OuterSignatureBindingSchemes_Type::set_SignedOuterKey(const SignedOuterKey & data)
{
    void *copy;

    copy = new SignedOuterKey(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 21;
	decoded = copy;
    }
}

SignedOuterKey *OuterSignatureBindingSchemes_Type::release_SignedOuterKey()
{
    pdunum = 0;
    decoded = NULL;
    return get_SignedOuterKey();
}

void OuterSignatureBindingSchemes_Type::set_SignedOuterKey(SignedOuterKey *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 21;
    decoded = data;
}

void OuterSignatureBindingSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq7::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq7::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq7::__seq7() {
    memset(this, 0, sizeof(__seq7));
}

__seq7::__seq7(const __seq7 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq7)
}

__seq7::__seq7(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq7)
}

__seq7 & __seq7::operator = (const __seq7 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq7::operator == (const __seq7 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq7::operator != (const __seq7 & that) const {
    return !(operator ==(that));
}

__seq7::type_id & __seq7::get_type_id() {
    return type_id_field;
}

const __seq7::type_id & __seq7::get_type_id() const {
    return type_id_field;
}

void __seq7::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq7::value & __seq7::get_value() {
    return value_field;
}

const __seq7::value & __seq7::get_value() const {
    return value_field;
}

void __seq7::set_value(const value & value_val) {
    value_field = value_val;
}

void *AttestationVerifierBody::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttestationVerifierBody::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttestationVerifierBody::AttestationVerifierBody() {
    memset(this, 0, sizeof(AttestationVerifierBody));
}

AttestationVerifierBody::AttestationVerifierBody(const AttestationVerifierBody & that) {
    OSSTRY {
	attester_field = that.attester_field;
	attesterLocation_field = that.attesterLocation_field;
	validity_field = that.validity_field;
	policy_field = that.policy_field;
	extensions_field = that.extensions_field;
	outerSignatureBinding_field = that.outerSignatureBinding_field;
    } OSSCLEAN(AttestationVerifierBody)
}

AttestationVerifierBody::AttestationVerifierBody(const attester & attester_val, const attesterLocation & attesterLocation_val, 
    const validity & validity_val, const policy & policy_val, const extensions & extensions_val, 
    const outerSignatureBinding & outerSignatureBinding_val) {
    OSSTRY {
	attester_field = attester_val;
	attesterLocation_field = attesterLocation_val;
	validity_field = validity_val;
	policy_field = policy_val;
	extensions_field = extensions_val;
	outerSignatureBinding_field = outerSignatureBinding_val;
    } OSSCLEAN(AttestationVerifierBody)
}

AttestationVerifierBody & AttestationVerifierBody::operator = (const AttestationVerifierBody & that) {
    if (this == &that)
	return *this;
    attester_field = that.attester_field;
    attesterLocation_field = that.attesterLocation_field;
    validity_field = that.validity_field;
    policy_field = that.policy_field;
    extensions_field = that.extensions_field;
    outerSignatureBinding_field = that.outerSignatureBinding_field;
    return *this;
}

int AttestationVerifierBody::operator == (const AttestationVerifierBody & that) const {
    if (attester_field != that.attester_field)
	return 0;
    if (attesterLocation_field != that.attesterLocation_field)
	return 0;
    if (validity_field != that.validity_field)
	return 0;
    if (policy_field != that.policy_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    if (outerSignatureBinding_field != that.outerSignatureBinding_field)
	return 0;
    return 1;
}

int AttestationVerifierBody::operator != (const AttestationVerifierBody & that) const {
    return !(operator ==(that));
}

AttestationVerifierBody::attester & AttestationVerifierBody::get_attester() {
    return attester_field;
}

const AttestationVerifierBody::attester & AttestationVerifierBody::get_attester() const {
    return attester_field;
}

void AttestationVerifierBody::set_attester(const attester & attester_val) {
    attester_field = attester_val;
}

AttestationVerifierBody::attesterLocation & AttestationVerifierBody::get_attesterLocation() {
    return attesterLocation_field;
}

const AttestationVerifierBody::attesterLocation & AttestationVerifierBody::get_attesterLocation() const {
    return attesterLocation_field;
}

void AttestationVerifierBody::set_attesterLocation(const attesterLocation & attesterLocation_val) {
    attesterLocation_field = attesterLocation_val;
}

AttestationVerifierBody::validity & AttestationVerifierBody::get_validity() {
    return validity_field;
}

const AttestationVerifierBody::validity & AttestationVerifierBody::get_validity() const {
    return validity_field;
}

void AttestationVerifierBody::set_validity(const validity & validity_val) {
    validity_field = validity_val;
}

AttestationVerifierBody::policy & AttestationVerifierBody::get_policy() {
    return policy_field;
}

const AttestationVerifierBody::policy & AttestationVerifierBody::get_policy() const {
    return policy_field;
}

void AttestationVerifierBody::set_policy(const policy & policy_val) {
    policy_field = policy_val;
}

AttestationVerifierBody::extensions & AttestationVerifierBody::get_extensions() {
    return extensions_field;
}

const AttestationVerifierBody::extensions & AttestationVerifierBody::get_extensions() const {
    return extensions_field;
}

void AttestationVerifierBody::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

AttestationVerifierBody::outerSignatureBinding & AttestationVerifierBody::get_outerSignatureBinding() {
    return outerSignatureBinding_field;
}

const AttestationVerifierBody::outerSignatureBinding & AttestationVerifierBody::get_outerSignatureBinding() const {
    return outerSignatureBinding_field;
}

void AttestationVerifierBody::set_outerSignatureBinding(const outerSignatureBinding & outerSignatureBinding_val) {
    outerSignatureBinding_field = outerSignatureBinding_val;
}

/* Auxiliary data structures and functions for class __seqof3 */

class __seqof3_member {
public:
    __seqof3_member *next;
    __seqof3::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof3_member();
    __seqof3_member(const __seqof3::component & val);
};

void *__seqof3_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof3_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof3_member::__seqof3_member() {
}

__seqof3_member::__seqof3_member(const __seqof3::component & val) {
    value = val;
}

static void *__seqof3_copy(void *that) {
    return new __seqof3_member(((__seqof3_member *)that)->value);
}

static void __seqof3_destroy(void *that) {
    delete (__seqof3_member *)that;
}

static int __seqof3_compare(void *val1, void *val2) {
    return (((__seqof3_member *)val1)->value == ((__seqof3_member *)val2)->value);
}

/* Constructors */

__seqof3::__seqof3() {
}

__seqof3::__seqof3(const __seqof3 & that) {
    OSSTRY {
	do_copy(that, &__seqof3_copy);
    } OSSCLEAN(__seqof3)
}

/* Destructor */

__seqof3::~__seqof3() {
    do_destroy(&__seqof3_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof3 & __seqof3::operator = (const __seqof3 & that) {
    do_destroy(&__seqof3_destroy);
    do_copy(that, &__seqof3_copy);
    return *this;
}

int __seqof3::operator == (const __seqof3 & that) const {
    return do_compare(that, &__seqof3_compare);
}

int __seqof3::operator != (const __seqof3 & that) const {
    return !do_compare(that, &__seqof3_compare);
}

/* Locate ("At" etc) methods */

__seqof3::component *__seqof3::at(OssIndex pos) {
    return &((__seqof3_member *)pos)->value;
}

const __seqof3::component *__seqof3::at(OssIndex pos) const {
    return &((__seqof3_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof3::prepend(const component & val) {
    __seqof3_member *newrec = new __seqof3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof3::prepend(__seqof3 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof3::insert_after(OssIndex pos, const component & val) {
    __seqof3_member *newrec = new __seqof3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof3::insert_after(OssIndex pos, __seqof3 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof3::remove_front() {
    __seqof3_member *extr = (__seqof3_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof3_destroy(extr);
    return 0;
}

int __seqof3::remove_after(OssIndex pos) {
    __seqof3_member *extr = (__seqof3_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof3_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof3 *__seqof3::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof3 *)do_extract_after(begin, end);
}

void *AttestationBody::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttestationBody::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttestationBody::AttestationBody() {
    memset(this, 0, sizeof(AttestationBody));
}

AttestationBody::AttestationBody(const AttestationBody & that) {
    OSSTRY {
	verifierBody_field = that.verifierBody_field;
	proverPolicyAddendums_field = that.proverPolicyAddendums_field;
	proverExtensions_field = that.proverExtensions_field;
    } OSSCLEAN(AttestationBody)
}

AttestationBody::AttestationBody(const verifierBody & verifierBody_val, const proverPolicyAddendums & proverPolicyAddendums_val, 
    const proverExtensions & proverExtensions_val) {
    OSSTRY {
	verifierBody_field = verifierBody_val;
	proverPolicyAddendums_field = proverPolicyAddendums_val;
	proverExtensions_field = proverExtensions_val;
    } OSSCLEAN(AttestationBody)
}

AttestationBody & AttestationBody::operator = (const AttestationBody & that) {
    if (this == &that)
	return *this;
    verifierBody_field = that.verifierBody_field;
    proverPolicyAddendums_field = that.proverPolicyAddendums_field;
    proverExtensions_field = that.proverExtensions_field;
    return *this;
}

int AttestationBody::operator == (const AttestationBody & that) const {
    if (verifierBody_field != that.verifierBody_field)
	return 0;
    if (proverPolicyAddendums_field != that.proverPolicyAddendums_field)
	return 0;
    if (proverExtensions_field != that.proverExtensions_field)
	return 0;
    return 1;
}

int AttestationBody::operator != (const AttestationBody & that) const {
    return !(operator ==(that));
}

AttestationBody::verifierBody & AttestationBody::get_verifierBody() {
    return verifierBody_field;
}

const AttestationBody::verifierBody & AttestationBody::get_verifierBody() const {
    return verifierBody_field;
}

void AttestationBody::set_verifierBody(const verifierBody & verifierBody_val) {
    verifierBody_field = verifierBody_val;
}

AttestationBody::proverPolicyAddendums & AttestationBody::get_proverPolicyAddendums() {
    return proverPolicyAddendums_field;
}

const AttestationBody::proverPolicyAddendums & AttestationBody::get_proverPolicyAddendums() const {
    return proverPolicyAddendums_field;
}

void AttestationBody::set_proverPolicyAddendums(const proverPolicyAddendums & proverPolicyAddendums_val) {
    proverPolicyAddendums_field = proverPolicyAddendums_val;
}

AttestationBody::proverExtensions & AttestationBody::get_proverExtensions() {
    return proverExtensions_field;
}

const AttestationBody::proverExtensions & AttestationBody::get_proverExtensions() const {
    return proverExtensions_field;
}

void AttestationBody::set_proverExtensions(const proverExtensions & proverExtensions_val) {
    proverExtensions_field = proverExtensions_val;
}

void *WR1BodyCiphertext::operator new(size_t size) {
    return ossNewFunc(size);
}

void WR1BodyCiphertext::operator delete(void *ptr) {
    asn1Free(ptr);
}

WR1BodyCiphertext::WR1BodyCiphertext() {
    memset(this, 0, sizeof(WR1BodyCiphertext));
}

WR1BodyCiphertext::WR1BodyCiphertext(const WR1BodyCiphertext & that) {
    OSSTRY {
	verifierBodyCiphertext_field = that.verifierBodyCiphertext_field;
	proverBodyCiphertext_field = that.proverBodyCiphertext_field;
	envelopeCiphertext_field = that.envelopeCiphertext_field;
	envelopeKey_ibe_bn256_field = that.envelopeKey_ibe_bn256_field;
	envelopeKey_curve25519_field = that.envelopeKey_curve25519_field;
    } OSSCLEAN(WR1BodyCiphertext)
}

WR1BodyCiphertext::WR1BodyCiphertext(const verifierBodyCiphertext & verifierBodyCiphertext_val, 
    const proverBodyCiphertext & proverBodyCiphertext_val, const envelopeCiphertext & envelopeCiphertext_val, 
    const envelopeKey_ibe_bn256 & envelopeKey_ibe_bn256_val, const envelopeKey_curve25519 & envelopeKey_curve25519_val) {
    OSSTRY {
	verifierBodyCiphertext_field = verifierBodyCiphertext_val;
	proverBodyCiphertext_field = proverBodyCiphertext_val;
	envelopeCiphertext_field = envelopeCiphertext_val;
	envelopeKey_ibe_bn256_field = envelopeKey_ibe_bn256_val;
	envelopeKey_curve25519_field = envelopeKey_curve25519_val;
    } OSSCLEAN(WR1BodyCiphertext)
}

WR1BodyCiphertext & WR1BodyCiphertext::operator = (const WR1BodyCiphertext & that) {
    if (this == &that)
	return *this;
    verifierBodyCiphertext_field = that.verifierBodyCiphertext_field;
    proverBodyCiphertext_field = that.proverBodyCiphertext_field;
    envelopeCiphertext_field = that.envelopeCiphertext_field;
    envelopeKey_ibe_bn256_field = that.envelopeKey_ibe_bn256_field;
    envelopeKey_curve25519_field = that.envelopeKey_curve25519_field;
    return *this;
}

int WR1BodyCiphertext::operator == (const WR1BodyCiphertext & that) const {
    if (verifierBodyCiphertext_field != that.verifierBodyCiphertext_field)
	return 0;
    if (proverBodyCiphertext_field != that.proverBodyCiphertext_field)
	return 0;
    if (envelopeCiphertext_field != that.envelopeCiphertext_field)
	return 0;
    if (envelopeKey_ibe_bn256_field != that.envelopeKey_ibe_bn256_field)
	return 0;
    if (envelopeKey_curve25519_field != that.envelopeKey_curve25519_field)
	return 0;
    return 1;
}

int WR1BodyCiphertext::operator != (const WR1BodyCiphertext & that) const {
    return !(operator ==(that));
}

WR1BodyCiphertext::verifierBodyCiphertext & WR1BodyCiphertext::get_verifierBodyCiphertext() {
    return verifierBodyCiphertext_field;
}

const WR1BodyCiphertext::verifierBodyCiphertext & WR1BodyCiphertext::get_verifierBodyCiphertext() const {
    return verifierBodyCiphertext_field;
}

void WR1BodyCiphertext::set_verifierBodyCiphertext(const verifierBodyCiphertext & verifierBodyCiphertext_val) {
    verifierBodyCiphertext_field = verifierBodyCiphertext_val;
}

WR1BodyCiphertext::proverBodyCiphertext & WR1BodyCiphertext::get_proverBodyCiphertext() {
    return proverBodyCiphertext_field;
}

const WR1BodyCiphertext::proverBodyCiphertext & WR1BodyCiphertext::get_proverBodyCiphertext() const {
    return proverBodyCiphertext_field;
}

void WR1BodyCiphertext::set_proverBodyCiphertext(const proverBodyCiphertext & proverBodyCiphertext_val) {
    proverBodyCiphertext_field = proverBodyCiphertext_val;
}

WR1BodyCiphertext::envelopeCiphertext & WR1BodyCiphertext::get_envelopeCiphertext() {
    return envelopeCiphertext_field;
}

const WR1BodyCiphertext::envelopeCiphertext & WR1BodyCiphertext::get_envelopeCiphertext() const {
    return envelopeCiphertext_field;
}

void WR1BodyCiphertext::set_envelopeCiphertext(const envelopeCiphertext & envelopeCiphertext_val) {
    envelopeCiphertext_field = envelopeCiphertext_val;
}

WR1BodyCiphertext::envelopeKey_ibe_bn256 & WR1BodyCiphertext::get_envelopeKey_ibe_bn256() {
    return envelopeKey_ibe_bn256_field;
}

const WR1BodyCiphertext::envelopeKey_ibe_bn256 & WR1BodyCiphertext::get_envelopeKey_ibe_bn256() const {
    return envelopeKey_ibe_bn256_field;
}

void WR1BodyCiphertext::set_envelopeKey_ibe_bn256(const envelopeKey_ibe_bn256 & envelopeKey_ibe_bn256_val) {
    envelopeKey_ibe_bn256_field = envelopeKey_ibe_bn256_val;
}

WR1BodyCiphertext::envelopeKey_curve25519 & WR1BodyCiphertext::get_envelopeKey_curve25519() {
    return envelopeKey_curve25519_field;
}

const WR1BodyCiphertext::envelopeKey_curve25519 & WR1BodyCiphertext::get_envelopeKey_curve25519() const {
    return envelopeKey_curve25519_field;
}

void WR1BodyCiphertext::set_envelopeKey_curve25519(const envelopeKey_curve25519 & envelopeKey_curve25519_val) {
    envelopeKey_curve25519_field = envelopeKey_curve25519_val;
}

/* Auxiliary data structures and functions for class __shared4 */

class __shared4_member {
public:
    __shared4_member *next;
    __shared4::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
};

void *__shared4_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared4_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

static void *__shared4_copy(void *that) {
    __shared4_member *result = new __shared4_member;
    if (result)
	result->value = ((__shared4_member *)that)->value;
    return result;
}

static void __shared4_destroy(void *that) {
    delete (__shared4_member *)that;
}

static int __shared4_compare(void *val1, void *val2) {
    return (((__shared4_member *)val1)->value == ((__shared4_member *)val2)->value);
}

/* Constructors */

__shared4::__shared4() {
}

__shared4::__shared4(const __shared4 & that) {
    OSSTRY {
	do_copy(that, &__shared4_copy);
    } OSSCLEAN(__shared4)
}

/* Destructor */

__shared4::~__shared4() {
    do_destroy(&__shared4_destroy);
}

/* Operators: assignment, equality, inequality */

__shared4 & __shared4::operator = (const __shared4 & that) {
    do_destroy(&__shared4_destroy);
    do_copy(that, &__shared4_copy);
    return *this;
}

int __shared4::operator == (const __shared4 & that) const {
    return do_compare(that, &__shared4_compare);
}

int __shared4::operator != (const __shared4 & that) const {
    return !do_compare(that, &__shared4_compare);
}

/* Locate ("At" etc) methods */

__shared4::component *__shared4::at(OssIndex pos) {
    return &((__shared4_member *)pos)->value;
}

const __shared4::component *__shared4::at(OssIndex pos) const {
    return &((__shared4_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared4::prepend(component val) {
    __shared4_member *newrec = new __shared4_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_prepend(newrec);
}

OssIndex __shared4::prepend(__shared4 *seq) {
    return do_prepend(seq);
}

OssIndex __shared4::insert_after(OssIndex pos, component val) {
    __shared4_member *newrec = new __shared4_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_insert_after(pos, newrec);
}

OssIndex __shared4::insert_after(OssIndex pos, __shared4 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared4::remove_front() {
    __shared4_member *extr = (__shared4_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared4_destroy(extr);
    return 0;
}

int __shared4::remove_after(OssIndex pos) {
    __shared4_member *extr = (__shared4_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared4_destroy(extr);
    return 0;
}

/* Extract methods */

__shared4 *__shared4::extract_after(OssIndex begin, OssIndex end) {
    return (__shared4 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __shared3 */

class __shared3_member {
public:
    __shared3_member *next;
    __shared3::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared3_member();
    __shared3_member(const __shared3::component & val);
};

void *__shared3_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared3_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared3_member::__shared3_member() {
}

__shared3_member::__shared3_member(const __shared3::component & val) {
    value = val;
}

static void *__shared3_copy(void *that) {
    return new __shared3_member(((__shared3_member *)that)->value);
}

static void __shared3_destroy(void *that) {
    delete (__shared3_member *)that;
}

static int __shared3_compare(void *val1, void *val2) {
    return (((__shared3_member *)val1)->value == ((__shared3_member *)val2)->value);
}

/* Constructors */

__shared3::__shared3() {
}

__shared3::__shared3(const __shared3 & that) {
    OSSTRY {
	do_copy(that, &__shared3_copy);
    } OSSCLEAN(__shared3)
}

/* Destructor */

__shared3::~__shared3() {
    do_destroy(&__shared3_destroy);
}

/* Operators: assignment, equality, inequality */

__shared3 & __shared3::operator = (const __shared3 & that) {
    do_destroy(&__shared3_destroy);
    do_copy(that, &__shared3_copy);
    return *this;
}

int __shared3::operator == (const __shared3 & that) const {
    return do_compare(that, &__shared3_compare);
}

int __shared3::operator != (const __shared3 & that) const {
    return !do_compare(that, &__shared3_compare);
}

/* Locate ("At" etc) methods */

__shared3::component *__shared3::at(OssIndex pos) {
    return &((__shared3_member *)pos)->value;
}

const __shared3::component *__shared3::at(OssIndex pos) const {
    return &((__shared3_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared3::prepend(const component & val) {
    __shared3_member *newrec = new __shared3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared3::prepend(__shared3 *seq) {
    return do_prepend(seq);
}

OssIndex __shared3::insert_after(OssIndex pos, const component & val) {
    __shared3_member *newrec = new __shared3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared3::insert_after(OssIndex pos, __shared3 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared3::remove_front() {
    __shared3_member *extr = (__shared3_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared3_destroy(extr);
    return 0;
}

int __shared3::remove_after(OssIndex pos) {
    __shared3_member *extr = (__shared3_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared3_destroy(extr);
    return 0;
}

/* Extract methods */

__shared3 *__shared3::extract_after(OssIndex begin, OssIndex end) {
    return (__shared3 *)do_extract_after(begin, end);
}

void *Public_OAQUE::operator new(size_t size) {
    return ossNewFunc(size);
}

void Public_OAQUE::operator delete(void *ptr) {
    asn1Free(ptr);
}

Public_OAQUE::Public_OAQUE() {
    memset(this, 0, sizeof(Public_OAQUE));
}

Public_OAQUE::Public_OAQUE(const Public_OAQUE & that) {
    OSSTRY {
	params_field = that.params_field;
	attributeset_field = that.attributeset_field;
    } OSSCLEAN(Public_OAQUE)
}

Public_OAQUE::Public_OAQUE(const params & params_val, const attributeset & attributeset_val) {
    OSSTRY {
	params_field = params_val;
	attributeset_field = attributeset_val;
    } OSSCLEAN(Public_OAQUE)
}

Public_OAQUE & Public_OAQUE::operator = (const Public_OAQUE & that) {
    if (this == &that)
	return *this;
    params_field = that.params_field;
    attributeset_field = that.attributeset_field;
    return *this;
}

int Public_OAQUE::operator == (const Public_OAQUE & that) const {
    if (params_field != that.params_field)
	return 0;
    if (attributeset_field != that.attributeset_field)
	return 0;
    return 1;
}

int Public_OAQUE::operator != (const Public_OAQUE & that) const {
    return !(operator ==(that));
}

Public_OAQUE::params & Public_OAQUE::get_params() {
    return params_field;
}

const Public_OAQUE::params & Public_OAQUE::get_params() const {
    return params_field;
}

void Public_OAQUE::set_params(const params & params_val) {
    params_field = params_val;
}

Public_OAQUE::attributeset & Public_OAQUE::get_attributeset() {
    return attributeset_field;
}

const Public_OAQUE::attributeset & Public_OAQUE::get_attributeset() const {
    return attributeset_field;
}

void Public_OAQUE::set_attributeset(const attributeset & attributeset_val) {
    attributeset_field = attributeset_val;
}

void *Public_BN256_IBE::operator new(size_t size) {
    return ossNewFunc(size);
}

void Public_BN256_IBE::operator delete(void *ptr) {
    asn1Free(ptr);
}

Public_BN256_IBE::Public_BN256_IBE() {
    memset(this, 0, sizeof(Public_BN256_IBE));
}

Public_BN256_IBE::Public_BN256_IBE(const Public_BN256_IBE & that) {
    OSSTRY {
	params_field = that.params_field;
	id_field = that.id_field;
    } OSSCLEAN(Public_BN256_IBE)
}

Public_BN256_IBE::Public_BN256_IBE(const params & params_val, const id & id_val) {
    OSSTRY {
	params_field = params_val;
	id_field = id_val;
    } OSSCLEAN(Public_BN256_IBE)
}

Public_BN256_IBE & Public_BN256_IBE::operator = (const Public_BN256_IBE & that) {
    if (this == &that)
	return *this;
    params_field = that.params_field;
    id_field = that.id_field;
    return *this;
}

int Public_BN256_IBE::operator == (const Public_BN256_IBE & that) const {
    if (params_field != that.params_field)
	return 0;
    if (id_field != that.id_field)
	return 0;
    return 1;
}

int Public_BN256_IBE::operator != (const Public_BN256_IBE & that) const {
    return !(operator ==(that));
}

Public_BN256_IBE::params & Public_BN256_IBE::get_params() {
    return params_field;
}

const Public_BN256_IBE::params & Public_BN256_IBE::get_params() const {
    return params_field;
}

void Public_BN256_IBE::set_params(const params & params_val) {
    params_field = params_val;
}

Public_BN256_IBE::id & Public_BN256_IBE::get_id() {
    return id_field;
}

const Public_BN256_IBE::id & Public_BN256_IBE::get_id() const {
    return id_field;
}

void Public_BN256_IBE::set_id(const id & id_val) {
    id_field = id_val;
}

EntityKeySchemes_Type::EntityKeySchemes_Type()
{
}

EntityKeySchemes_Type::EntityKeySchemes_Type(const EntityKeySchemes_Type & that)
{
    operator =(that);
}

EntityKeySchemes_Type::~EntityKeySchemes_Type()
{
    cleanup_decoded();
}

EntityKeySchemes_Type & EntityKeySchemes_Type::operator = (const EntityKeySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int EntityKeySchemes_Type::operator == (const EntityKeySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int EntityKeySchemes_Type::operator != (const EntityKeySchemes_Type & that) const
{
    return !(operator ==(that));
}

int EntityKeySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int EntityKeySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int EntityKeySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int EntityKeySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int EntityKeySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

Public_Ed25519 *EntityKeySchemes_Type::get_Public_Ed25519()
{
    if (pdunum == 31)
	return (Public_Ed25519 *)decoded;
    else
	return NULL;
}

const Public_Ed25519 *EntityKeySchemes_Type::get_Public_Ed25519() const
{
    if (pdunum == 31)
	return (const Public_Ed25519 *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Public_Ed25519(const Public_Ed25519 & data)
{
    void *copy;

    copy = new Public_Ed25519(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 31;
	decoded = copy;
    }
}

Public_Ed25519 *EntityKeySchemes_Type::release_Public_Ed25519()
{
    pdunum = 0;
    decoded = NULL;
    return get_Public_Ed25519();
}

void EntityKeySchemes_Type::set_Public_Ed25519(Public_Ed25519 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 31;
    decoded = data;
}

Public_Curve25519 *EntityKeySchemes_Type::get_Public_Curve25519()
{
    if (pdunum == 32)
	return (Public_Curve25519 *)decoded;
    else
	return NULL;
}

const Public_Curve25519 *EntityKeySchemes_Type::get_Public_Curve25519() const
{
    if (pdunum == 32)
	return (const Public_Curve25519 *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Public_Curve25519(const Public_Curve25519 & data)
{
    void *copy;

    copy = new Public_Curve25519(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 32;
	decoded = copy;
    }
}

Public_Curve25519 *EntityKeySchemes_Type::release_Public_Curve25519()
{
    pdunum = 0;
    decoded = NULL;
    return get_Public_Curve25519();
}

void EntityKeySchemes_Type::set_Public_Curve25519(Public_Curve25519 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 32;
    decoded = data;
}

Public_OAQUE *EntityKeySchemes_Type::get_Public_OAQUE()
{
    if (pdunum == 33)
	return (Public_OAQUE *)decoded;
    else
	return NULL;
}

const Public_OAQUE *EntityKeySchemes_Type::get_Public_OAQUE() const
{
    if (pdunum == 33)
	return (const Public_OAQUE *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Public_OAQUE(const Public_OAQUE & data)
{
    void *copy;

    copy = new Public_OAQUE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 33;
	decoded = copy;
    }
}

Public_OAQUE *EntityKeySchemes_Type::release_Public_OAQUE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Public_OAQUE();
}

void EntityKeySchemes_Type::set_Public_OAQUE(Public_OAQUE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 33;
    decoded = data;
}

Params_BN256_OAQUE *EntityKeySchemes_Type::get_Params_BN256_OAQUE()
{
    if (pdunum == 34)
	return (Params_BN256_OAQUE *)decoded;
    else
	return NULL;
}

const Params_BN256_OAQUE *EntityKeySchemes_Type::get_Params_BN256_OAQUE() const
{
    if (pdunum == 34)
	return (const Params_BN256_OAQUE *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Params_BN256_OAQUE(const Params_BN256_OAQUE & data)
{
    void *copy;

    copy = new Params_BN256_OAQUE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 34;
	decoded = copy;
    }
}

Params_BN256_OAQUE *EntityKeySchemes_Type::release_Params_BN256_OAQUE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Params_BN256_OAQUE();
}

void EntityKeySchemes_Type::set_Params_BN256_OAQUE(Params_BN256_OAQUE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 34;
    decoded = data;
}

Params_BN256_IBE *EntityKeySchemes_Type::get_Params_BN256_IBE()
{
    if (pdunum == 35)
	return (Params_BN256_IBE *)decoded;
    else
	return NULL;
}

const Params_BN256_IBE *EntityKeySchemes_Type::get_Params_BN256_IBE() const
{
    if (pdunum == 35)
	return (const Params_BN256_IBE *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Params_BN256_IBE(const Params_BN256_IBE & data)
{
    void *copy;

    copy = new Params_BN256_IBE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 35;
	decoded = copy;
    }
}

Params_BN256_IBE *EntityKeySchemes_Type::release_Params_BN256_IBE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Params_BN256_IBE();
}

void EntityKeySchemes_Type::set_Params_BN256_IBE(Params_BN256_IBE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 35;
    decoded = data;
}

Public_BN256_IBE *EntityKeySchemes_Type::get_Public_BN256_IBE()
{
    if (pdunum == 36)
	return (Public_BN256_IBE *)decoded;
    else
	return NULL;
}

const Public_BN256_IBE *EntityKeySchemes_Type::get_Public_BN256_IBE() const
{
    if (pdunum == 36)
	return (const Public_BN256_IBE *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Public_BN256_IBE(const Public_BN256_IBE & data)
{
    void *copy;

    copy = new Public_BN256_IBE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 36;
	decoded = copy;
    }
}

Public_BN256_IBE *EntityKeySchemes_Type::release_Public_BN256_IBE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Public_BN256_IBE();
}

void EntityKeySchemes_Type::set_Public_BN256_IBE(Public_BN256_IBE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 36;
    decoded = data;
}

void EntityKeySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq8::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq8::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq8::__seq8() {
    memset(this, 0, sizeof(__seq8));
}

__seq8::__seq8(const __seq8 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq8)
}

__seq8::__seq8(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq8)
}

__seq8 & __seq8::operator = (const __seq8 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq8::operator == (const __seq8 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq8::operator != (const __seq8 & that) const {
    return !(operator ==(that));
}

__seq8::type_id & __seq8::get_type_id() {
    return type_id_field;
}

const __seq8::type_id & __seq8::get_type_id() const {
    return type_id_field;
}

void __seq8::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq8::value & __seq8::get_value() {
    return value_field;
}

const __seq8::value & __seq8::get_value() const {
    return value_field;
}

void __seq8::set_value(const value & value_val) {
    value_field = value_val;
}

void *EntityPublicKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void EntityPublicKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

EntityPublicKey::EntityPublicKey() {
    memset(this, 0, sizeof(EntityPublicKey));
}

EntityPublicKey::EntityPublicKey(const EntityPublicKey & that) {
    OSSTRY {
	capabilityFlags_field = that.capabilityFlags_field;
	key_field = that.key_field;
    } OSSCLEAN(EntityPublicKey)
}

EntityPublicKey::EntityPublicKey(const capabilityFlags & capabilityFlags_val, const key & key_val) {
    OSSTRY {
	capabilityFlags_field = capabilityFlags_val;
	key_field = key_val;
    } OSSCLEAN(EntityPublicKey)
}

EntityPublicKey & EntityPublicKey::operator = (const EntityPublicKey & that) {
    if (this == &that)
	return *this;
    capabilityFlags_field = that.capabilityFlags_field;
    key_field = that.key_field;
    return *this;
}

int EntityPublicKey::operator == (const EntityPublicKey & that) const {
    if (capabilityFlags_field != that.capabilityFlags_field)
	return 0;
    if (key_field != that.key_field)
	return 0;
    return 1;
}

int EntityPublicKey::operator != (const EntityPublicKey & that) const {
    return !(operator ==(that));
}

EntityPublicKey::capabilityFlags & EntityPublicKey::get_capabilityFlags() {
    return capabilityFlags_field;
}

const EntityPublicKey::capabilityFlags & EntityPublicKey::get_capabilityFlags() const {
    return capabilityFlags_field;
}

void EntityPublicKey::set_capabilityFlags(const capabilityFlags & capabilityFlags_val) {
    capabilityFlags_field = capabilityFlags_val;
}

EntityPublicKey::key & EntityPublicKey::get_key() {
    return key_field;
}

const EntityPublicKey::key & EntityPublicKey::get_key() const {
    return key_field;
}

void EntityPublicKey::set_key(const key & key_val) {
    key_field = key_val;
}

void *PSKBodyCiphertext::operator new(size_t size) {
    return ossNewFunc(size);
}

void PSKBodyCiphertext::operator delete(void *ptr) {
    asn1Free(ptr);
}

PSKBodyCiphertext::PSKBodyCiphertext() {
    memset(this, 0, sizeof(PSKBodyCiphertext));
}

PSKBodyCiphertext::PSKBodyCiphertext(const PSKBodyCiphertext & that) {
    OSSTRY {
	attestationBodyCiphertext_field = that.attestationBodyCiphertext_field;
	encryptedUnder_field = that.encryptedUnder_field;
    } OSSCLEAN(PSKBodyCiphertext)
}

PSKBodyCiphertext::PSKBodyCiphertext(const attestationBodyCiphertext & attestationBodyCiphertext_val, 
    const encryptedUnder & encryptedUnder_val) {
    OSSTRY {
	attestationBodyCiphertext_field = attestationBodyCiphertext_val;
	encryptedUnder_field = encryptedUnder_val;
    } OSSCLEAN(PSKBodyCiphertext)
}

PSKBodyCiphertext & PSKBodyCiphertext::operator = (const PSKBodyCiphertext & that) {
    if (this == &that)
	return *this;
    attestationBodyCiphertext_field = that.attestationBodyCiphertext_field;
    encryptedUnder_field = that.encryptedUnder_field;
    return *this;
}

int PSKBodyCiphertext::operator == (const PSKBodyCiphertext & that) const {
    if (attestationBodyCiphertext_field != that.attestationBodyCiphertext_field)
	return 0;
    if (encryptedUnder_field != that.encryptedUnder_field)
	return 0;
    return 1;
}

int PSKBodyCiphertext::operator != (const PSKBodyCiphertext & that) const {
    return !(operator ==(that));
}

PSKBodyCiphertext::attestationBodyCiphertext & PSKBodyCiphertext::get_attestationBodyCiphertext() {
    return attestationBodyCiphertext_field;
}

const PSKBodyCiphertext::attestationBodyCiphertext & PSKBodyCiphertext::get_attestationBodyCiphertext() const {
    return attestationBodyCiphertext_field;
}

void PSKBodyCiphertext::set_attestationBodyCiphertext(const attestationBodyCiphertext & attestationBodyCiphertext_val) {
    attestationBodyCiphertext_field = attestationBodyCiphertext_val;
}

PSKBodyCiphertext::encryptedUnder & PSKBodyCiphertext::get_encryptedUnder() {
    return encryptedUnder_field;
}

const PSKBodyCiphertext::encryptedUnder & PSKBodyCiphertext::get_encryptedUnder() const {
    return encryptedUnder_field;
}

void PSKBodyCiphertext::set_encryptedUnder(const encryptedUnder & encryptedUnder_val) {
    encryptedUnder_field = encryptedUnder_val;
}

AttestationBodySchemes_Type::AttestationBodySchemes_Type()
{
}

AttestationBodySchemes_Type::AttestationBodySchemes_Type(const AttestationBodySchemes_Type & that)
{
    operator =(that);
}

AttestationBodySchemes_Type::~AttestationBodySchemes_Type()
{
    cleanup_decoded();
}

AttestationBodySchemes_Type & AttestationBodySchemes_Type::operator = (const AttestationBodySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int AttestationBodySchemes_Type::operator == (const AttestationBodySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int AttestationBodySchemes_Type::operator != (const AttestationBodySchemes_Type & that) const
{
    return !(operator ==(that));
}

int AttestationBodySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int AttestationBodySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int AttestationBodySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int AttestationBodySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int AttestationBodySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

AttestationBody *AttestationBodySchemes_Type::get_AttestationBody()
{
    if (pdunum == 3)
	return (AttestationBody *)decoded;
    else
	return NULL;
}

const AttestationBody *AttestationBodySchemes_Type::get_AttestationBody() const
{
    if (pdunum == 3)
	return (const AttestationBody *)decoded;
    else
	return NULL;
}

void AttestationBodySchemes_Type::set_AttestationBody(const AttestationBody & data)
{
    void *copy;

    copy = new AttestationBody(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 3;
	decoded = copy;
    }
}

AttestationBody *AttestationBodySchemes_Type::release_AttestationBody()
{
    pdunum = 0;
    decoded = NULL;
    return get_AttestationBody();
}

void AttestationBodySchemes_Type::set_AttestationBody(AttestationBody *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 3;
    decoded = data;
}

WR1BodyCiphertext *AttestationBodySchemes_Type::get_WR1BodyCiphertext()
{
    if (pdunum == 16)
	return (WR1BodyCiphertext *)decoded;
    else
	return NULL;
}

const WR1BodyCiphertext *AttestationBodySchemes_Type::get_WR1BodyCiphertext() const
{
    if (pdunum == 16)
	return (const WR1BodyCiphertext *)decoded;
    else
	return NULL;
}

void AttestationBodySchemes_Type::set_WR1BodyCiphertext(const WR1BodyCiphertext & data)
{
    void *copy;

    copy = new WR1BodyCiphertext(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 16;
	decoded = copy;
    }
}

WR1BodyCiphertext *AttestationBodySchemes_Type::release_WR1BodyCiphertext()
{
    pdunum = 0;
    decoded = NULL;
    return get_WR1BodyCiphertext();
}

void AttestationBodySchemes_Type::set_WR1BodyCiphertext(WR1BodyCiphertext *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 16;
    decoded = data;
}

PSKBodyCiphertext *AttestationBodySchemes_Type::get_PSKBodyCiphertext()
{
    if (pdunum == 15)
	return (PSKBodyCiphertext *)decoded;
    else
	return NULL;
}

const PSKBodyCiphertext *AttestationBodySchemes_Type::get_PSKBodyCiphertext() const
{
    if (pdunum == 15)
	return (const PSKBodyCiphertext *)decoded;
    else
	return NULL;
}

void AttestationBodySchemes_Type::set_PSKBodyCiphertext(const PSKBodyCiphertext & data)
{
    void *copy;

    copy = new PSKBodyCiphertext(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 15;
	decoded = copy;
    }
}

PSKBodyCiphertext *AttestationBodySchemes_Type::release_PSKBodyCiphertext()
{
    pdunum = 0;
    decoded = NULL;
    return get_PSKBodyCiphertext();
}

void AttestationBodySchemes_Type::set_PSKBodyCiphertext(PSKBodyCiphertext *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 15;
    decoded = data;
}

void AttestationBodySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq2::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq2::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq2::__seq2() {
    memset(this, 0, sizeof(__seq2));
}

__seq2::__seq2(const __seq2 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq2)
}

__seq2::__seq2(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq2)
}

__seq2 & __seq2::operator = (const __seq2 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq2::operator == (const __seq2 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq2::operator != (const __seq2 & that) const {
    return !(operator ==(that));
}

__seq2::type_id & __seq2::get_type_id() {
    return type_id_field;
}

const __seq2::type_id & __seq2::get_type_id() const {
    return type_id_field;
}

void __seq2::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq2::value & __seq2::get_value() {
    return value_field;
}

const __seq2::value & __seq2::get_value() const {
    return value_field;
}

void __seq2::set_value(const value & value_val) {
    value_field = value_val;
}

void *__seq3::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq3::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq3::__seq3() {
    memset(this, 0, sizeof(__seq3));
}

__seq3::__seq3(const __seq3 & that) {
    OSSTRY {
	subject_field = that.subject_field;
	subjectLocation_field = that.subjectLocation_field;
	revocations_field = that.revocations_field;
	publicExtensions_field = that.publicExtensions_field;
	body_field = that.body_field;
    } OSSCLEAN(__seq3)
}

__seq3::__seq3(const subject & subject_val, const subjectLocation & subjectLocation_val, 
    const revocations & revocations_val, const publicExtensions & publicExtensions_val, 
    const body & body_val) {
    OSSTRY {
	subject_field = subject_val;
	subjectLocation_field = subjectLocation_val;
	revocations_field = revocations_val;
	publicExtensions_field = publicExtensions_val;
	body_field = body_val;
    } OSSCLEAN(__seq3)
}

__seq3 & __seq3::operator = (const __seq3 & that) {
    if (this == &that)
	return *this;
    subject_field = that.subject_field;
    subjectLocation_field = that.subjectLocation_field;
    revocations_field = that.revocations_field;
    publicExtensions_field = that.publicExtensions_field;
    body_field = that.body_field;
    return *this;
}

int __seq3::operator == (const __seq3 & that) const {
    if (subject_field != that.subject_field)
	return 0;
    if (subjectLocation_field != that.subjectLocation_field)
	return 0;
    if (revocations_field != that.revocations_field)
	return 0;
    if (publicExtensions_field != that.publicExtensions_field)
	return 0;
    if (body_field != that.body_field)
	return 0;
    return 1;
}

int __seq3::operator != (const __seq3 & that) const {
    return !(operator ==(that));
}

__seq3::subject & __seq3::get_subject() {
    return subject_field;
}

const __seq3::subject & __seq3::get_subject() const {
    return subject_field;
}

void __seq3::set_subject(const subject & subject_val) {
    subject_field = subject_val;
}

__seq3::subjectLocation & __seq3::get_subjectLocation() {
    return subjectLocation_field;
}

const __seq3::subjectLocation & __seq3::get_subjectLocation() const {
    return subjectLocation_field;
}

void __seq3::set_subjectLocation(const subjectLocation & subjectLocation_val) {
    subjectLocation_field = subjectLocation_val;
}

__seq3::revocations & __seq3::get_revocations() {
    return revocations_field;
}

const __seq3::revocations & __seq3::get_revocations() const {
    return revocations_field;
}

void __seq3::set_revocations(const revocations & revocations_val) {
    revocations_field = revocations_val;
}

__seq3::publicExtensions & __seq3::get_publicExtensions() {
    return publicExtensions_field;
}

const __seq3::publicExtensions & __seq3::get_publicExtensions() const {
    return publicExtensions_field;
}

void __seq3::set_publicExtensions(const publicExtensions & publicExtensions_val) {
    publicExtensions_field = publicExtensions_val;
}

__seq3::body & __seq3::get_body() {
    return body_field;
}

const __seq3::body & __seq3::get_body() const {
    return body_field;
}

void __seq3::set_body(const body & body_val) {
    body_field = body_val;
}

void *Ed25519OuterSignature::operator new(size_t size) {
    return ossNewFunc(size);
}

void Ed25519OuterSignature::operator delete(void *ptr) {
    asn1Free(ptr);
}

Ed25519OuterSignature::Ed25519OuterSignature() {
    memset(this, 0, sizeof(Ed25519OuterSignature));
}

Ed25519OuterSignature::Ed25519OuterSignature(const Ed25519OuterSignature & that) {
    OSSTRY {
	verifyingKey_field = that.verifyingKey_field;
	signature_field = that.signature_field;
    } OSSCLEAN(Ed25519OuterSignature)
}

Ed25519OuterSignature::Ed25519OuterSignature(const verifyingKey & verifyingKey_val, 
    const signature & signature_val) {
    OSSTRY {
	verifyingKey_field = verifyingKey_val;
	signature_field = signature_val;
    } OSSCLEAN(Ed25519OuterSignature)
}

Ed25519OuterSignature & Ed25519OuterSignature::operator = (const Ed25519OuterSignature & that) {
    if (this == &that)
	return *this;
    verifyingKey_field = that.verifyingKey_field;
    signature_field = that.signature_field;
    return *this;
}

int Ed25519OuterSignature::operator == (const Ed25519OuterSignature & that) const {
    if (verifyingKey_field != that.verifyingKey_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    return 1;
}

int Ed25519OuterSignature::operator != (const Ed25519OuterSignature & that) const {
    return !(operator ==(that));
}

Ed25519OuterSignature::verifyingKey & Ed25519OuterSignature::get_verifyingKey() {
    return verifyingKey_field;
}

const Ed25519OuterSignature::verifyingKey & Ed25519OuterSignature::get_verifyingKey() const {
    return verifyingKey_field;
}

void Ed25519OuterSignature::set_verifyingKey(const verifyingKey & verifyingKey_val) {
    verifyingKey_field = verifyingKey_val;
}

Ed25519OuterSignature::signature & Ed25519OuterSignature::get_signature() {
    return signature_field;
}

const Ed25519OuterSignature::signature & Ed25519OuterSignature::get_signature() const {
    return signature_field;
}

void Ed25519OuterSignature::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

OuterSignatureSchemes_Type::OuterSignatureSchemes_Type()
{
}

OuterSignatureSchemes_Type::OuterSignatureSchemes_Type(const OuterSignatureSchemes_Type & that)
{
    operator =(that);
}

OuterSignatureSchemes_Type::~OuterSignatureSchemes_Type()
{
    cleanup_decoded();
}

OuterSignatureSchemes_Type & OuterSignatureSchemes_Type::operator = (const OuterSignatureSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int OuterSignatureSchemes_Type::operator == (const OuterSignatureSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int OuterSignatureSchemes_Type::operator != (const OuterSignatureSchemes_Type & that) const
{
    return !(operator ==(that));
}

int OuterSignatureSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int OuterSignatureSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int OuterSignatureSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int OuterSignatureSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int OuterSignatureSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

Ed25519OuterSignature *OuterSignatureSchemes_Type::get_Ed25519OuterSignature()
{
    if (pdunum == 20)
	return (Ed25519OuterSignature *)decoded;
    else
	return NULL;
}

const Ed25519OuterSignature *OuterSignatureSchemes_Type::get_Ed25519OuterSignature() const
{
    if (pdunum == 20)
	return (const Ed25519OuterSignature *)decoded;
    else
	return NULL;
}

void OuterSignatureSchemes_Type::set_Ed25519OuterSignature(const Ed25519OuterSignature & data)
{
    void *copy;

    copy = new Ed25519OuterSignature(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 20;
	decoded = copy;
    }
}

Ed25519OuterSignature *OuterSignatureSchemes_Type::release_Ed25519OuterSignature()
{
    pdunum = 0;
    decoded = NULL;
    return get_Ed25519OuterSignature();
}

void OuterSignatureSchemes_Type::set_Ed25519OuterSignature(Ed25519OuterSignature *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 20;
    decoded = data;
}

void OuterSignatureSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq4::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq4::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq4::__seq4() {
    memset(this, 0, sizeof(__seq4));
}

__seq4::__seq4(const __seq4 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq4)
}

__seq4::__seq4(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq4)
}

__seq4 & __seq4::operator = (const __seq4 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq4::operator == (const __seq4 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq4::operator != (const __seq4 & that) const {
    return !(operator ==(that));
}

__seq4::type_id & __seq4::get_type_id() {
    return type_id_field;
}

const __seq4::type_id & __seq4::get_type_id() const {
    return type_id_field;
}

void __seq4::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq4::value & __seq4::get_value() {
    return value_field;
}

const __seq4::value & __seq4::get_value() const {
    return value_field;
}

void __seq4::set_value(const value & value_val) {
    value_field = value_val;
}

void *WaveAttestation::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveAttestation::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveAttestation::WaveAttestation() {
    memset(this, 0, sizeof(WaveAttestation));
}

WaveAttestation::WaveAttestation(const WaveAttestation & that) {
    OSSTRY {
	tbs_field = that.tbs_field;
	outerSignature_field = that.outerSignature_field;
    } OSSCLEAN(WaveAttestation)
}

WaveAttestation::WaveAttestation(const tbs & tbs_val, const outerSignature & outerSignature_val) {
    OSSTRY {
	tbs_field = tbs_val;
	outerSignature_field = outerSignature_val;
    } OSSCLEAN(WaveAttestation)
}

WaveAttestation & WaveAttestation::operator = (const WaveAttestation & that) {
    if (this == &that)
	return *this;
    tbs_field = that.tbs_field;
    outerSignature_field = that.outerSignature_field;
    return *this;
}

int WaveAttestation::operator == (const WaveAttestation & that) const {
    if (tbs_field != that.tbs_field)
	return 0;
    if (outerSignature_field != that.outerSignature_field)
	return 0;
    return 1;
}

int WaveAttestation::operator != (const WaveAttestation & that) const {
    return !(operator ==(that));
}

WaveAttestation::tbs & WaveAttestation::get_tbs() {
    return tbs_field;
}

const WaveAttestation::tbs & WaveAttestation::get_tbs() const {
    return tbs_field;
}

void WaveAttestation::set_tbs(const tbs & tbs_val) {
    tbs_field = tbs_val;
}

WaveAttestation::outerSignature & WaveAttestation::get_outerSignature() {
    return outerSignature_field;
}

const WaveAttestation::outerSignature & WaveAttestation::get_outerSignature() const {
    return outerSignature_field;
}

void WaveAttestation::set_outerSignature(const outerSignature & outerSignature_val) {
    outerSignature_field = outerSignature_val;
}

/* Auxiliary data structures and functions for class __seqof4 */

class __seqof4_member {
public:
    __seqof4_member *next;
    __seqof4::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof4_member();
    __seqof4_member(const __seqof4::component & val);
};

void *__seqof4_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof4_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof4_member::__seqof4_member() {
}

__seqof4_member::__seqof4_member(const __seqof4::component & val) {
    value = val;
}

static void *__seqof4_copy(void *that) {
    return new __seqof4_member(((__seqof4_member *)that)->value);
}

static void __seqof4_destroy(void *that) {
    delete (__seqof4_member *)that;
}

static int __seqof4_compare(void *val1, void *val2) {
    return (((__seqof4_member *)val1)->value == ((__seqof4_member *)val2)->value);
}

/* Constructors */

__seqof4::__seqof4() {
}

__seqof4::__seqof4(const __seqof4 & that) {
    OSSTRY {
	do_copy(that, &__seqof4_copy);
    } OSSCLEAN(__seqof4)
}

/* Destructor */

__seqof4::~__seqof4() {
    do_destroy(&__seqof4_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof4 & __seqof4::operator = (const __seqof4 & that) {
    do_destroy(&__seqof4_destroy);
    do_copy(that, &__seqof4_copy);
    return *this;
}

int __seqof4::operator == (const __seqof4 & that) const {
    return do_compare(that, &__seqof4_compare);
}

int __seqof4::operator != (const __seqof4 & that) const {
    return !do_compare(that, &__seqof4_compare);
}

/* Locate ("At" etc) methods */

__seqof4::component *__seqof4::at(OssIndex pos) {
    return &((__seqof4_member *)pos)->value;
}

const __seqof4::component *__seqof4::at(OssIndex pos) const {
    return &((__seqof4_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof4::prepend(const component & val) {
    __seqof4_member *newrec = new __seqof4_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof4::prepend(__seqof4 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof4::insert_after(OssIndex pos, const component & val) {
    __seqof4_member *newrec = new __seqof4_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof4::insert_after(OssIndex pos, __seqof4 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof4::remove_front() {
    __seqof4_member *extr = (__seqof4_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof4_destroy(extr);
    return 0;
}

int __seqof4::remove_after(OssIndex pos) {
    __seqof4_member *extr = (__seqof4_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof4_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof4 *__seqof4::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof4 *)do_extract_after(begin, end);
}

void *__seq9::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq9::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq9::__seq9() {
    memset(this, 0, sizeof(__seq9));
}

__seq9::__seq9(const __seq9 & that) {
    OSSTRY {
	verifyingKey_field = that.verifyingKey_field;
	keys_field = that.keys_field;
	validity_field = that.validity_field;
	revocations_field = that.revocations_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(__seq9)
}

__seq9::__seq9(const verifyingKey & verifyingKey_val, const keys & keys_val, const validity & validity_val, 
    const revocations & revocations_val, const extensions & extensions_val) {
    OSSTRY {
	verifyingKey_field = verifyingKey_val;
	keys_field = keys_val;
	validity_field = validity_val;
	revocations_field = revocations_val;
	extensions_field = extensions_val;
    } OSSCLEAN(__seq9)
}

__seq9 & __seq9::operator = (const __seq9 & that) {
    if (this == &that)
	return *this;
    verifyingKey_field = that.verifyingKey_field;
    keys_field = that.keys_field;
    validity_field = that.validity_field;
    revocations_field = that.revocations_field;
    extensions_field = that.extensions_field;
    return *this;
}

int __seq9::operator == (const __seq9 & that) const {
    if (verifyingKey_field != that.verifyingKey_field)
	return 0;
    if (keys_field != that.keys_field)
	return 0;
    if (validity_field != that.validity_field)
	return 0;
    if (revocations_field != that.revocations_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    return 1;
}

int __seq9::operator != (const __seq9 & that) const {
    return !(operator ==(that));
}

__seq9::verifyingKey & __seq9::get_verifyingKey() {
    return verifyingKey_field;
}

const __seq9::verifyingKey & __seq9::get_verifyingKey() const {
    return verifyingKey_field;
}

void __seq9::set_verifyingKey(const verifyingKey & verifyingKey_val) {
    verifyingKey_field = verifyingKey_val;
}

__seq9::keys & __seq9::get_keys() {
    return keys_field;
}

const __seq9::keys & __seq9::get_keys() const {
    return keys_field;
}

void __seq9::set_keys(const keys & keys_val) {
    keys_field = keys_val;
}

__seq9::validity & __seq9::get_validity() {
    return validity_field;
}

const __seq9::validity & __seq9::get_validity() const {
    return validity_field;
}

void __seq9::set_validity(const validity & validity_val) {
    validity_field = validity_val;
}

__seq9::revocations & __seq9::get_revocations() {
    return revocations_field;
}

const __seq9::revocations & __seq9::get_revocations() const {
    return revocations_field;
}

void __seq9::set_revocations(const revocations & revocations_val) {
    revocations_field = revocations_val;
}

__seq9::extensions & __seq9::get_extensions() {
    return extensions_field;
}

const __seq9::extensions & __seq9::get_extensions() const {
    return extensions_field;
}

void __seq9::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

void *WaveEntity::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveEntity::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveEntity::WaveEntity() {
    memset(this, 0, sizeof(WaveEntity));
}

WaveEntity::WaveEntity(const WaveEntity & that) {
    OSSTRY {
	tbs_field = that.tbs_field;
	signature_field = that.signature_field;
    } OSSCLEAN(WaveEntity)
}

WaveEntity::WaveEntity(const tbs & tbs_val, const signature & signature_val) {
    OSSTRY {
	tbs_field = tbs_val;
	signature_field = signature_val;
    } OSSCLEAN(WaveEntity)
}

WaveEntity & WaveEntity::operator = (const WaveEntity & that) {
    if (this == &that)
	return *this;
    tbs_field = that.tbs_field;
    signature_field = that.signature_field;
    return *this;
}

int WaveEntity::operator == (const WaveEntity & that) const {
    if (tbs_field != that.tbs_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    return 1;
}

int WaveEntity::operator != (const WaveEntity & that) const {
    return !(operator ==(that));
}

WaveEntity::tbs & WaveEntity::get_tbs() {
    return tbs_field;
}

const WaveEntity::tbs & WaveEntity::get_tbs() const {
    return tbs_field;
}

void WaveEntity::set_tbs(const tbs & tbs_val) {
    tbs_field = tbs_val;
}

WaveEntity::signature & WaveEntity::get_signature() {
    return signature_field;
}

const WaveEntity::signature & WaveEntity::get_signature() const {
    return signature_field;
}

void WaveEntity::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

/* Auxiliary data structures and functions for class __seqof11 */

class __seqof11_member {
public:
    __seqof11_member *next;
    __seqof11::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof11_member();
    __seqof11_member(const __seqof11::component & val);
};

void *__seqof11_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof11_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof11_member::__seqof11_member() {
}

__seqof11_member::__seqof11_member(const __seqof11::component & val) {
    value = val;
}

static void *__seqof11_copy(void *that) {
    return new __seqof11_member(((__seqof11_member *)that)->value);
}

static void __seqof11_destroy(void *that) {
    delete (__seqof11_member *)that;
}

static int __seqof11_compare(void *val1, void *val2) {
    return (((__seqof11_member *)val1)->value == ((__seqof11_member *)val2)->value);
}

/* Constructors */

__seqof11::__seqof11() {
}

__seqof11::__seqof11(const __seqof11 & that) {
    OSSTRY {
	do_copy(that, &__seqof11_copy);
    } OSSCLEAN(__seqof11)
}

/* Destructor */

__seqof11::~__seqof11() {
    do_destroy(&__seqof11_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof11 & __seqof11::operator = (const __seqof11 & that) {
    do_destroy(&__seqof11_destroy);
    do_copy(that, &__seqof11_copy);
    return *this;
}

int __seqof11::operator == (const __seqof11 & that) const {
    return do_compare(that, &__seqof11_compare);
}

int __seqof11::operator != (const __seqof11 & that) const {
    return !do_compare(that, &__seqof11_compare);
}

/* Locate ("At" etc) methods */

__seqof11::component *__seqof11::at(OssIndex pos) {
    return &((__seqof11_member *)pos)->value;
}

const __seqof11::component *__seqof11::at(OssIndex pos) const {
    return &((__seqof11_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof11::prepend(const component & val) {
    __seqof11_member *newrec = new __seqof11_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof11::prepend(__seqof11 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof11::insert_after(OssIndex pos, const component & val) {
    __seqof11_member *newrec = new __seqof11_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof11::insert_after(OssIndex pos, __seqof11 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof11::remove_front() {
    __seqof11_member *extr = (__seqof11_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof11_destroy(extr);
    return 0;
}

int __seqof11::remove_after(OssIndex pos) {
    __seqof11_member *extr = (__seqof11_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof11_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof11 *__seqof11::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof11 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __seqof12 */

class __seqof12_member {
public:
    __seqof12_member *next;
    __seqof12::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof12_member();
    __seqof12_member(const __seqof12::component & val);
};

void *__seqof12_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof12_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof12_member::__seqof12_member() {
}

__seqof12_member::__seqof12_member(const __seqof12::component & val) {
    value = val;
}

static void *__seqof12_copy(void *that) {
    return new __seqof12_member(((__seqof12_member *)that)->value);
}

static void __seqof12_destroy(void *that) {
    delete (__seqof12_member *)that;
}

static int __seqof12_compare(void *val1, void *val2) {
    return (((__seqof12_member *)val1)->value == ((__seqof12_member *)val2)->value);
}

/* Constructors */

__seqof12::__seqof12() {
}

__seqof12::__seqof12(const __seqof12 & that) {
    OSSTRY {
	do_copy(that, &__seqof12_copy);
    } OSSCLEAN(__seqof12)
}

/* Destructor */

__seqof12::~__seqof12() {
    do_destroy(&__seqof12_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof12 & __seqof12::operator = (const __seqof12 & that) {
    do_destroy(&__seqof12_destroy);
    do_copy(that, &__seqof12_copy);
    return *this;
}

int __seqof12::operator == (const __seqof12 & that) const {
    return do_compare(that, &__seqof12_compare);
}

int __seqof12::operator != (const __seqof12 & that) const {
    return !do_compare(that, &__seqof12_compare);
}

/* Locate ("At" etc) methods */

__seqof12::component *__seqof12::at(OssIndex pos) {
    return &((__seqof12_member *)pos)->value;
}

const __seqof12::component *__seqof12::at(OssIndex pos) const {
    return &((__seqof12_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof12::prepend(const component & val) {
    __seqof12_member *newrec = new __seqof12_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof12::prepend(__seqof12 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof12::insert_after(OssIndex pos, const component & val) {
    __seqof12_member *newrec = new __seqof12_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof12::insert_after(OssIndex pos, __seqof12 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof12::remove_front() {
    __seqof12_member *extr = (__seqof12_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof12_destroy(extr);
    return 0;
}

int __seqof12::remove_after(OssIndex pos) {
    __seqof12_member *extr = (__seqof12_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof12_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof12 *__seqof12::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof12 *)do_extract_after(begin, end);
}

void *WaveExplicitProof::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveExplicitProof::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveExplicitProof::WaveExplicitProof() {
    memset(this, 0, sizeof(WaveExplicitProof));
}

WaveExplicitProof::WaveExplicitProof(const WaveExplicitProof & that) {
    OSSTRY {
	attestations_field = that.attestations_field;
	paths_field = that.paths_field;
	entities_field = that.entities_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(WaveExplicitProof)
}

WaveExplicitProof::WaveExplicitProof(const attestations & attestations_val, const paths & paths_val, 
    const entities & entities_val, const extensions & extensions_val) {
    OSSTRY {
	attestations_field = attestations_val;
	paths_field = paths_val;
	entities_field = entities_val;
	extensions_field = extensions_val;
    } OSSCLEAN(WaveExplicitProof)
}

WaveExplicitProof & WaveExplicitProof::operator = (const WaveExplicitProof & that) {
    if (this == &that)
	return *this;
    attestations_field = that.attestations_field;
    paths_field = that.paths_field;
    entities_field = that.entities_field;
    extensions_field = that.extensions_field;
    return *this;
}

int WaveExplicitProof::operator == (const WaveExplicitProof & that) const {
    if (attestations_field != that.attestations_field)
	return 0;
    if (paths_field != that.paths_field)
	return 0;
    if (entities_field != that.entities_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    return 1;
}

int WaveExplicitProof::operator != (const WaveExplicitProof & that) const {
    return !(operator ==(that));
}

WaveExplicitProof::attestations & WaveExplicitProof::get_attestations() {
    return attestations_field;
}

const WaveExplicitProof::attestations & WaveExplicitProof::get_attestations() const {
    return attestations_field;
}

void WaveExplicitProof::set_attestations(const attestations & attestations_val) {
    attestations_field = attestations_val;
}

WaveExplicitProof::paths & WaveExplicitProof::get_paths() {
    return paths_field;
}

const WaveExplicitProof::paths & WaveExplicitProof::get_paths() const {
    return paths_field;
}

void WaveExplicitProof::set_paths(const paths & paths_val) {
    paths_field = paths_val;
}

WaveExplicitProof::entities & WaveExplicitProof::get_entities() {
    return entities_field;
}

const WaveExplicitProof::entities & WaveExplicitProof::get_entities() const {
    return entities_field;
}

void WaveExplicitProof::set_entities(const entities & entities_val) {
    entities_field = entities_val;
}

WaveExplicitProof::extensions & WaveExplicitProof::get_extensions() {
    return extensions_field;
}

const WaveExplicitProof::extensions & WaveExplicitProof::get_extensions() const {
    return extensions_field;
}

void WaveExplicitProof::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

/* Auxiliary data structures and functions for class __seqof5 */

class __seqof5_member {
public:
    __seqof5_member *next;
    __seqof5::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof5_member();
    __seqof5_member(const __seqof5::component & val);
};

void *__seqof5_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof5_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof5_member::__seqof5_member() {
}

__seqof5_member::__seqof5_member(const __seqof5::component & val) {
    value = val;
}

static void *__seqof5_copy(void *that) {
    return new __seqof5_member(((__seqof5_member *)that)->value);
}

static void __seqof5_destroy(void *that) {
    delete (__seqof5_member *)that;
}

static int __seqof5_compare(void *val1, void *val2) {
    return (((__seqof5_member *)val1)->value == ((__seqof5_member *)val2)->value);
}

/* Constructors */

__seqof5::__seqof5() {
}

__seqof5::__seqof5(const __seqof5 & that) {
    OSSTRY {
	do_copy(that, &__seqof5_copy);
    } OSSCLEAN(__seqof5)
}

/* Destructor */

__seqof5::~__seqof5() {
    do_destroy(&__seqof5_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof5 & __seqof5::operator = (const __seqof5 & that) {
    do_destroy(&__seqof5_destroy);
    do_copy(that, &__seqof5_copy);
    return *this;
}

int __seqof5::operator == (const __seqof5 & that) const {
    return do_compare(that, &__seqof5_compare);
}

int __seqof5::operator != (const __seqof5 & that) const {
    return !do_compare(that, &__seqof5_compare);
}

/* Locate ("At" etc) methods */

__seqof5::component *__seqof5::at(OssIndex pos) {
    return &((__seqof5_member *)pos)->value;
}

const __seqof5::component *__seqof5::at(OssIndex pos) const {
    return &((__seqof5_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof5::prepend(const component & val) {
    __seqof5_member *newrec = new __seqof5_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof5::prepend(__seqof5 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof5::insert_after(OssIndex pos, const component & val) {
    __seqof5_member *newrec = new __seqof5_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof5::insert_after(OssIndex pos, __seqof5 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof5::remove_front() {
    __seqof5_member *extr = (__seqof5_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof5_destroy(extr);
    return 0;
}

int __seqof5::remove_after(OssIndex pos) {
    __seqof5_member *extr = (__seqof5_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof5_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof5 *__seqof5::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof5 *)do_extract_after(begin, end);
}

void *EntityKeyring::operator new(size_t size) {
    return ossNewFunc(size);
}

void EntityKeyring::operator delete(void *ptr) {
    asn1Free(ptr);
}

EntityKeyring::EntityKeyring() {
    memset(this, 0, sizeof(EntityKeyring));
}

EntityKeyring::EntityKeyring(const EntityKeyring & that) {
    OSSTRY {
	keys_field = that.keys_field;
    } OSSCLEAN(EntityKeyring)
}

EntityKeyring::EntityKeyring(const keys & keys_val) {
    OSSTRY {
	keys_field = keys_val;
    } OSSCLEAN(EntityKeyring)
}

EntityKeyring & EntityKeyring::operator = (const EntityKeyring & that) {
    if (this == &that)
	return *this;
    keys_field = that.keys_field;
    return *this;
}

int EntityKeyring::operator == (const EntityKeyring & that) const {
    if (keys_field != that.keys_field)
	return 0;
    return 1;
}

int EntityKeyring::operator != (const EntityKeyring & that) const {
    return !(operator ==(that));
}

EntityKeyring::keys & EntityKeyring::get_keys() {
    return keys_field;
}

const EntityKeyring::keys & EntityKeyring::get_keys() const {
    return keys_field;
}

void EntityKeyring::set_keys(const keys & keys_val) {
    keys_field = keys_val;
}

void *KeyringAESCiphertext::operator new(size_t size) {
    return ossNewFunc(size);
}

void KeyringAESCiphertext::operator delete(void *ptr) {
    asn1Free(ptr);
}

KeyringAESCiphertext::KeyringAESCiphertext() {
    memset(this, 0, sizeof(KeyringAESCiphertext));
}

KeyringAESCiphertext::KeyringAESCiphertext(const KeyringAESCiphertext & that) {
    OSSTRY {
	ciphertext_field = that.ciphertext_field;
	salt_field = that.salt_field;
	iterations_field = that.iterations_field;
    } OSSCLEAN(KeyringAESCiphertext)
}

KeyringAESCiphertext::KeyringAESCiphertext(const ciphertext & ciphertext_val, const salt & salt_val, 
    iterations iterations_val) {
    OSSTRY {
	ciphertext_field = ciphertext_val;
	salt_field = salt_val;
	iterations_field = iterations_val;
    } OSSCLEAN(KeyringAESCiphertext)
}

KeyringAESCiphertext & KeyringAESCiphertext::operator = (const KeyringAESCiphertext & that) {
    if (this == &that)
	return *this;
    ciphertext_field = that.ciphertext_field;
    salt_field = that.salt_field;
    iterations_field = that.iterations_field;
    return *this;
}

int KeyringAESCiphertext::operator == (const KeyringAESCiphertext & that) const {
    if (ciphertext_field != that.ciphertext_field)
	return 0;
    if (salt_field != that.salt_field)
	return 0;
    if (iterations_field != that.iterations_field)
	return 0;
    return 1;
}

int KeyringAESCiphertext::operator != (const KeyringAESCiphertext & that) const {
    return !(operator ==(that));
}

KeyringAESCiphertext::ciphertext & KeyringAESCiphertext::get_ciphertext() {
    return ciphertext_field;
}

const KeyringAESCiphertext::ciphertext & KeyringAESCiphertext::get_ciphertext() const {
    return ciphertext_field;
}

void KeyringAESCiphertext::set_ciphertext(const ciphertext & ciphertext_val) {
    ciphertext_field = ciphertext_val;
}

KeyringAESCiphertext::salt & KeyringAESCiphertext::get_salt() {
    return salt_field;
}

const KeyringAESCiphertext::salt & KeyringAESCiphertext::get_salt() const {
    return salt_field;
}

void KeyringAESCiphertext::set_salt(const salt & salt_val) {
    salt_field = salt_val;
}

KeyringAESCiphertext::iterations & KeyringAESCiphertext::get_iterations() {
    return iterations_field;
}

KeyringAESCiphertext::iterations KeyringAESCiphertext::get_iterations() const {
    return iterations_field;
}

void KeyringAESCiphertext::set_iterations(iterations iterations_val) {
    iterations_field = iterations_val;
}

EntityKeyringSchemes_Type::EntityKeyringSchemes_Type()
{
}

EntityKeyringSchemes_Type::EntityKeyringSchemes_Type(const EntityKeyringSchemes_Type & that)
{
    operator =(that);
}

EntityKeyringSchemes_Type::~EntityKeyringSchemes_Type()
{
    cleanup_decoded();
}

EntityKeyringSchemes_Type & EntityKeyringSchemes_Type::operator = (const EntityKeyringSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int EntityKeyringSchemes_Type::operator == (const EntityKeyringSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int EntityKeyringSchemes_Type::operator != (const EntityKeyringSchemes_Type & that) const
{
    return !(operator ==(that));
}

int EntityKeyringSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int EntityKeyringSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int EntityKeyringSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int EntityKeyringSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int EntityKeyringSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

EntityKeyring *EntityKeyringSchemes_Type::get_EntityKeyring()
{
    if (pdunum == 6)
	return (EntityKeyring *)decoded;
    else
	return NULL;
}

const EntityKeyring *EntityKeyringSchemes_Type::get_EntityKeyring() const
{
    if (pdunum == 6)
	return (const EntityKeyring *)decoded;
    else
	return NULL;
}

void EntityKeyringSchemes_Type::set_EntityKeyring(const EntityKeyring & data)
{
    void *copy;

    copy = new EntityKeyring(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 6;
	decoded = copy;
    }
}

EntityKeyring *EntityKeyringSchemes_Type::release_EntityKeyring()
{
    pdunum = 0;
    decoded = NULL;
    return get_EntityKeyring();
}

void EntityKeyringSchemes_Type::set_EntityKeyring(EntityKeyring *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 6;
    decoded = data;
}

KeyringAESCiphertext *EntityKeyringSchemes_Type::get_KeyringAESCiphertext()
{
    if (pdunum == 37)
	return (KeyringAESCiphertext *)decoded;
    else
	return NULL;
}

const KeyringAESCiphertext *EntityKeyringSchemes_Type::get_KeyringAESCiphertext() const
{
    if (pdunum == 37)
	return (const KeyringAESCiphertext *)decoded;
    else
	return NULL;
}

void EntityKeyringSchemes_Type::set_KeyringAESCiphertext(const KeyringAESCiphertext & data)
{
    void *copy;

    copy = new KeyringAESCiphertext(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 37;
	decoded = copy;
    }
}

KeyringAESCiphertext *EntityKeyringSchemes_Type::release_KeyringAESCiphertext()
{
    pdunum = 0;
    decoded = NULL;
    return get_KeyringAESCiphertext();
}

void EntityKeyringSchemes_Type::set_KeyringAESCiphertext(KeyringAESCiphertext *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 37;
    decoded = data;
}

void EntityKeyringSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq10::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq10::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq10::__seq10() {
    memset(this, 0, sizeof(__seq10));
}

__seq10::__seq10(const __seq10 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq10)
}

__seq10::__seq10(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq10)
}

__seq10 & __seq10::operator = (const __seq10 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq10::operator == (const __seq10 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq10::operator != (const __seq10 & that) const {
    return !(operator ==(that));
}

__seq10::type_id & __seq10::get_type_id() {
    return type_id_field;
}

const __seq10::type_id & __seq10::get_type_id() const {
    return type_id_field;
}

void __seq10::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq10::value & __seq10::get_value() {
    return value_field;
}

const __seq10::value & __seq10::get_value() const {
    return value_field;
}

void __seq10::set_value(const value & value_val) {
    value_field = value_val;
}

void *WaveEntitySecret::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveEntitySecret::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveEntitySecret::WaveEntitySecret() {
    memset(this, 0, sizeof(WaveEntitySecret));
}

WaveEntitySecret::WaveEntitySecret(const WaveEntitySecret & that) {
    OSSTRY {
	entity_field = that.entity_field;
	keyring_field = that.keyring_field;
    } OSSCLEAN(WaveEntitySecret)
}

WaveEntitySecret::WaveEntitySecret(const entity & entity_val, const keyring & keyring_val) {
    OSSTRY {
	entity_field = entity_val;
	keyring_field = keyring_val;
    } OSSCLEAN(WaveEntitySecret)
}

WaveEntitySecret & WaveEntitySecret::operator = (const WaveEntitySecret & that) {
    if (this == &that)
	return *this;
    entity_field = that.entity_field;
    keyring_field = that.keyring_field;
    return *this;
}

int WaveEntitySecret::operator == (const WaveEntitySecret & that) const {
    if (entity_field != that.entity_field)
	return 0;
    if (keyring_field != that.keyring_field)
	return 0;
    return 1;
}

int WaveEntitySecret::operator != (const WaveEntitySecret & that) const {
    return !(operator ==(that));
}

WaveEntitySecret::entity & WaveEntitySecret::get_entity() {
    return entity_field;
}

const WaveEntitySecret::entity & WaveEntitySecret::get_entity() const {
    return entity_field;
}

void WaveEntitySecret::set_entity(const entity & entity_val) {
    entity_field = entity_val;
}

WaveEntitySecret::keyring & WaveEntitySecret::get_keyring() {
    return keyring_field;
}

const WaveEntitySecret::keyring & WaveEntitySecret::get_keyring() const {
    return keyring_field;
}

void WaveEntitySecret::set_keyring(const keyring & keyring_val) {
    keyring_field = keyring_val;
}

WaveObjects_Type::WaveObjects_Type()
{
}

WaveObjects_Type::WaveObjects_Type(const WaveObjects_Type & that)
{
    operator =(that);
}

WaveObjects_Type::~WaveObjects_Type()
{
    cleanup_decoded();
}

WaveObjects_Type & WaveObjects_Type::operator = (const WaveObjects_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int WaveObjects_Type::operator == (const WaveObjects_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int WaveObjects_Type::operator != (const WaveObjects_Type & that) const
{
    return !(operator ==(that));
}

int WaveObjects_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int WaveObjects_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int WaveObjects_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int WaveObjects_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int WaveObjects_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

WaveAttestation *WaveObjects_Type::get_WaveAttestation()
{
    if (pdunum == 2)
	return (WaveAttestation *)decoded;
    else
	return NULL;
}

const WaveAttestation *WaveObjects_Type::get_WaveAttestation() const
{
    if (pdunum == 2)
	return (const WaveAttestation *)decoded;
    else
	return NULL;
}

void WaveObjects_Type::set_WaveAttestation(const WaveAttestation & data)
{
    void *copy;

    copy = new WaveAttestation(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 2;
	decoded = copy;
    }
}

WaveAttestation *WaveObjects_Type::release_WaveAttestation()
{
    pdunum = 0;
    decoded = NULL;
    return get_WaveAttestation();
}

void WaveObjects_Type::set_WaveAttestation(WaveAttestation *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 2;
    decoded = data;
}

WaveEntity *WaveObjects_Type::get_WaveEntity()
{
    if (pdunum == 4)
	return (WaveEntity *)decoded;
    else
	return NULL;
}

const WaveEntity *WaveObjects_Type::get_WaveEntity() const
{
    if (pdunum == 4)
	return (const WaveEntity *)decoded;
    else
	return NULL;
}

void WaveObjects_Type::set_WaveEntity(const WaveEntity & data)
{
    void *copy;

    copy = new WaveEntity(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 4;
	decoded = copy;
    }
}

WaveEntity *WaveObjects_Type::release_WaveEntity()
{
    pdunum = 0;
    decoded = NULL;
    return get_WaveEntity();
}

void WaveObjects_Type::set_WaveEntity(WaveEntity *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 4;
    decoded = data;
}

WaveExplicitProof *WaveObjects_Type::get_WaveExplicitProof()
{
    if (pdunum == 8)
	return (WaveExplicitProof *)decoded;
    else
	return NULL;
}

const WaveExplicitProof *WaveObjects_Type::get_WaveExplicitProof() const
{
    if (pdunum == 8)
	return (const WaveExplicitProof *)decoded;
    else
	return NULL;
}

void WaveObjects_Type::set_WaveExplicitProof(const WaveExplicitProof & data)
{
    void *copy;

    copy = new WaveExplicitProof(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 8;
	decoded = copy;
    }
}

WaveExplicitProof *WaveObjects_Type::release_WaveExplicitProof()
{
    pdunum = 0;
    decoded = NULL;
    return get_WaveExplicitProof();
}

void WaveObjects_Type::set_WaveExplicitProof(WaveExplicitProof *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 8;
    decoded = data;
}

WaveEntitySecret *WaveObjects_Type::get_WaveEntitySecret()
{
    if (pdunum == 5)
	return (WaveEntitySecret *)decoded;
    else
	return NULL;
}

const WaveEntitySecret *WaveObjects_Type::get_WaveEntitySecret() const
{
    if (pdunum == 5)
	return (const WaveEntitySecret *)decoded;
    else
	return NULL;
}

void WaveObjects_Type::set_WaveEntitySecret(const WaveEntitySecret & data)
{
    void *copy;

    copy = new WaveEntitySecret(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 5;
	decoded = copy;
    }
}

WaveEntitySecret *WaveObjects_Type::release_WaveEntitySecret()
{
    pdunum = 0;
    decoded = NULL;
    return get_WaveEntitySecret();
}

void WaveObjects_Type::set_WaveEntitySecret(WaveEntitySecret *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 5;
    decoded = data;
}

void WaveObjects_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *WaveWireObject::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveWireObject::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveWireObject::WaveWireObject() {
    memset(this, 0, sizeof(WaveWireObject));
}

WaveWireObject::WaveWireObject(const WaveWireObject & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(WaveWireObject)
}

WaveWireObject::WaveWireObject(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(WaveWireObject)
}

WaveWireObject & WaveWireObject::operator = (const WaveWireObject & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int WaveWireObject::operator == (const WaveWireObject & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int WaveWireObject::operator != (const WaveWireObject & that) const {
    return !(operator ==(that));
}

WaveWireObject::type_id & WaveWireObject::get_type_id() {
    return type_id_field;
}

const WaveWireObject::type_id & WaveWireObject::get_type_id() const {
    return type_id_field;
}

void WaveWireObject::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

WaveWireObject::value & WaveWireObject::get_value() {
    return value_field;
}

const WaveWireObject::value & WaveWireObject::get_value() const {
    return value_field;
}

void WaveWireObject::set_value(const value & value_val) {
    value_field = value_val;
}

void *CommitmentRevocationOption::operator new(size_t size) {
    return ossNewFunc(size);
}

void CommitmentRevocationOption::operator delete(void *ptr) {
    asn1Free(ptr);
}

CommitmentRevocationOption::CommitmentRevocationOption() {
    memset(this, 0, sizeof(CommitmentRevocationOption));
}

CommitmentRevocationOption::CommitmentRevocationOption(const CommitmentRevocationOption & that) {
    OSSTRY {
	hash_field = that.hash_field;
	location_field = that.location_field;
    } OSSCLEAN(CommitmentRevocationOption)
}

CommitmentRevocationOption::CommitmentRevocationOption(const hash & hash_val, const location & location_val) {
    OSSTRY {
	hash_field = hash_val;
	location_field = location_val;
    } OSSCLEAN(CommitmentRevocationOption)
}

CommitmentRevocationOption & CommitmentRevocationOption::operator = (const CommitmentRevocationOption & that) {
    if (this == &that)
	return *this;
    hash_field = that.hash_field;
    location_field = that.location_field;
    return *this;
}

int CommitmentRevocationOption::operator == (const CommitmentRevocationOption & that) const {
    if (hash_field != that.hash_field)
	return 0;
    if (location_field != that.location_field)
	return 0;
    return 1;
}

int CommitmentRevocationOption::operator != (const CommitmentRevocationOption & that) const {
    return !(operator ==(that));
}

CommitmentRevocationOption::hash & CommitmentRevocationOption::get_hash() {
    return hash_field;
}

const CommitmentRevocationOption::hash & CommitmentRevocationOption::get_hash() const {
    return hash_field;
}

void CommitmentRevocationOption::set_hash(const hash & hash_val) {
    hash_field = hash_val;
}

CommitmentRevocationOption::location & CommitmentRevocationOption::get_location() {
    return location_field;
}

const CommitmentRevocationOption::location & CommitmentRevocationOption::get_location() const {
    return location_field;
}

void CommitmentRevocationOption::set_location(const location & location_val) {
    location_field = location_val;
}

RevocationSchemes_Type::RevocationSchemes_Type()
{
}

RevocationSchemes_Type::RevocationSchemes_Type(const RevocationSchemes_Type & that)
{
    operator =(that);
}

RevocationSchemes_Type::~RevocationSchemes_Type()
{
    cleanup_decoded();
}

RevocationSchemes_Type & RevocationSchemes_Type::operator = (const RevocationSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int RevocationSchemes_Type::operator == (const RevocationSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int RevocationSchemes_Type::operator != (const RevocationSchemes_Type & that) const
{
    return !(operator ==(that));
}

int RevocationSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int RevocationSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int RevocationSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int RevocationSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int RevocationSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

CommitmentRevocationOption *RevocationSchemes_Type::get_CommitmentRevocationOption()
{
    if (pdunum == 23)
	return (CommitmentRevocationOption *)decoded;
    else
	return NULL;
}

const CommitmentRevocationOption *RevocationSchemes_Type::get_CommitmentRevocationOption() const
{
    if (pdunum == 23)
	return (const CommitmentRevocationOption *)decoded;
    else
	return NULL;
}

void RevocationSchemes_Type::set_CommitmentRevocationOption(const CommitmentRevocationOption & data)
{
    void *copy;

    copy = new CommitmentRevocationOption(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 23;
	decoded = copy;
    }
}

CommitmentRevocationOption *RevocationSchemes_Type::release_CommitmentRevocationOption()
{
    pdunum = 0;
    decoded = NULL;
    return get_CommitmentRevocationOption();
}

void RevocationSchemes_Type::set_CommitmentRevocationOption(CommitmentRevocationOption *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 23;
    decoded = data;
}

void RevocationSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq1::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq1::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq1::__seq1() {
    memset(this, 0, sizeof(__seq1));
}

__seq1::__seq1(const __seq1 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq1)
}

__seq1::__seq1(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq1)
}

__seq1 & __seq1::operator = (const __seq1 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq1::operator == (const __seq1 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq1::operator != (const __seq1 & that) const {
    return !(operator ==(that));
}

__seq1::type_id & __seq1::get_type_id() {
    return type_id_field;
}

const __seq1::type_id & __seq1::get_type_id() const {
    return type_id_field;
}

void __seq1::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq1::value & __seq1::get_value() {
    return value_field;
}

const __seq1::value & __seq1::get_value() const {
    return value_field;
}

void __seq1::set_value(const value & value_val) {
    value_field = value_val;
}

void *RevocationOption::operator new(size_t size) {
    return ossNewFunc(size);
}

void RevocationOption::operator delete(void *ptr) {
    asn1Free(ptr);
}

RevocationOption::RevocationOption() {
    memset(this, 0, sizeof(RevocationOption));
}

RevocationOption::RevocationOption(const RevocationOption & that) {
    OSSTRY {
	critical_field = that.critical_field;
	scheme_field = that.scheme_field;
    } OSSCLEAN(RevocationOption)
}

RevocationOption::RevocationOption(critical critical_val, const scheme & scheme_val) {
    OSSTRY {
	critical_field = critical_val;
	scheme_field = scheme_val;
    } OSSCLEAN(RevocationOption)
}

RevocationOption & RevocationOption::operator = (const RevocationOption & that) {
    if (this == &that)
	return *this;
    critical_field = that.critical_field;
    scheme_field = that.scheme_field;
    return *this;
}

int RevocationOption::operator == (const RevocationOption & that) const {
    if (critical_field != that.critical_field)
	return 0;
    if (scheme_field != that.scheme_field)
	return 0;
    return 1;
}

int RevocationOption::operator != (const RevocationOption & that) const {
    return !(operator ==(that));
}

RevocationOption::critical & RevocationOption::get_critical() {
    return critical_field;
}

RevocationOption::critical RevocationOption::get_critical() const {
    return critical_field;
}

void RevocationOption::set_critical(critical critical_val) {
    critical_field = critical_val;
}

RevocationOption::scheme & RevocationOption::get_scheme() {
    return scheme_field;
}

const RevocationOption::scheme & RevocationOption::get_scheme() const {
    return scheme_field;
}

void RevocationOption::set_scheme(const scheme & scheme_val) {
    scheme_field = scheme_val;
}

void *Extension::operator new(size_t size) {
    return ossNewFunc(size);
}

void Extension::operator delete(void *ptr) {
    asn1Free(ptr);
}

Extension::Extension() {
    memset(this, 0, sizeof(Extension));
}

Extension::Extension(const Extension & that) {
    OSSTRY {
	extnID_field = that.extnID_field;
	critical_field = that.critical_field;
	value_field = that.value_field;
    } OSSCLEAN(Extension)
}

Extension::Extension(const extnID & extnID_val, critical critical_val, const value & value_val) {
    OSSTRY {
	extnID_field = extnID_val;
	critical_field = critical_val;
	value_field = value_val;
    } OSSCLEAN(Extension)
}

Extension & Extension::operator = (const Extension & that) {
    if (this == &that)
	return *this;
    extnID_field = that.extnID_field;
    critical_field = that.critical_field;
    value_field = that.value_field;
    return *this;
}

int Extension::operator == (const Extension & that) const {
    if (extnID_field != that.extnID_field)
	return 0;
    if (critical_field != that.critical_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int Extension::operator != (const Extension & that) const {
    return !(operator ==(that));
}

Extension::extnID & Extension::get_extnID() {
    return extnID_field;
}

const Extension::extnID & Extension::get_extnID() const {
    return extnID_field;
}

void Extension::set_extnID(const extnID & extnID_val) {
    extnID_field = extnID_val;
}

Extension::critical & Extension::get_critical() {
    return critical_field;
}

Extension::critical Extension::get_critical() const {
    return critical_field;
}

void Extension::set_critical(critical critical_val) {
    critical_field = critical_val;
}

Extension::value & Extension::get_value() {
    return value_field;
}

const Extension::value & Extension::get_value() const {
    return value_field;
}

void Extension::set_value(const value & value_val) {
    value_field = value_val;
}

EntitySecretKeySchemes_Type::EntitySecretKeySchemes_Type()
{
}

EntitySecretKeySchemes_Type::EntitySecretKeySchemes_Type(const EntitySecretKeySchemes_Type & that)
{
    operator =(that);
}

EntitySecretKeySchemes_Type::~EntitySecretKeySchemes_Type()
{
    cleanup_decoded();
}

EntitySecretKeySchemes_Type & EntitySecretKeySchemes_Type::operator = (const EntitySecretKeySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int EntitySecretKeySchemes_Type::operator == (const EntitySecretKeySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int EntitySecretKeySchemes_Type::operator != (const EntitySecretKeySchemes_Type & that) const
{
    return !(operator ==(that));
}

int EntitySecretKeySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int EntitySecretKeySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int EntitySecretKeySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int EntitySecretKeySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int EntitySecretKeySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

Private_Ed25519 *EntitySecretKeySchemes_Type::get_Private_Ed25519()
{
    if (pdunum == 25)
	return (Private_Ed25519 *)decoded;
    else
	return NULL;
}

const Private_Ed25519 *EntitySecretKeySchemes_Type::get_Private_Ed25519() const
{
    if (pdunum == 25)
	return (const Private_Ed25519 *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Private_Ed25519(const Private_Ed25519 & data)
{
    void *copy;

    copy = new Private_Ed25519(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 25;
	decoded = copy;
    }
}

Private_Ed25519 *EntitySecretKeySchemes_Type::release_Private_Ed25519()
{
    pdunum = 0;
    decoded = NULL;
    return get_Private_Ed25519();
}

void EntitySecretKeySchemes_Type::set_Private_Ed25519(Private_Ed25519 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 25;
    decoded = data;
}

Private_Curve25519 *EntitySecretKeySchemes_Type::get_Private_Curve25519()
{
    if (pdunum == 26)
	return (Private_Curve25519 *)decoded;
    else
	return NULL;
}

const Private_Curve25519 *EntitySecretKeySchemes_Type::get_Private_Curve25519() const
{
    if (pdunum == 26)
	return (const Private_Curve25519 *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Private_Curve25519(const Private_Curve25519 & data)
{
    void *copy;

    copy = new Private_Curve25519(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 26;
	decoded = copy;
    }
}

Private_Curve25519 *EntitySecretKeySchemes_Type::release_Private_Curve25519()
{
    pdunum = 0;
    decoded = NULL;
    return get_Private_Curve25519();
}

void EntitySecretKeySchemes_Type::set_Private_Curve25519(Private_Curve25519 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 26;
    decoded = data;
}

Private_BN256_OAQUE *EntitySecretKeySchemes_Type::get_Private_BN256_OAQUE()
{
    if (pdunum == 27)
	return (Private_BN256_OAQUE *)decoded;
    else
	return NULL;
}

const Private_BN256_OAQUE *EntitySecretKeySchemes_Type::get_Private_BN256_OAQUE() const
{
    if (pdunum == 27)
	return (const Private_BN256_OAQUE *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Private_BN256_OAQUE(const Private_BN256_OAQUE & data)
{
    void *copy;

    copy = new Private_BN256_OAQUE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 27;
	decoded = copy;
    }
}

Private_BN256_OAQUE *EntitySecretKeySchemes_Type::release_Private_BN256_OAQUE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Private_BN256_OAQUE();
}

void EntitySecretKeySchemes_Type::set_Private_BN256_OAQUE(Private_BN256_OAQUE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 27;
    decoded = data;
}

Master_BN256_OAQUE *EntitySecretKeySchemes_Type::get_Master_BN256_OAQUE()
{
    if (pdunum == 29)
	return (Master_BN256_OAQUE *)decoded;
    else
	return NULL;
}

const Master_BN256_OAQUE *EntitySecretKeySchemes_Type::get_Master_BN256_OAQUE() const
{
    if (pdunum == 29)
	return (const Master_BN256_OAQUE *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Master_BN256_OAQUE(const Master_BN256_OAQUE & data)
{
    void *copy;

    copy = new Master_BN256_OAQUE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 29;
	decoded = copy;
    }
}

Master_BN256_OAQUE *EntitySecretKeySchemes_Type::release_Master_BN256_OAQUE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Master_BN256_OAQUE();
}

void EntitySecretKeySchemes_Type::set_Master_BN256_OAQUE(Master_BN256_OAQUE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 29;
    decoded = data;
}

Master_BN256_IBE *EntitySecretKeySchemes_Type::get_Master_BN256_IBE()
{
    if (pdunum == 30)
	return (Master_BN256_IBE *)decoded;
    else
	return NULL;
}

const Master_BN256_IBE *EntitySecretKeySchemes_Type::get_Master_BN256_IBE() const
{
    if (pdunum == 30)
	return (const Master_BN256_IBE *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Master_BN256_IBE(const Master_BN256_IBE & data)
{
    void *copy;

    copy = new Master_BN256_IBE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 30;
	decoded = copy;
    }
}

Master_BN256_IBE *EntitySecretKeySchemes_Type::release_Master_BN256_IBE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Master_BN256_IBE();
}

void EntitySecretKeySchemes_Type::set_Master_BN256_IBE(Master_BN256_IBE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 30;
    decoded = data;
}

Private_BN256_IBE *EntitySecretKeySchemes_Type::get_Private_BN256_IBE()
{
    if (pdunum == 28)
	return (Private_BN256_IBE *)decoded;
    else
	return NULL;
}

const Private_BN256_IBE *EntitySecretKeySchemes_Type::get_Private_BN256_IBE() const
{
    if (pdunum == 28)
	return (const Private_BN256_IBE *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Private_BN256_IBE(const Private_BN256_IBE & data)
{
    void *copy;

    copy = new Private_BN256_IBE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 28;
	decoded = copy;
    }
}

Private_BN256_IBE *EntitySecretKeySchemes_Type::release_Private_BN256_IBE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Private_BN256_IBE();
}

void EntitySecretKeySchemes_Type::set_Private_BN256_IBE(Private_BN256_IBE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 28;
    decoded = data;
}

void EntitySecretKeySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *EntityPrivateKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void EntityPrivateKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

EntityPrivateKey::EntityPrivateKey() {
    memset(this, 0, sizeof(EntityPrivateKey));
}

EntityPrivateKey::EntityPrivateKey(const EntityPrivateKey & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(EntityPrivateKey)
}

EntityPrivateKey::EntityPrivateKey(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(EntityPrivateKey)
}

EntityPrivateKey & EntityPrivateKey::operator = (const EntityPrivateKey & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int EntityPrivateKey::operator == (const EntityPrivateKey & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int EntityPrivateKey::operator != (const EntityPrivateKey & that) const {
    return !(operator ==(that));
}

EntityPrivateKey::type_id & EntityPrivateKey::get_type_id() {
    return type_id_field;
}

const EntityPrivateKey::type_id & EntityPrivateKey::get_type_id() const {
    return type_id_field;
}

void EntityPrivateKey::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

EntityPrivateKey::value & EntityPrivateKey::get_value() {
    return value_field;
}

const EntityPrivateKey::value & EntityPrivateKey::get_value() const {
    return value_field;
}

void EntityPrivateKey::set_value(const value & value_val) {
    value_field = value_val;
}

void *EntityKeyringEntry::operator new(size_t size) {
    return ossNewFunc(size);
}

void EntityKeyringEntry::operator delete(void *ptr) {
    asn1Free(ptr);
}

EntityKeyringEntry::EntityKeyringEntry() {
    memset(this, 0, sizeof(EntityKeyringEntry));
}

EntityKeyringEntry::EntityKeyringEntry(const EntityKeyringEntry & that) {
    OSSTRY {
	EntityKeyringEntry_public_field = that.EntityKeyringEntry_public_field;
	secret_field = that.secret_field;
    } OSSCLEAN(EntityKeyringEntry)
}

EntityKeyringEntry::EntityKeyringEntry(const EntityKeyringEntry_public & EntityKeyringEntry_public_val, 
    const secret & secret_val) {
    OSSTRY {
	EntityKeyringEntry_public_field = EntityKeyringEntry_public_val;
	secret_field = secret_val;
    } OSSCLEAN(EntityKeyringEntry)
}

EntityKeyringEntry & EntityKeyringEntry::operator = (const EntityKeyringEntry & that) {
    if (this == &that)
	return *this;
    EntityKeyringEntry_public_field = that.EntityKeyringEntry_public_field;
    secret_field = that.secret_field;
    return *this;
}

int EntityKeyringEntry::operator == (const EntityKeyringEntry & that) const {
    if (EntityKeyringEntry_public_field != that.EntityKeyringEntry_public_field)
	return 0;
    if (secret_field != that.secret_field)
	return 0;
    return 1;
}

int EntityKeyringEntry::operator != (const EntityKeyringEntry & that) const {
    return !(operator ==(that));
}

EntityKeyringEntry::EntityKeyringEntry_public & EntityKeyringEntry::get_EntityKeyringEntry_public() {
    return EntityKeyringEntry_public_field;
}

const EntityKeyringEntry::EntityKeyringEntry_public & EntityKeyringEntry::get_EntityKeyringEntry_public() const {
    return EntityKeyringEntry_public_field;
}

void EntityKeyringEntry::set_EntityKeyringEntry_public(const EntityKeyringEntry_public & EntityKeyringEntry_public_val) {
    EntityKeyringEntry_public_field = EntityKeyringEntry_public_val;
}

EntityKeyringEntry::secret & EntityKeyringEntry::get_secret() {
    return secret_field;
}

const EntityKeyringEntry::secret & EntityKeyringEntry::get_secret() const {
    return secret_field;
}

void EntityKeyringEntry::set_secret(const secret & secret_val) {
    secret_field = secret_val;
}

PolicyAddendumSchemes_Type::PolicyAddendumSchemes_Type()
{
}

PolicyAddendumSchemes_Type::PolicyAddendumSchemes_Type(const PolicyAddendumSchemes_Type & that)
{
    operator =(that);
}

PolicyAddendumSchemes_Type::~PolicyAddendumSchemes_Type()
{
    cleanup_decoded();
}

PolicyAddendumSchemes_Type & PolicyAddendumSchemes_Type::operator = (const PolicyAddendumSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int PolicyAddendumSchemes_Type::operator == (const PolicyAddendumSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int PolicyAddendumSchemes_Type::operator != (const PolicyAddendumSchemes_Type & that) const
{
    return !(operator ==(that));
}

int PolicyAddendumSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int PolicyAddendumSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int PolicyAddendumSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int PolicyAddendumSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int PolicyAddendumSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

EntityKeyringEntry *PolicyAddendumSchemes_Type::get_EntityKeyringEntry()
{
    if (pdunum == 7)
	return (EntityKeyringEntry *)decoded;
    else
	return NULL;
}

const EntityKeyringEntry *PolicyAddendumSchemes_Type::get_EntityKeyringEntry() const
{
    if (pdunum == 7)
	return (const EntityKeyringEntry *)decoded;
    else
	return NULL;
}

void PolicyAddendumSchemes_Type::set_EntityKeyringEntry(const EntityKeyringEntry & data)
{
    void *copy;

    copy = new EntityKeyringEntry(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 7;
	decoded = copy;
    }
}

EntityKeyringEntry *PolicyAddendumSchemes_Type::release_EntityKeyringEntry()
{
    pdunum = 0;
    decoded = NULL;
    return get_EntityKeyringEntry();
}

void PolicyAddendumSchemes_Type::set_EntityKeyringEntry(EntityKeyringEntry *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 7;
    decoded = data;
}

void PolicyAddendumSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *PolicyAddendum::operator new(size_t size) {
    return ossNewFunc(size);
}

void PolicyAddendum::operator delete(void *ptr) {
    asn1Free(ptr);
}

PolicyAddendum::PolicyAddendum() {
    memset(this, 0, sizeof(PolicyAddendum));
}

PolicyAddendum::PolicyAddendum(const PolicyAddendum & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(PolicyAddendum)
}

PolicyAddendum::PolicyAddendum(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(PolicyAddendum)
}

PolicyAddendum & PolicyAddendum::operator = (const PolicyAddendum & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int PolicyAddendum::operator == (const PolicyAddendum & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int PolicyAddendum::operator != (const PolicyAddendum & that) const {
    return !(operator ==(that));
}

PolicyAddendum::type_id & PolicyAddendum::get_type_id() {
    return type_id_field;
}

const PolicyAddendum::type_id & PolicyAddendum::get_type_id() const {
    return type_id_field;
}

void PolicyAddendum::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

PolicyAddendum::value & PolicyAddendum::get_value() {
    return value_field;
}

const PolicyAddendum::value & PolicyAddendum::get_value() const {
    return value_field;
}

void PolicyAddendum::set_value(const value & value_val) {
    value_field = value_val;
}

AttestationVerifierKeySchemes_Type::AttestationVerifierKeySchemes_Type()
{
}

AttestationVerifierKeySchemes_Type::AttestationVerifierKeySchemes_Type(const AttestationVerifierKeySchemes_Type & that)
{
    operator =(that);
}

AttestationVerifierKeySchemes_Type::~AttestationVerifierKeySchemes_Type()
{
    cleanup_decoded();
}

AttestationVerifierKeySchemes_Type & AttestationVerifierKeySchemes_Type::operator = (const AttestationVerifierKeySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int AttestationVerifierKeySchemes_Type::operator == (const AttestationVerifierKeySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int AttestationVerifierKeySchemes_Type::operator != (const AttestationVerifierKeySchemes_Type & that) const
{
    return !(operator ==(that));
}

int AttestationVerifierKeySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int AttestationVerifierKeySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int AttestationVerifierKeySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int AttestationVerifierKeySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int AttestationVerifierKeySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

AVKeyAES128_GCM *AttestationVerifierKeySchemes_Type::get_AVKeyAES128_GCM()
{
    if (pdunum == 24)
	return (AVKeyAES128_GCM *)decoded;
    else
	return NULL;
}

const AVKeyAES128_GCM *AttestationVerifierKeySchemes_Type::get_AVKeyAES128_GCM() const
{
    if (pdunum == 24)
	return (const AVKeyAES128_GCM *)decoded;
    else
	return NULL;
}

void AttestationVerifierKeySchemes_Type::set_AVKeyAES128_GCM(const AVKeyAES128_GCM & data)
{
    void *copy;

    copy = new AVKeyAES128_GCM(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 24;
	decoded = copy;
    }
}

AVKeyAES128_GCM *AttestationVerifierKeySchemes_Type::release_AVKeyAES128_GCM()
{
    pdunum = 0;
    decoded = NULL;
    return get_AVKeyAES128_GCM();
}

void AttestationVerifierKeySchemes_Type::set_AVKeyAES128_GCM(AVKeyAES128_GCM *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 24;
    decoded = data;
}

void AttestationVerifierKeySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *AttestationVerifierKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttestationVerifierKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttestationVerifierKey::AttestationVerifierKey() {
    memset(this, 0, sizeof(AttestationVerifierKey));
}

AttestationVerifierKey::AttestationVerifierKey(const AttestationVerifierKey & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(AttestationVerifierKey)
}

AttestationVerifierKey::AttestationVerifierKey(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(AttestationVerifierKey)
}

AttestationVerifierKey & AttestationVerifierKey::operator = (const AttestationVerifierKey & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int AttestationVerifierKey::operator == (const AttestationVerifierKey & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int AttestationVerifierKey::operator != (const AttestationVerifierKey & that) const {
    return !(operator ==(that));
}

AttestationVerifierKey::type_id & AttestationVerifierKey::get_type_id() {
    return type_id_field;
}

const AttestationVerifierKey::type_id & AttestationVerifierKey::get_type_id() const {
    return type_id_field;
}

void AttestationVerifierKey::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

AttestationVerifierKey::value & AttestationVerifierKey::get_value() {
    return value_field;
}

const AttestationVerifierKey::value & AttestationVerifierKey::get_value() const {
    return value_field;
}

void AttestationVerifierKey::set_value(const value & value_val) {
    value_field = value_val;
}

RevocationCheckSchemes_Type::RevocationCheckSchemes_Type()
{
}

RevocationCheckSchemes_Type::RevocationCheckSchemes_Type(const RevocationCheckSchemes_Type & that)
{
    operator =(that);
}

RevocationCheckSchemes_Type::~RevocationCheckSchemes_Type()
{
    cleanup_decoded();
}

RevocationCheckSchemes_Type & RevocationCheckSchemes_Type::operator = (const RevocationCheckSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int RevocationCheckSchemes_Type::operator == (const RevocationCheckSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int RevocationCheckSchemes_Type::operator != (const RevocationCheckSchemes_Type & that) const
{
    return !(operator ==(that));
}

int RevocationCheckSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int RevocationCheckSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int RevocationCheckSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int RevocationCheckSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int RevocationCheckSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

void RevocationCheckSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *RevocationCheck::operator new(size_t size) {
    return ossNewFunc(size);
}

void RevocationCheck::operator delete(void *ptr) {
    asn1Free(ptr);
}

RevocationCheck::RevocationCheck() {
    memset(this, 0, sizeof(RevocationCheck));
}

RevocationCheck::RevocationCheck(const RevocationCheck & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(RevocationCheck)
}

RevocationCheck::RevocationCheck(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(RevocationCheck)
}

RevocationCheck & RevocationCheck::operator = (const RevocationCheck & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int RevocationCheck::operator == (const RevocationCheck & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int RevocationCheck::operator != (const RevocationCheck & that) const {
    return !(operator ==(that));
}

RevocationCheck::type_id & RevocationCheck::get_type_id() {
    return type_id_field;
}

const RevocationCheck::type_id & RevocationCheck::get_type_id() const {
    return type_id_field;
}

void RevocationCheck::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

RevocationCheck::value & RevocationCheck::get_value() {
    return value_field;
}

const RevocationCheck::value & RevocationCheck::get_value() const {
    return value_field;
}

void RevocationCheck::set_value(const value & value_val) {
    value_field = value_val;
}

/* Auxiliary data structures and functions for class __seqof6 */

class __seqof6_member {
public:
    __seqof6_member *next;
    __seqof6::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof6_member();
    __seqof6_member(const __seqof6::component & val);
};

void *__seqof6_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof6_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof6_member::__seqof6_member() {
}

__seqof6_member::__seqof6_member(const __seqof6::component & val) {
    value = val;
}

static void *__seqof6_copy(void *that) {
    return new __seqof6_member(((__seqof6_member *)that)->value);
}

static void __seqof6_destroy(void *that) {
    delete (__seqof6_member *)that;
}

static int __seqof6_compare(void *val1, void *val2) {
    return (((__seqof6_member *)val1)->value == ((__seqof6_member *)val2)->value);
}

/* Constructors */

__seqof6::__seqof6() {
}

__seqof6::__seqof6(const __seqof6 & that) {
    OSSTRY {
	do_copy(that, &__seqof6_copy);
    } OSSCLEAN(__seqof6)
}

/* Destructor */

__seqof6::~__seqof6() {
    do_destroy(&__seqof6_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof6 & __seqof6::operator = (const __seqof6 & that) {
    do_destroy(&__seqof6_destroy);
    do_copy(that, &__seqof6_copy);
    return *this;
}

int __seqof6::operator == (const __seqof6 & that) const {
    return do_compare(that, &__seqof6_compare);
}

int __seqof6::operator != (const __seqof6 & that) const {
    return !do_compare(that, &__seqof6_compare);
}

/* Locate ("At" etc) methods */

__seqof6::component *__seqof6::at(OssIndex pos) {
    return &((__seqof6_member *)pos)->value;
}

const __seqof6::component *__seqof6::at(OssIndex pos) const {
    return &((__seqof6_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof6::prepend(const component & val) {
    __seqof6_member *newrec = new __seqof6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof6::prepend(__seqof6 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof6::insert_after(OssIndex pos, const component & val) {
    __seqof6_member *newrec = new __seqof6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof6::insert_after(OssIndex pos, __seqof6 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof6::remove_front() {
    __seqof6_member *extr = (__seqof6_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof6_destroy(extr);
    return 0;
}

int __seqof6::remove_after(OssIndex pos) {
    __seqof6_member *extr = (__seqof6_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof6_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof6 *__seqof6::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof6 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __seqof7 */

class __seqof7_member {
public:
    __seqof7_member *next;
    __seqof7::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof7_member();
    __seqof7_member(const __seqof7::component & val);
};

void *__seqof7_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof7_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof7_member::__seqof7_member() {
}

__seqof7_member::__seqof7_member(const __seqof7::component & val) {
    value = val;
}

static void *__seqof7_copy(void *that) {
    return new __seqof7_member(((__seqof7_member *)that)->value);
}

static void __seqof7_destroy(void *that) {
    delete (__seqof7_member *)that;
}

static int __seqof7_compare(void *val1, void *val2) {
    return (((__seqof7_member *)val1)->value == ((__seqof7_member *)val2)->value);
}

/* Constructors */

__seqof7::__seqof7() {
}

__seqof7::__seqof7(const __seqof7 & that) {
    OSSTRY {
	do_copy(that, &__seqof7_copy);
    } OSSCLEAN(__seqof7)
}

/* Destructor */

__seqof7::~__seqof7() {
    do_destroy(&__seqof7_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof7 & __seqof7::operator = (const __seqof7 & that) {
    do_destroy(&__seqof7_destroy);
    do_copy(that, &__seqof7_copy);
    return *this;
}

int __seqof7::operator == (const __seqof7 & that) const {
    return do_compare(that, &__seqof7_compare);
}

int __seqof7::operator != (const __seqof7 & that) const {
    return !do_compare(that, &__seqof7_compare);
}

/* Locate ("At" etc) methods */

__seqof7::component *__seqof7::at(OssIndex pos) {
    return &((__seqof7_member *)pos)->value;
}

const __seqof7::component *__seqof7::at(OssIndex pos) const {
    return &((__seqof7_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof7::prepend(const component & val) {
    __seqof7_member *newrec = new __seqof7_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof7::prepend(__seqof7 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof7::insert_after(OssIndex pos, const component & val) {
    __seqof7_member *newrec = new __seqof7_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof7::insert_after(OssIndex pos, __seqof7 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof7::remove_front() {
    __seqof7_member *extr = (__seqof7_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof7_destroy(extr);
    return 0;
}

int __seqof7::remove_after(OssIndex pos) {
    __seqof7_member *extr = (__seqof7_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof7_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof7 *__seqof7::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof7 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __seqof8 */

class __seqof8_member {
public:
    __seqof8_member *next;
    __seqof8::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof8_member();
    __seqof8_member(const __seqof8::component & val);
};

void *__seqof8_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof8_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof8_member::__seqof8_member() {
}

__seqof8_member::__seqof8_member(const __seqof8::component & val) {
    value = val;
}

static void *__seqof8_copy(void *that) {
    return new __seqof8_member(((__seqof8_member *)that)->value);
}

static void __seqof8_destroy(void *that) {
    delete (__seqof8_member *)that;
}

static int __seqof8_compare(void *val1, void *val2) {
    return (((__seqof8_member *)val1)->value == ((__seqof8_member *)val2)->value);
}

/* Constructors */

__seqof8::__seqof8() {
}

__seqof8::__seqof8(const __seqof8 & that) {
    OSSTRY {
	do_copy(that, &__seqof8_copy);
    } OSSCLEAN(__seqof8)
}

/* Destructor */

__seqof8::~__seqof8() {
    do_destroy(&__seqof8_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof8 & __seqof8::operator = (const __seqof8 & that) {
    do_destroy(&__seqof8_destroy);
    do_copy(that, &__seqof8_copy);
    return *this;
}

int __seqof8::operator == (const __seqof8 & that) const {
    return do_compare(that, &__seqof8_compare);
}

int __seqof8::operator != (const __seqof8 & that) const {
    return !do_compare(that, &__seqof8_compare);
}

/* Locate ("At" etc) methods */

__seqof8::component *__seqof8::at(OssIndex pos) {
    return &((__seqof8_member *)pos)->value;
}

const __seqof8::component *__seqof8::at(OssIndex pos) const {
    return &((__seqof8_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof8::prepend(const component & val) {
    __seqof8_member *newrec = new __seqof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof8::prepend(__seqof8 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof8::insert_after(OssIndex pos, const component & val) {
    __seqof8_member *newrec = new __seqof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof8::insert_after(OssIndex pos, __seqof8 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof8::remove_front() {
    __seqof8_member *extr = (__seqof8_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof8_destroy(extr);
    return 0;
}

int __seqof8::remove_after(OssIndex pos) {
    __seqof8_member *extr = (__seqof8_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof8_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof8 *__seqof8::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof8 *)do_extract_after(begin, end);
}

void *AttestationReference::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttestationReference::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttestationReference::AttestationReference() {
    memset(this, 0, sizeof(AttestationReference));
}

AttestationReference::AttestationReference(const AttestationReference & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	hash_field = that.hash_field;
	content_field = that.content_field;
	location_field = that.location_field;
	keys_field = that.keys_field;
	revocationChecks_field = that.revocationChecks_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(AttestationReference)
}

AttestationReference::AttestationReference(const hash & hash_val, const content & content_val, 
    const location & location_val, const keys & keys_val, const revocationChecks & revocationChecks_val, 
    const extensions & extensions_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	hash_field = hash_val;
	content_field = content_val;
	location_field = location_val;
	keys_field = keys_val;
	revocationChecks_field = revocationChecks_val;
	extensions_field = extensions_val;
    } OSSCLEAN(AttestationReference)
}

AttestationReference::AttestationReference(const hash & hash_val, const location & location_val, 
    const keys & keys_val, const revocationChecks & revocationChecks_val, const extensions & extensions_val) {
    OSSTRY {
	bit_mask = 0;
	hash_field = hash_val;
	location_field = location_val;
	keys_field = keys_val;
	revocationChecks_field = revocationChecks_val;
	extensions_field = extensions_val;
    } OSSCLEAN(AttestationReference)
}

AttestationReference & AttestationReference::operator = (const AttestationReference & that) {
    if (this == &that)
	return *this;
    this->~AttestationReference();
    bit_mask = that.bit_mask;
    hash_field = that.hash_field;
    content_field = that.content_field;
    location_field = that.location_field;
    keys_field = that.keys_field;
    revocationChecks_field = that.revocationChecks_field;
    extensions_field = that.extensions_field;
    return *this;
}

int AttestationReference::operator == (const AttestationReference & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (hash_field != that.hash_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (content_field != that.content_field)
	    return 0;
    }
    if (location_field != that.location_field)
	return 0;
    if (keys_field != that.keys_field)
	return 0;
    if (revocationChecks_field != that.revocationChecks_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    return 1;
}

int AttestationReference::operator != (const AttestationReference & that) const {
    return !(operator ==(that));
}

AttestationReference::hash & AttestationReference::get_hash() {
    return hash_field;
}

const AttestationReference::hash & AttestationReference::get_hash() const {
    return hash_field;
}

void AttestationReference::set_hash(const hash & hash_val) {
    hash_field = hash_val;
}

AttestationReference::content *AttestationReference::get_content() {
    if (bit_mask & 0x80000000)
	return &content_field;
    else
	return 0;
}

const AttestationReference::content *AttestationReference::get_content() const {
    if (bit_mask & 0x80000000)
	return &content_field;
    else
	return 0;
}

void AttestationReference::set_content(const content & content_val) {
    bit_mask |= 0x80000000;
    content_field = content_val;
}

int AttestationReference::content_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void AttestationReference::omit_content() {
    content_field.~OssString();
    bit_mask &= ~0x80000000;
}

AttestationReference::location & AttestationReference::get_location() {
    return location_field;
}

const AttestationReference::location & AttestationReference::get_location() const {
    return location_field;
}

void AttestationReference::set_location(const location & location_val) {
    location_field = location_val;
}

AttestationReference::keys & AttestationReference::get_keys() {
    return keys_field;
}

const AttestationReference::keys & AttestationReference::get_keys() const {
    return keys_field;
}

void AttestationReference::set_keys(const keys & keys_val) {
    keys_field = keys_val;
}

AttestationReference::revocationChecks & AttestationReference::get_revocationChecks() {
    return revocationChecks_field;
}

const AttestationReference::revocationChecks & AttestationReference::get_revocationChecks() const {
    return revocationChecks_field;
}

void AttestationReference::set_revocationChecks(const revocationChecks & revocationChecks_val) {
    revocationChecks_field = revocationChecks_val;
}

AttestationReference::extensions & AttestationReference::get_extensions() {
    return extensions_field;
}

const AttestationReference::extensions & AttestationReference::get_extensions() const {
    return extensions_field;
}

void AttestationReference::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

void *RTreeStatement::operator new(size_t size) {
    return ossNewFunc(size);
}

void RTreeStatement::operator delete(void *ptr) {
    asn1Free(ptr);
}

RTreeStatement::RTreeStatement() {
    memset(this, 0, sizeof(RTreeStatement));
}

RTreeStatement::RTreeStatement(const RTreeStatement & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	permissionSet_field = that.permissionSet_field;
	permissions_field = that.permissions_field;
	resource_field = that.resource_field;
	comment_field = that.comment_field;
    } OSSCLEAN(RTreeStatement)
}

RTreeStatement::RTreeStatement(const permissionSet & permissionSet_val, const permissions & permissions_val, 
    const resource & resource_val, const comment & comment_val) {
    OSSTRY {
	bit_mask = 0x80000000;
	permissionSet_field = permissionSet_val;
	permissions_field = permissions_val;
	resource_field = resource_val;
	comment_field = comment_val;
    } OSSCLEAN(RTreeStatement)
}

RTreeStatement::RTreeStatement(const permissionSet & permissionSet_val, const permissions & permissions_val, 
    const resource & resource_val) {
    OSSTRY {
	bit_mask = 0;
	permissionSet_field = permissionSet_val;
	permissions_field = permissions_val;
	resource_field = resource_val;
    } OSSCLEAN(RTreeStatement)
}

RTreeStatement & RTreeStatement::operator = (const RTreeStatement & that) {
    if (this == &that)
	return *this;
    this->~RTreeStatement();
    bit_mask = that.bit_mask;
    permissionSet_field = that.permissionSet_field;
    permissions_field = that.permissions_field;
    resource_field = that.resource_field;
    comment_field = that.comment_field;
    return *this;
}

int RTreeStatement::operator == (const RTreeStatement & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (permissionSet_field != that.permissionSet_field)
	return 0;
    if (permissions_field != that.permissions_field)
	return 0;
    if (resource_field != that.resource_field)
	return 0;
    if (bit_mask & 0x80000000) {
	if (comment_field != that.comment_field)
	    return 0;
    }
    return 1;
}

int RTreeStatement::operator != (const RTreeStatement & that) const {
    return !(operator ==(that));
}

RTreeStatement::permissionSet & RTreeStatement::get_permissionSet() {
    return permissionSet_field;
}

const RTreeStatement::permissionSet & RTreeStatement::get_permissionSet() const {
    return permissionSet_field;
}

void RTreeStatement::set_permissionSet(const permissionSet & permissionSet_val) {
    permissionSet_field = permissionSet_val;
}

RTreeStatement::permissions & RTreeStatement::get_permissions() {
    return permissions_field;
}

const RTreeStatement::permissions & RTreeStatement::get_permissions() const {
    return permissions_field;
}

void RTreeStatement::set_permissions(const permissions & permissions_val) {
    permissions_field = permissions_val;
}

RTreeStatement::resource & RTreeStatement::get_resource() {
    return resource_field;
}

const RTreeStatement::resource & RTreeStatement::get_resource() const {
    return resource_field;
}

void RTreeStatement::set_resource(const resource & resource_val) {
    resource_field = resource_val;
}

RTreeStatement::comment *RTreeStatement::get_comment() {
    if (bit_mask & 0x80000000)
	return &comment_field;
    else
	return 0;
}

const RTreeStatement::comment *RTreeStatement::get_comment() const {
    if (bit_mask & 0x80000000)
	return &comment_field;
    else
	return 0;
}

void RTreeStatement::set_comment(const comment & comment_val) {
    bit_mask |= 0x80000000;
    comment_field = comment_val;
}

int RTreeStatement::comment_is_present() const {
    return !!(bit_mask & 0x80000000);
}

void RTreeStatement::omit_comment() {
    comment_field.~OssString();
    bit_mask &= ~0x80000000;
}

void *WR1Envelope::operator new(size_t size) {
    return ossNewFunc(size);
}

void WR1Envelope::operator delete(void *ptr) {
    asn1Free(ptr);
}

WR1Envelope::WR1Envelope() {
    memset(this, 0, sizeof(WR1Envelope));
}

WR1Envelope::WR1Envelope(const WR1Envelope & that) {
    OSSTRY {
	bodyKeys_oaque_field = that.bodyKeys_oaque_field;
	partition_field = that.partition_field;
    } OSSCLEAN(WR1Envelope)
}

WR1Envelope::WR1Envelope(const bodyKeys_oaque & bodyKeys_oaque_val, const partition & partition_val) {
    OSSTRY {
	bodyKeys_oaque_field = bodyKeys_oaque_val;
	partition_field = partition_val;
    } OSSCLEAN(WR1Envelope)
}

WR1Envelope & WR1Envelope::operator = (const WR1Envelope & that) {
    if (this == &that)
	return *this;
    bodyKeys_oaque_field = that.bodyKeys_oaque_field;
    partition_field = that.partition_field;
    return *this;
}

int WR1Envelope::operator == (const WR1Envelope & that) const {
    if (bodyKeys_oaque_field != that.bodyKeys_oaque_field)
	return 0;
    if (partition_field != that.partition_field)
	return 0;
    return 1;
}

int WR1Envelope::operator != (const WR1Envelope & that) const {
    return !(operator ==(that));
}

WR1Envelope::bodyKeys_oaque & WR1Envelope::get_bodyKeys_oaque() {
    return bodyKeys_oaque_field;
}

const WR1Envelope::bodyKeys_oaque & WR1Envelope::get_bodyKeys_oaque() const {
    return bodyKeys_oaque_field;
}

void WR1Envelope::set_bodyKeys_oaque(const bodyKeys_oaque & bodyKeys_oaque_val) {
    bodyKeys_oaque_field = bodyKeys_oaque_val;
}

WR1Envelope::partition & WR1Envelope::get_partition() {
    return partition_field;
}

const WR1Envelope::partition & WR1Envelope::get_partition() const {
    return partition_field;
}

void WR1Envelope::set_partition(const partition & partition_val) {
    partition_field = partition_val;
}

void *WR1ProverBody::operator new(size_t size) {
    return ossNewFunc(size);
}

void WR1ProverBody::operator delete(void *ptr) {
    asn1Free(ptr);
}

WR1ProverBody::WR1ProverBody() {
    memset(this, 0, sizeof(WR1ProverBody));
}

WR1ProverBody::WR1ProverBody(const WR1ProverBody & that) {
    OSSTRY {
	addendums_field = that.addendums_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(WR1ProverBody)
}

WR1ProverBody::WR1ProverBody(const addendums & addendums_val, const extensions & extensions_val) {
    OSSTRY {
	addendums_field = addendums_val;
	extensions_field = extensions_val;
    } OSSCLEAN(WR1ProverBody)
}

WR1ProverBody & WR1ProverBody::operator = (const WR1ProverBody & that) {
    if (this == &that)
	return *this;
    addendums_field = that.addendums_field;
    extensions_field = that.extensions_field;
    return *this;
}

int WR1ProverBody::operator == (const WR1ProverBody & that) const {
    if (addendums_field != that.addendums_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    return 1;
}

int WR1ProverBody::operator != (const WR1ProverBody & that) const {
    return !(operator ==(that));
}

WR1ProverBody::addendums & WR1ProverBody::get_addendums() {
    return addendums_field;
}

const WR1ProverBody::addendums & WR1ProverBody::get_addendums() const {
    return addendums_field;
}

void WR1ProverBody::set_addendums(const addendums & addendums_val) {
    addendums_field = addendums_val;
}

WR1ProverBody::extensions & WR1ProverBody::get_extensions() {
    return extensions_field;
}

const WR1ProverBody::extensions & WR1ProverBody::get_extensions() const {
    return extensions_field;
}

void WR1ProverBody::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

void *WR1VerifierBody::operator new(size_t size) {
    return ossNewFunc(size);
}

void WR1VerifierBody::operator delete(void *ptr) {
    asn1Free(ptr);
}

WR1VerifierBody::WR1VerifierBody() {
    memset(this, 0, sizeof(WR1VerifierBody));
}

WR1VerifierBody::WR1VerifierBody(const WR1VerifierBody & that) {
    OSSTRY {
	attestationVerifierBody_field = that.attestationVerifierBody_field;
    } OSSCLEAN(WR1VerifierBody)
}

WR1VerifierBody::WR1VerifierBody(const attestationVerifierBody & attestationVerifierBody_val) {
    OSSTRY {
	attestationVerifierBody_field = attestationVerifierBody_val;
    } OSSCLEAN(WR1VerifierBody)
}

WR1VerifierBody & WR1VerifierBody::operator = (const WR1VerifierBody & that) {
    if (this == &that)
	return *this;
    attestationVerifierBody_field = that.attestationVerifierBody_field;
    return *this;
}

int WR1VerifierBody::operator == (const WR1VerifierBody & that) const {
    if (attestationVerifierBody_field != that.attestationVerifierBody_field)
	return 0;
    return 1;
}

int WR1VerifierBody::operator != (const WR1VerifierBody & that) const {
    return !(operator ==(that));
}

WR1VerifierBody::attestationVerifierBody & WR1VerifierBody::get_attestationVerifierBody() {
    return attestationVerifierBody_field;
}

const WR1VerifierBody::attestationVerifierBody & WR1VerifierBody::get_attestationVerifierBody() const {
    return attestationVerifierBody_field;
}

void WR1VerifierBody::set_attestationVerifierBody(const attestationVerifierBody & attestationVerifierBody_val) {
    attestationVerifierBody_field = attestationVerifierBody_val;
}

/* Universal PDU class */

objects_PDU::objects_PDU() {
}

void objects_PDU::set_WaveWireObject(WaveWireObject & d) {
    index = 1;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveWireObject *objects_PDU::get_WaveWireObject() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 1 && !constant)
#else
    if (index == 1)
#endif
	return (WaveWireObject *)data;
    else
	return 0;
}

void objects_PDU::set_WaveAttestation(WaveAttestation & d) {
    index = 2;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveAttestation *objects_PDU::get_WaveAttestation() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 2 && !constant)
#else
    if (index == 2)
#endif
	return (WaveAttestation *)data;
    else
	return 0;
}

void objects_PDU::set_AttestationBody(AttestationBody & d) {
    index = 3;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttestationBody *objects_PDU::get_AttestationBody() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 3 && !constant)
#else
    if (index == 3)
#endif
	return (AttestationBody *)data;
    else
	return 0;
}

void objects_PDU::set_WaveEntity(WaveEntity & d) {
    index = 4;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveEntity *objects_PDU::get_WaveEntity() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 4 && !constant)
#else
    if (index == 4)
#endif
	return (WaveEntity *)data;
    else
	return 0;
}

void objects_PDU::set_WaveEntitySecret(WaveEntitySecret & d) {
    index = 5;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveEntitySecret *objects_PDU::get_WaveEntitySecret() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 5 && !constant)
#else
    if (index == 5)
#endif
	return (WaveEntitySecret *)data;
    else
	return 0;
}

void objects_PDU::set_EntityKeyring(EntityKeyring & d) {
    index = 6;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EntityKeyring *objects_PDU::get_EntityKeyring() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 6 && !constant)
#else
    if (index == 6)
#endif
	return (EntityKeyring *)data;
    else
	return 0;
}

void objects_PDU::set_EntityKeyringEntry(EntityKeyringEntry & d) {
    index = 7;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EntityKeyringEntry *objects_PDU::get_EntityKeyringEntry() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 7 && !constant)
#else
    if (index == 7)
#endif
	return (EntityKeyringEntry *)data;
    else
	return 0;
}

void objects_PDU::set_WaveExplicitProof(WaveExplicitProof & d) {
    index = 8;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveExplicitProof *objects_PDU::get_WaveExplicitProof() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 8 && !constant)
#else
    if (index == 8)
#endif
	return (WaveExplicitProof *)data;
    else
	return 0;
}

void objects_PDU::set_RTreePolicy(RTreePolicy & d) {
    index = 9;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

RTreePolicy *objects_PDU::get_RTreePolicy() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 9 && !constant)
#else
    if (index == 9)
#endif
	return (RTreePolicy *)data;
    else
	return 0;
}

void objects_PDU::set_HashSha3_256(HashSha3_256 & d) {
    index = 10;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashSha3_256 *objects_PDU::get_HashSha3_256() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 10 && !constant)
#else
    if (index == 10)
#endif
	return (HashSha3_256 *)data;
    else
	return 0;
}

void objects_PDU::set_HashSha_256(HashSha_256 & d) {
    index = 11;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashSha_256 *objects_PDU::get_HashSha_256() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 11 && !constant)
#else
    if (index == 11)
#endif
	return (HashSha_256 *)data;
    else
	return 0;
}

void objects_PDU::set_HashKeccak_256(HashKeccak_256 & d) {
    index = 12;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashKeccak_256 *objects_PDU::get_HashKeccak_256() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 12 && !constant)
#else
    if (index == 12)
#endif
	return (HashKeccak_256 *)data;
    else
	return 0;
}

void objects_PDU::set_LocationURL(LocationURL & d) {
    index = 13;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocationURL *objects_PDU::get_LocationURL() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 13 && !constant)
#else
    if (index == 13)
#endif
	return (LocationURL *)data;
    else
	return 0;
}

void objects_PDU::set_LocationEthereum(LocationEthereum & d) {
    index = 14;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocationEthereum *objects_PDU::get_LocationEthereum() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 14 && !constant)
#else
    if (index == 14)
#endif
	return (LocationEthereum *)data;
    else
	return 0;
}

void objects_PDU::set_PSKBodyCiphertext(PSKBodyCiphertext & d) {
    index = 15;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PSKBodyCiphertext *objects_PDU::get_PSKBodyCiphertext() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 15 && !constant)
#else
    if (index == 15)
#endif
	return (PSKBodyCiphertext *)data;
    else
	return 0;
}

void objects_PDU::set_WR1BodyCiphertext(WR1BodyCiphertext & d) {
    index = 16;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1BodyCiphertext *objects_PDU::get_WR1BodyCiphertext() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 16 && !constant)
#else
    if (index == 16)
#endif
	return (WR1BodyCiphertext *)data;
    else
	return 0;
}

void objects_PDU::set_WR1Envelope(WR1Envelope & d) {
    index = 17;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1Envelope *objects_PDU::get_WR1Envelope() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 17 && !constant)
#else
    if (index == 17)
#endif
	return (WR1Envelope *)data;
    else
	return 0;
}

void objects_PDU::set_WR1ProverBody(WR1ProverBody & d) {
    index = 18;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1ProverBody *objects_PDU::get_WR1ProverBody() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 18 && !constant)
#else
    if (index == 18)
#endif
	return (WR1ProverBody *)data;
    else
	return 0;
}

void objects_PDU::set_WR1VerifierBody(WR1VerifierBody & d) {
    index = 19;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1VerifierBody *objects_PDU::get_WR1VerifierBody() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 19 && !constant)
#else
    if (index == 19)
#endif
	return (WR1VerifierBody *)data;
    else
	return 0;
}

void objects_PDU::set_Ed25519OuterSignature(Ed25519OuterSignature & d) {
    index = 20;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Ed25519OuterSignature *objects_PDU::get_Ed25519OuterSignature() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 20 && !constant)
#else
    if (index == 20)
#endif
	return (Ed25519OuterSignature *)data;
    else
	return 0;
}

void objects_PDU::set_SignedOuterKey(SignedOuterKey & d) {
    index = 21;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SignedOuterKey *objects_PDU::get_SignedOuterKey() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 21 && !constant)
#else
    if (index == 21)
#endif
	return (SignedOuterKey *)data;
    else
	return 0;
}

void objects_PDU::set_TrustLevel(TrustLevel & d) {
    index = 22;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TrustLevel *objects_PDU::get_TrustLevel() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 22 && !constant)
#else
    if (index == 22)
#endif
	return (TrustLevel *)data;
    else
	return 0;
}

void objects_PDU::set_CommitmentRevocationOption(CommitmentRevocationOption & d) {
    index = 23;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommitmentRevocationOption *objects_PDU::get_CommitmentRevocationOption() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 23 && !constant)
#else
    if (index == 23)
#endif
	return (CommitmentRevocationOption *)data;
    else
	return 0;
}

void objects_PDU::set_AVKeyAES128_GCM(AVKeyAES128_GCM & d) {
    index = 24;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AVKeyAES128_GCM *objects_PDU::get_AVKeyAES128_GCM() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 24 && !constant)
#else
    if (index == 24)
#endif
	return (AVKeyAES128_GCM *)data;
    else
	return 0;
}

void objects_PDU::set_Private_Ed25519(Private_Ed25519 & d) {
    index = 25;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_Ed25519 *objects_PDU::get_Private_Ed25519() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 25 && !constant)
#else
    if (index == 25)
#endif
	return (Private_Ed25519 *)data;
    else
	return 0;
}

void objects_PDU::set_Private_Curve25519(Private_Curve25519 & d) {
    index = 26;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_Curve25519 *objects_PDU::get_Private_Curve25519() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 26 && !constant)
#else
    if (index == 26)
#endif
	return (Private_Curve25519 *)data;
    else
	return 0;
}

void objects_PDU::set_Private_BN256_OAQUE(Private_BN256_OAQUE & d) {
    index = 27;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_BN256_OAQUE *objects_PDU::get_Private_BN256_OAQUE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 27 && !constant)
#else
    if (index == 27)
#endif
	return (Private_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_Private_BN256_IBE(Private_BN256_IBE & d) {
    index = 28;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_BN256_IBE *objects_PDU::get_Private_BN256_IBE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 28 && !constant)
#else
    if (index == 28)
#endif
	return (Private_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_Master_BN256_OAQUE(Master_BN256_OAQUE & d) {
    index = 29;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Master_BN256_OAQUE *objects_PDU::get_Master_BN256_OAQUE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 29 && !constant)
#else
    if (index == 29)
#endif
	return (Master_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_Master_BN256_IBE(Master_BN256_IBE & d) {
    index = 30;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Master_BN256_IBE *objects_PDU::get_Master_BN256_IBE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 30 && !constant)
#else
    if (index == 30)
#endif
	return (Master_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_Public_Ed25519(Public_Ed25519 & d) {
    index = 31;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_Ed25519 *objects_PDU::get_Public_Ed25519() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 31 && !constant)
#else
    if (index == 31)
#endif
	return (Public_Ed25519 *)data;
    else
	return 0;
}

void objects_PDU::set_Public_Curve25519(Public_Curve25519 & d) {
    index = 32;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_Curve25519 *objects_PDU::get_Public_Curve25519() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 32 && !constant)
#else
    if (index == 32)
#endif
	return (Public_Curve25519 *)data;
    else
	return 0;
}

void objects_PDU::set_Public_OAQUE(Public_OAQUE & d) {
    index = 33;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_OAQUE *objects_PDU::get_Public_OAQUE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 33 && !constant)
#else
    if (index == 33)
#endif
	return (Public_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_Params_BN256_OAQUE(Params_BN256_OAQUE & d) {
    index = 34;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Params_BN256_OAQUE *objects_PDU::get_Params_BN256_OAQUE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 34 && !constant)
#else
    if (index == 34)
#endif
	return (Params_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_Params_BN256_IBE(Params_BN256_IBE & d) {
    index = 35;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Params_BN256_IBE *objects_PDU::get_Params_BN256_IBE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 35 && !constant)
#else
    if (index == 35)
#endif
	return (Params_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_Public_BN256_IBE(Public_BN256_IBE & d) {
    index = 36;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_BN256_IBE *objects_PDU::get_Public_BN256_IBE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 36 && !constant)
#else
    if (index == 36)
#endif
	return (Public_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_KeyringAESCiphertext(KeyringAESCiphertext & d) {
    index = 37;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KeyringAESCiphertext *objects_PDU::get_KeyringAESCiphertext() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 37 && !constant)
#else
    if (index == 37)
#endif
	return (KeyringAESCiphertext *)data;
    else
	return 0;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
void objects_PDU::set_const_WaveWireObject(const WaveWireObject & d) {
    index = 1;
    data = (void *)&d;
    constant = 1;
}

const WaveWireObject *objects_PDU::get_const_WaveWireObject() const {
    if (index == 1)
	return (const WaveWireObject *)data;
    else
	return 0;
}

void objects_PDU::set_const_WaveAttestation(const WaveAttestation & d) {
    index = 2;
    data = (void *)&d;
    constant = 1;
}

const WaveAttestation *objects_PDU::get_const_WaveAttestation() const {
    if (index == 2)
	return (const WaveAttestation *)data;
    else
	return 0;
}

void objects_PDU::set_const_AttestationBody(const AttestationBody & d) {
    index = 3;
    data = (void *)&d;
    constant = 1;
}

const AttestationBody *objects_PDU::get_const_AttestationBody() const {
    if (index == 3)
	return (const AttestationBody *)data;
    else
	return 0;
}

void objects_PDU::set_const_WaveEntity(const WaveEntity & d) {
    index = 4;
    data = (void *)&d;
    constant = 1;
}

const WaveEntity *objects_PDU::get_const_WaveEntity() const {
    if (index == 4)
	return (const WaveEntity *)data;
    else
	return 0;
}

void objects_PDU::set_const_WaveEntitySecret(const WaveEntitySecret & d) {
    index = 5;
    data = (void *)&d;
    constant = 1;
}

const WaveEntitySecret *objects_PDU::get_const_WaveEntitySecret() const {
    if (index == 5)
	return (const WaveEntitySecret *)data;
    else
	return 0;
}

void objects_PDU::set_const_EntityKeyring(const EntityKeyring & d) {
    index = 6;
    data = (void *)&d;
    constant = 1;
}

const EntityKeyring *objects_PDU::get_const_EntityKeyring() const {
    if (index == 6)
	return (const EntityKeyring *)data;
    else
	return 0;
}

void objects_PDU::set_const_EntityKeyringEntry(const EntityKeyringEntry & d) {
    index = 7;
    data = (void *)&d;
    constant = 1;
}

const EntityKeyringEntry *objects_PDU::get_const_EntityKeyringEntry() const {
    if (index == 7)
	return (const EntityKeyringEntry *)data;
    else
	return 0;
}

void objects_PDU::set_const_WaveExplicitProof(const WaveExplicitProof & d) {
    index = 8;
    data = (void *)&d;
    constant = 1;
}

const WaveExplicitProof *objects_PDU::get_const_WaveExplicitProof() const {
    if (index == 8)
	return (const WaveExplicitProof *)data;
    else
	return 0;
}

void objects_PDU::set_const_RTreePolicy(const RTreePolicy & d) {
    index = 9;
    data = (void *)&d;
    constant = 1;
}

const RTreePolicy *objects_PDU::get_const_RTreePolicy() const {
    if (index == 9)
	return (const RTreePolicy *)data;
    else
	return 0;
}

void objects_PDU::set_const_HashSha3_256(const HashSha3_256 & d) {
    index = 10;
    data = (void *)&d;
    constant = 1;
}

const HashSha3_256 *objects_PDU::get_const_HashSha3_256() const {
    if (index == 10)
	return (const HashSha3_256 *)data;
    else
	return 0;
}

void objects_PDU::set_const_HashSha_256(const HashSha_256 & d) {
    index = 11;
    data = (void *)&d;
    constant = 1;
}

const HashSha_256 *objects_PDU::get_const_HashSha_256() const {
    if (index == 11)
	return (const HashSha_256 *)data;
    else
	return 0;
}

void objects_PDU::set_const_HashKeccak_256(const HashKeccak_256 & d) {
    index = 12;
    data = (void *)&d;
    constant = 1;
}

const HashKeccak_256 *objects_PDU::get_const_HashKeccak_256() const {
    if (index == 12)
	return (const HashKeccak_256 *)data;
    else
	return 0;
}

void objects_PDU::set_const_LocationURL(const LocationURL & d) {
    index = 13;
    data = (void *)&d;
    constant = 1;
}

const LocationURL *objects_PDU::get_const_LocationURL() const {
    if (index == 13)
	return (const LocationURL *)data;
    else
	return 0;
}

void objects_PDU::set_const_LocationEthereum(const LocationEthereum & d) {
    index = 14;
    data = (void *)&d;
    constant = 1;
}

const LocationEthereum *objects_PDU::get_const_LocationEthereum() const {
    if (index == 14)
	return (const LocationEthereum *)data;
    else
	return 0;
}

void objects_PDU::set_const_PSKBodyCiphertext(const PSKBodyCiphertext & d) {
    index = 15;
    data = (void *)&d;
    constant = 1;
}

const PSKBodyCiphertext *objects_PDU::get_const_PSKBodyCiphertext() const {
    if (index == 15)
	return (const PSKBodyCiphertext *)data;
    else
	return 0;
}

void objects_PDU::set_const_WR1BodyCiphertext(const WR1BodyCiphertext & d) {
    index = 16;
    data = (void *)&d;
    constant = 1;
}

const WR1BodyCiphertext *objects_PDU::get_const_WR1BodyCiphertext() const {
    if (index == 16)
	return (const WR1BodyCiphertext *)data;
    else
	return 0;
}

void objects_PDU::set_const_WR1Envelope(const WR1Envelope & d) {
    index = 17;
    data = (void *)&d;
    constant = 1;
}

const WR1Envelope *objects_PDU::get_const_WR1Envelope() const {
    if (index == 17)
	return (const WR1Envelope *)data;
    else
	return 0;
}

void objects_PDU::set_const_WR1ProverBody(const WR1ProverBody & d) {
    index = 18;
    data = (void *)&d;
    constant = 1;
}

const WR1ProverBody *objects_PDU::get_const_WR1ProverBody() const {
    if (index == 18)
	return (const WR1ProverBody *)data;
    else
	return 0;
}

void objects_PDU::set_const_WR1VerifierBody(const WR1VerifierBody & d) {
    index = 19;
    data = (void *)&d;
    constant = 1;
}

const WR1VerifierBody *objects_PDU::get_const_WR1VerifierBody() const {
    if (index == 19)
	return (const WR1VerifierBody *)data;
    else
	return 0;
}

void objects_PDU::set_const_Ed25519OuterSignature(const Ed25519OuterSignature & d) {
    index = 20;
    data = (void *)&d;
    constant = 1;
}

const Ed25519OuterSignature *objects_PDU::get_const_Ed25519OuterSignature() const {
    if (index == 20)
	return (const Ed25519OuterSignature *)data;
    else
	return 0;
}

void objects_PDU::set_const_SignedOuterKey(const SignedOuterKey & d) {
    index = 21;
    data = (void *)&d;
    constant = 1;
}

const SignedOuterKey *objects_PDU::get_const_SignedOuterKey() const {
    if (index == 21)
	return (const SignedOuterKey *)data;
    else
	return 0;
}

void objects_PDU::set_const_TrustLevel(const TrustLevel & d) {
    index = 22;
    data = (void *)&d;
    constant = 1;
}

const TrustLevel *objects_PDU::get_const_TrustLevel() const {
    if (index == 22)
	return (const TrustLevel *)data;
    else
	return 0;
}

void objects_PDU::set_const_CommitmentRevocationOption(const CommitmentRevocationOption & d) {
    index = 23;
    data = (void *)&d;
    constant = 1;
}

const CommitmentRevocationOption *objects_PDU::get_const_CommitmentRevocationOption() const {
    if (index == 23)
	return (const CommitmentRevocationOption *)data;
    else
	return 0;
}

void objects_PDU::set_const_AVKeyAES128_GCM(const AVKeyAES128_GCM & d) {
    index = 24;
    data = (void *)&d;
    constant = 1;
}

const AVKeyAES128_GCM *objects_PDU::get_const_AVKeyAES128_GCM() const {
    if (index == 24)
	return (const AVKeyAES128_GCM *)data;
    else
	return 0;
}

void objects_PDU::set_const_Private_Ed25519(const Private_Ed25519 & d) {
    index = 25;
    data = (void *)&d;
    constant = 1;
}

const Private_Ed25519 *objects_PDU::get_const_Private_Ed25519() const {
    if (index == 25)
	return (const Private_Ed25519 *)data;
    else
	return 0;
}

void objects_PDU::set_const_Private_Curve25519(const Private_Curve25519 & d) {
    index = 26;
    data = (void *)&d;
    constant = 1;
}

const Private_Curve25519 *objects_PDU::get_const_Private_Curve25519() const {
    if (index == 26)
	return (const Private_Curve25519 *)data;
    else
	return 0;
}

void objects_PDU::set_const_Private_BN256_OAQUE(const Private_BN256_OAQUE & d) {
    index = 27;
    data = (void *)&d;
    constant = 1;
}

const Private_BN256_OAQUE *objects_PDU::get_const_Private_BN256_OAQUE() const {
    if (index == 27)
	return (const Private_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Private_BN256_IBE(const Private_BN256_IBE & d) {
    index = 28;
    data = (void *)&d;
    constant = 1;
}

const Private_BN256_IBE *objects_PDU::get_const_Private_BN256_IBE() const {
    if (index == 28)
	return (const Private_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Master_BN256_OAQUE(const Master_BN256_OAQUE & d) {
    index = 29;
    data = (void *)&d;
    constant = 1;
}

const Master_BN256_OAQUE *objects_PDU::get_const_Master_BN256_OAQUE() const {
    if (index == 29)
	return (const Master_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Master_BN256_IBE(const Master_BN256_IBE & d) {
    index = 30;
    data = (void *)&d;
    constant = 1;
}

const Master_BN256_IBE *objects_PDU::get_const_Master_BN256_IBE() const {
    if (index == 30)
	return (const Master_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Public_Ed25519(const Public_Ed25519 & d) {
    index = 31;
    data = (void *)&d;
    constant = 1;
}

const Public_Ed25519 *objects_PDU::get_const_Public_Ed25519() const {
    if (index == 31)
	return (const Public_Ed25519 *)data;
    else
	return 0;
}

void objects_PDU::set_const_Public_Curve25519(const Public_Curve25519 & d) {
    index = 32;
    data = (void *)&d;
    constant = 1;
}

const Public_Curve25519 *objects_PDU::get_const_Public_Curve25519() const {
    if (index == 32)
	return (const Public_Curve25519 *)data;
    else
	return 0;
}

void objects_PDU::set_const_Public_OAQUE(const Public_OAQUE & d) {
    index = 33;
    data = (void *)&d;
    constant = 1;
}

const Public_OAQUE *objects_PDU::get_const_Public_OAQUE() const {
    if (index == 33)
	return (const Public_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Params_BN256_OAQUE(const Params_BN256_OAQUE & d) {
    index = 34;
    data = (void *)&d;
    constant = 1;
}

const Params_BN256_OAQUE *objects_PDU::get_const_Params_BN256_OAQUE() const {
    if (index == 34)
	return (const Params_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Params_BN256_IBE(const Params_BN256_IBE & d) {
    index = 35;
    data = (void *)&d;
    constant = 1;
}

const Params_BN256_IBE *objects_PDU::get_const_Params_BN256_IBE() const {
    if (index == 35)
	return (const Params_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Public_BN256_IBE(const Public_BN256_IBE & d) {
    index = 36;
    data = (void *)&d;
    constant = 1;
}

const Public_BN256_IBE *objects_PDU::get_const_Public_BN256_IBE() const {
    if (index == 36)
	return (const Public_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_const_KeyringAESCiphertext(const KeyringAESCiphertext & d) {
    index = 37;
    data = (void *)&d;
    constant = 1;
}

const KeyringAESCiphertext *objects_PDU::get_const_KeyringAESCiphertext() const {
    if (index == 37)
	return (const KeyringAESCiphertext *)data;
    else
	return 0;
}

#endif
/* Specific PDU classes */

WaveWireObject_PDU::WaveWireObject_PDU() {
}

void WaveWireObject_PDU::set_data(WaveWireObject & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveWireObject *WaveWireObject_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveWireObject *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveWireObject_PDU::set_const_data(const WaveWireObject & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveWireObject *WaveWireObject_PDU::get_const_data() const {
    return (const WaveWireObject *)data;
}

#endif

OssTypeIndex WaveWireObject_PDU::get_index() const {
    return 1;
}

WaveAttestation_PDU::WaveAttestation_PDU() {
}

void WaveAttestation_PDU::set_data(WaveAttestation & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveAttestation *WaveAttestation_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveAttestation *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveAttestation_PDU::set_const_data(const WaveAttestation & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveAttestation *WaveAttestation_PDU::get_const_data() const {
    return (const WaveAttestation *)data;
}

#endif

OssTypeIndex WaveAttestation_PDU::get_index() const {
    return 2;
}

AttestationBody_PDU::AttestationBody_PDU() {
}

void AttestationBody_PDU::set_data(AttestationBody & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttestationBody *AttestationBody_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AttestationBody *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AttestationBody_PDU::set_const_data(const AttestationBody & d) {
    data = (void *)&d;
    constant = 1;
}

const AttestationBody *AttestationBody_PDU::get_const_data() const {
    return (const AttestationBody *)data;
}

#endif

OssTypeIndex AttestationBody_PDU::get_index() const {
    return 3;
}

WaveEntity_PDU::WaveEntity_PDU() {
}

void WaveEntity_PDU::set_data(WaveEntity & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveEntity *WaveEntity_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveEntity *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveEntity_PDU::set_const_data(const WaveEntity & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveEntity *WaveEntity_PDU::get_const_data() const {
    return (const WaveEntity *)data;
}

#endif

OssTypeIndex WaveEntity_PDU::get_index() const {
    return 4;
}

WaveEntitySecret_PDU::WaveEntitySecret_PDU() {
}

void WaveEntitySecret_PDU::set_data(WaveEntitySecret & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveEntitySecret *WaveEntitySecret_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveEntitySecret *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveEntitySecret_PDU::set_const_data(const WaveEntitySecret & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveEntitySecret *WaveEntitySecret_PDU::get_const_data() const {
    return (const WaveEntitySecret *)data;
}

#endif

OssTypeIndex WaveEntitySecret_PDU::get_index() const {
    return 5;
}

EntityKeyring_PDU::EntityKeyring_PDU() {
}

void EntityKeyring_PDU::set_data(EntityKeyring & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EntityKeyring *EntityKeyring_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EntityKeyring *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EntityKeyring_PDU::set_const_data(const EntityKeyring & d) {
    data = (void *)&d;
    constant = 1;
}

const EntityKeyring *EntityKeyring_PDU::get_const_data() const {
    return (const EntityKeyring *)data;
}

#endif

OssTypeIndex EntityKeyring_PDU::get_index() const {
    return 6;
}

EntityKeyringEntry_PDU::EntityKeyringEntry_PDU() {
}

void EntityKeyringEntry_PDU::set_data(EntityKeyringEntry & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EntityKeyringEntry *EntityKeyringEntry_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EntityKeyringEntry *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EntityKeyringEntry_PDU::set_const_data(const EntityKeyringEntry & d) {
    data = (void *)&d;
    constant = 1;
}

const EntityKeyringEntry *EntityKeyringEntry_PDU::get_const_data() const {
    return (const EntityKeyringEntry *)data;
}

#endif

OssTypeIndex EntityKeyringEntry_PDU::get_index() const {
    return 7;
}

WaveExplicitProof_PDU::WaveExplicitProof_PDU() {
}

void WaveExplicitProof_PDU::set_data(WaveExplicitProof & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveExplicitProof *WaveExplicitProof_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveExplicitProof *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveExplicitProof_PDU::set_const_data(const WaveExplicitProof & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveExplicitProof *WaveExplicitProof_PDU::get_const_data() const {
    return (const WaveExplicitProof *)data;
}

#endif

OssTypeIndex WaveExplicitProof_PDU::get_index() const {
    return 8;
}

RTreePolicy_PDU::RTreePolicy_PDU() {
}

void RTreePolicy_PDU::set_data(RTreePolicy & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

RTreePolicy *RTreePolicy_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (RTreePolicy *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void RTreePolicy_PDU::set_const_data(const RTreePolicy & d) {
    data = (void *)&d;
    constant = 1;
}

const RTreePolicy *RTreePolicy_PDU::get_const_data() const {
    return (const RTreePolicy *)data;
}

#endif

OssTypeIndex RTreePolicy_PDU::get_index() const {
    return 9;
}

HashSha3_256_PDU::HashSha3_256_PDU() {
}

void HashSha3_256_PDU::set_data(HashSha3_256 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashSha3_256 *HashSha3_256_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HashSha3_256 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HashSha3_256_PDU::set_const_data(const HashSha3_256 & d) {
    data = (void *)&d;
    constant = 1;
}

const HashSha3_256 *HashSha3_256_PDU::get_const_data() const {
    return (const HashSha3_256 *)data;
}

#endif

OssTypeIndex HashSha3_256_PDU::get_index() const {
    return 10;
}

HashSha_256_PDU::HashSha_256_PDU() {
}

void HashSha_256_PDU::set_data(HashSha_256 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashSha_256 *HashSha_256_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HashSha_256 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HashSha_256_PDU::set_const_data(const HashSha_256 & d) {
    data = (void *)&d;
    constant = 1;
}

const HashSha_256 *HashSha_256_PDU::get_const_data() const {
    return (const HashSha_256 *)data;
}

#endif

OssTypeIndex HashSha_256_PDU::get_index() const {
    return 11;
}

HashKeccak_256_PDU::HashKeccak_256_PDU() {
}

void HashKeccak_256_PDU::set_data(HashKeccak_256 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashKeccak_256 *HashKeccak_256_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HashKeccak_256 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HashKeccak_256_PDU::set_const_data(const HashKeccak_256 & d) {
    data = (void *)&d;
    constant = 1;
}

const HashKeccak_256 *HashKeccak_256_PDU::get_const_data() const {
    return (const HashKeccak_256 *)data;
}

#endif

OssTypeIndex HashKeccak_256_PDU::get_index() const {
    return 12;
}

LocationURL_PDU::LocationURL_PDU() {
}

void LocationURL_PDU::set_data(LocationURL & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocationURL *LocationURL_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (LocationURL *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void LocationURL_PDU::set_const_data(const LocationURL & d) {
    data = (void *)&d;
    constant = 1;
}

const LocationURL *LocationURL_PDU::get_const_data() const {
    return (const LocationURL *)data;
}

#endif

OssTypeIndex LocationURL_PDU::get_index() const {
    return 13;
}

LocationEthereum_PDU::LocationEthereum_PDU() {
}

void LocationEthereum_PDU::set_data(LocationEthereum & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocationEthereum *LocationEthereum_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (LocationEthereum *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void LocationEthereum_PDU::set_const_data(const LocationEthereum & d) {
    data = (void *)&d;
    constant = 1;
}

const LocationEthereum *LocationEthereum_PDU::get_const_data() const {
    return (const LocationEthereum *)data;
}

#endif

OssTypeIndex LocationEthereum_PDU::get_index() const {
    return 14;
}

PSKBodyCiphertext_PDU::PSKBodyCiphertext_PDU() {
}

void PSKBodyCiphertext_PDU::set_data(PSKBodyCiphertext & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PSKBodyCiphertext *PSKBodyCiphertext_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PSKBodyCiphertext *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PSKBodyCiphertext_PDU::set_const_data(const PSKBodyCiphertext & d) {
    data = (void *)&d;
    constant = 1;
}

const PSKBodyCiphertext *PSKBodyCiphertext_PDU::get_const_data() const {
    return (const PSKBodyCiphertext *)data;
}

#endif

OssTypeIndex PSKBodyCiphertext_PDU::get_index() const {
    return 15;
}

WR1BodyCiphertext_PDU::WR1BodyCiphertext_PDU() {
}

void WR1BodyCiphertext_PDU::set_data(WR1BodyCiphertext & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1BodyCiphertext *WR1BodyCiphertext_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WR1BodyCiphertext *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WR1BodyCiphertext_PDU::set_const_data(const WR1BodyCiphertext & d) {
    data = (void *)&d;
    constant = 1;
}

const WR1BodyCiphertext *WR1BodyCiphertext_PDU::get_const_data() const {
    return (const WR1BodyCiphertext *)data;
}

#endif

OssTypeIndex WR1BodyCiphertext_PDU::get_index() const {
    return 16;
}

WR1Envelope_PDU::WR1Envelope_PDU() {
}

void WR1Envelope_PDU::set_data(WR1Envelope & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1Envelope *WR1Envelope_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WR1Envelope *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WR1Envelope_PDU::set_const_data(const WR1Envelope & d) {
    data = (void *)&d;
    constant = 1;
}

const WR1Envelope *WR1Envelope_PDU::get_const_data() const {
    return (const WR1Envelope *)data;
}

#endif

OssTypeIndex WR1Envelope_PDU::get_index() const {
    return 17;
}

WR1ProverBody_PDU::WR1ProverBody_PDU() {
}

void WR1ProverBody_PDU::set_data(WR1ProverBody & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1ProverBody *WR1ProverBody_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WR1ProverBody *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WR1ProverBody_PDU::set_const_data(const WR1ProverBody & d) {
    data = (void *)&d;
    constant = 1;
}

const WR1ProverBody *WR1ProverBody_PDU::get_const_data() const {
    return (const WR1ProverBody *)data;
}

#endif

OssTypeIndex WR1ProverBody_PDU::get_index() const {
    return 18;
}

WR1VerifierBody_PDU::WR1VerifierBody_PDU() {
}

void WR1VerifierBody_PDU::set_data(WR1VerifierBody & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1VerifierBody *WR1VerifierBody_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WR1VerifierBody *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WR1VerifierBody_PDU::set_const_data(const WR1VerifierBody & d) {
    data = (void *)&d;
    constant = 1;
}

const WR1VerifierBody *WR1VerifierBody_PDU::get_const_data() const {
    return (const WR1VerifierBody *)data;
}

#endif

OssTypeIndex WR1VerifierBody_PDU::get_index() const {
    return 19;
}

Ed25519OuterSignature_PDU::Ed25519OuterSignature_PDU() {
}

void Ed25519OuterSignature_PDU::set_data(Ed25519OuterSignature & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Ed25519OuterSignature *Ed25519OuterSignature_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Ed25519OuterSignature *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Ed25519OuterSignature_PDU::set_const_data(const Ed25519OuterSignature & d) {
    data = (void *)&d;
    constant = 1;
}

const Ed25519OuterSignature *Ed25519OuterSignature_PDU::get_const_data() const {
    return (const Ed25519OuterSignature *)data;
}

#endif

OssTypeIndex Ed25519OuterSignature_PDU::get_index() const {
    return 20;
}

SignedOuterKey_PDU::SignedOuterKey_PDU() {
}

void SignedOuterKey_PDU::set_data(SignedOuterKey & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SignedOuterKey *SignedOuterKey_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SignedOuterKey *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SignedOuterKey_PDU::set_const_data(const SignedOuterKey & d) {
    data = (void *)&d;
    constant = 1;
}

const SignedOuterKey *SignedOuterKey_PDU::get_const_data() const {
    return (const SignedOuterKey *)data;
}

#endif

OssTypeIndex SignedOuterKey_PDU::get_index() const {
    return 21;
}

TrustLevel_PDU::TrustLevel_PDU() {
}

void TrustLevel_PDU::set_data(TrustLevel & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TrustLevel *TrustLevel_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TrustLevel *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TrustLevel_PDU::set_const_data(const TrustLevel & d) {
    data = (void *)&d;
    constant = 1;
}

const TrustLevel *TrustLevel_PDU::get_const_data() const {
    return (const TrustLevel *)data;
}

#endif

OssTypeIndex TrustLevel_PDU::get_index() const {
    return 22;
}

CommitmentRevocationOption_PDU::CommitmentRevocationOption_PDU() {
}

void CommitmentRevocationOption_PDU::set_data(CommitmentRevocationOption & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommitmentRevocationOption *CommitmentRevocationOption_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CommitmentRevocationOption *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CommitmentRevocationOption_PDU::set_const_data(const CommitmentRevocationOption & d) {
    data = (void *)&d;
    constant = 1;
}

const CommitmentRevocationOption *CommitmentRevocationOption_PDU::get_const_data() const {
    return (const CommitmentRevocationOption *)data;
}

#endif

OssTypeIndex CommitmentRevocationOption_PDU::get_index() const {
    return 23;
}

AVKeyAES128_GCM_PDU::AVKeyAES128_GCM_PDU() {
}

void AVKeyAES128_GCM_PDU::set_data(AVKeyAES128_GCM & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AVKeyAES128_GCM *AVKeyAES128_GCM_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AVKeyAES128_GCM *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AVKeyAES128_GCM_PDU::set_const_data(const AVKeyAES128_GCM & d) {
    data = (void *)&d;
    constant = 1;
}

const AVKeyAES128_GCM *AVKeyAES128_GCM_PDU::get_const_data() const {
    return (const AVKeyAES128_GCM *)data;
}

#endif

OssTypeIndex AVKeyAES128_GCM_PDU::get_index() const {
    return 24;
}

Private_Ed25519_PDU::Private_Ed25519_PDU() {
}

void Private_Ed25519_PDU::set_data(Private_Ed25519 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_Ed25519 *Private_Ed25519_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Private_Ed25519 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Private_Ed25519_PDU::set_const_data(const Private_Ed25519 & d) {
    data = (void *)&d;
    constant = 1;
}

const Private_Ed25519 *Private_Ed25519_PDU::get_const_data() const {
    return (const Private_Ed25519 *)data;
}

#endif

OssTypeIndex Private_Ed25519_PDU::get_index() const {
    return 25;
}

Private_Curve25519_PDU::Private_Curve25519_PDU() {
}

void Private_Curve25519_PDU::set_data(Private_Curve25519 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_Curve25519 *Private_Curve25519_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Private_Curve25519 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Private_Curve25519_PDU::set_const_data(const Private_Curve25519 & d) {
    data = (void *)&d;
    constant = 1;
}

const Private_Curve25519 *Private_Curve25519_PDU::get_const_data() const {
    return (const Private_Curve25519 *)data;
}

#endif

OssTypeIndex Private_Curve25519_PDU::get_index() const {
    return 26;
}

Private_BN256_OAQUE_PDU::Private_BN256_OAQUE_PDU() {
}

void Private_BN256_OAQUE_PDU::set_data(Private_BN256_OAQUE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_BN256_OAQUE *Private_BN256_OAQUE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Private_BN256_OAQUE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Private_BN256_OAQUE_PDU::set_const_data(const Private_BN256_OAQUE & d) {
    data = (void *)&d;
    constant = 1;
}

const Private_BN256_OAQUE *Private_BN256_OAQUE_PDU::get_const_data() const {
    return (const Private_BN256_OAQUE *)data;
}

#endif

OssTypeIndex Private_BN256_OAQUE_PDU::get_index() const {
    return 27;
}

Private_BN256_IBE_PDU::Private_BN256_IBE_PDU() {
}

void Private_BN256_IBE_PDU::set_data(Private_BN256_IBE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_BN256_IBE *Private_BN256_IBE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Private_BN256_IBE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Private_BN256_IBE_PDU::set_const_data(const Private_BN256_IBE & d) {
    data = (void *)&d;
    constant = 1;
}

const Private_BN256_IBE *Private_BN256_IBE_PDU::get_const_data() const {
    return (const Private_BN256_IBE *)data;
}

#endif

OssTypeIndex Private_BN256_IBE_PDU::get_index() const {
    return 28;
}

Master_BN256_OAQUE_PDU::Master_BN256_OAQUE_PDU() {
}

void Master_BN256_OAQUE_PDU::set_data(Master_BN256_OAQUE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Master_BN256_OAQUE *Master_BN256_OAQUE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Master_BN256_OAQUE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Master_BN256_OAQUE_PDU::set_const_data(const Master_BN256_OAQUE & d) {
    data = (void *)&d;
    constant = 1;
}

const Master_BN256_OAQUE *Master_BN256_OAQUE_PDU::get_const_data() const {
    return (const Master_BN256_OAQUE *)data;
}

#endif

OssTypeIndex Master_BN256_OAQUE_PDU::get_index() const {
    return 29;
}

Master_BN256_IBE_PDU::Master_BN256_IBE_PDU() {
}

void Master_BN256_IBE_PDU::set_data(Master_BN256_IBE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Master_BN256_IBE *Master_BN256_IBE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Master_BN256_IBE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Master_BN256_IBE_PDU::set_const_data(const Master_BN256_IBE & d) {
    data = (void *)&d;
    constant = 1;
}

const Master_BN256_IBE *Master_BN256_IBE_PDU::get_const_data() const {
    return (const Master_BN256_IBE *)data;
}

#endif

OssTypeIndex Master_BN256_IBE_PDU::get_index() const {
    return 30;
}

Public_Ed25519_PDU::Public_Ed25519_PDU() {
}

void Public_Ed25519_PDU::set_data(Public_Ed25519 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_Ed25519 *Public_Ed25519_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Public_Ed25519 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Public_Ed25519_PDU::set_const_data(const Public_Ed25519 & d) {
    data = (void *)&d;
    constant = 1;
}

const Public_Ed25519 *Public_Ed25519_PDU::get_const_data() const {
    return (const Public_Ed25519 *)data;
}

#endif

OssTypeIndex Public_Ed25519_PDU::get_index() const {
    return 31;
}

Public_Curve25519_PDU::Public_Curve25519_PDU() {
}

void Public_Curve25519_PDU::set_data(Public_Curve25519 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_Curve25519 *Public_Curve25519_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Public_Curve25519 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Public_Curve25519_PDU::set_const_data(const Public_Curve25519 & d) {
    data = (void *)&d;
    constant = 1;
}

const Public_Curve25519 *Public_Curve25519_PDU::get_const_data() const {
    return (const Public_Curve25519 *)data;
}

#endif

OssTypeIndex Public_Curve25519_PDU::get_index() const {
    return 32;
}

Public_OAQUE_PDU::Public_OAQUE_PDU() {
}

void Public_OAQUE_PDU::set_data(Public_OAQUE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_OAQUE *Public_OAQUE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Public_OAQUE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Public_OAQUE_PDU::set_const_data(const Public_OAQUE & d) {
    data = (void *)&d;
    constant = 1;
}

const Public_OAQUE *Public_OAQUE_PDU::get_const_data() const {
    return (const Public_OAQUE *)data;
}

#endif

OssTypeIndex Public_OAQUE_PDU::get_index() const {
    return 33;
}

Params_BN256_OAQUE_PDU::Params_BN256_OAQUE_PDU() {
}

void Params_BN256_OAQUE_PDU::set_data(Params_BN256_OAQUE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Params_BN256_OAQUE *Params_BN256_OAQUE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Params_BN256_OAQUE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Params_BN256_OAQUE_PDU::set_const_data(const Params_BN256_OAQUE & d) {
    data = (void *)&d;
    constant = 1;
}

const Params_BN256_OAQUE *Params_BN256_OAQUE_PDU::get_const_data() const {
    return (const Params_BN256_OAQUE *)data;
}

#endif

OssTypeIndex Params_BN256_OAQUE_PDU::get_index() const {
    return 34;
}

Params_BN256_IBE_PDU::Params_BN256_IBE_PDU() {
}

void Params_BN256_IBE_PDU::set_data(Params_BN256_IBE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Params_BN256_IBE *Params_BN256_IBE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Params_BN256_IBE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Params_BN256_IBE_PDU::set_const_data(const Params_BN256_IBE & d) {
    data = (void *)&d;
    constant = 1;
}

const Params_BN256_IBE *Params_BN256_IBE_PDU::get_const_data() const {
    return (const Params_BN256_IBE *)data;
}

#endif

OssTypeIndex Params_BN256_IBE_PDU::get_index() const {
    return 35;
}

Public_BN256_IBE_PDU::Public_BN256_IBE_PDU() {
}

void Public_BN256_IBE_PDU::set_data(Public_BN256_IBE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_BN256_IBE *Public_BN256_IBE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Public_BN256_IBE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Public_BN256_IBE_PDU::set_const_data(const Public_BN256_IBE & d) {
    data = (void *)&d;
    constant = 1;
}

const Public_BN256_IBE *Public_BN256_IBE_PDU::get_const_data() const {
    return (const Public_BN256_IBE *)data;
}

#endif

OssTypeIndex Public_BN256_IBE_PDU::get_index() const {
    return 36;
}

KeyringAESCiphertext_PDU::KeyringAESCiphertext_PDU() {
}

void KeyringAESCiphertext_PDU::set_data(KeyringAESCiphertext & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KeyringAESCiphertext *KeyringAESCiphertext_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KeyringAESCiphertext *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KeyringAESCiphertext_PDU::set_const_data(const KeyringAESCiphertext & d) {
    data = (void *)&d;
    constant = 1;
}

const KeyringAESCiphertext *KeyringAESCiphertext_PDU::get_const_data() const {
    return (const KeyringAESCiphertext *)data;
}

#endif

OssTypeIndex KeyringAESCiphertext_PDU::get_index() const {
    return 37;
}

/* Control object class */

objects_Control::objects_Control() : OssControl(&objects_Table, objects_TableType::internal) {
}

objects_Control::objects_Control(const objects_Control & that) : OssControl(that) {
}


/* ASN.1 data initialization */
static unsigned char _v1[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55 };
static OSSC::COssEncOID _v0 = {
    8,
    _v1
};

const OssEncOID& wave_id = (const OssEncOID&)_v0;

static unsigned char _v3[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02 };
static OSSC::COssEncOID _v2 = {
    9,
    _v3
};

const OssEncOID& wave_object = (const OssEncOID&)_v2;

static unsigned char _v5[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x01 };
static OSSC::COssEncOID _v4 = {
    10,
    _v5
};

const OssEncOID& attestation_id = (const OssEncOID&)_v4;

static unsigned char _v7[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x02 };
static OSSC::COssEncOID _v6 = {
    10,
    _v7
};

const OssEncOID& entity_id = (const OssEncOID&)_v6;

static unsigned char _v9[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x03 };
static OSSC::COssEncOID _v8 = {
    10,
    _v9
};

const OssEncOID& explicit_proof_id = (const OssEncOID&)_v8;

static unsigned char _v11[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x04 };
static OSSC::COssEncOID _v10 = {
    10,
    _v11
};

const OssEncOID& entity_secret_id = (const OssEncOID&)_v10;

static unsigned char _v13[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03 };
static OSSC::COssEncOID _v12 = {
    9,
    _v13
};

const OssEncOID& attestation_body_scheme = (const OssEncOID&)_v12;

static unsigned char _v15[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x01 };
static OSSC::COssEncOID _v14 = {
    10,
    _v15
};

const OssEncOID& unencrypted_body_scheme = (const OssEncOID&)_v14;

static unsigned char _v17[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x02 };
static OSSC::COssEncOID _v16 = {
    10,
    _v17
};

const OssEncOID& wr1_body_scheme_v1 = (const OssEncOID&)_v16;

static unsigned char _v19[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x03 };
static OSSC::COssEncOID _v18 = {
    10,
    _v19
};

const OssEncOID& psk_body_scheme = (const OssEncOID&)_v18;

static unsigned char _v21[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x04 };
static OSSC::COssEncOID _v20 = {
    9,
    _v21
};

const OssEncOID& attestation_verifier_key_scheme = (const OssEncOID&)_v20;

static unsigned char _v23[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x04, 0x01 };
static OSSC::COssEncOID _v22 = {
    10,
    _v23
};

const OssEncOID& attestation_verifier_key_aes128_gcm = (const OssEncOID&)_v22;

static unsigned char _v25[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x05 };
static OSSC::COssEncOID _v24 = {
    9,
    _v25
};

const OssEncOID& outer_signature_scheme = (const OssEncOID&)_v24;

static unsigned char _v27[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x05, 0x01 };
static OSSC::COssEncOID _v26 = {
    10,
    _v27
};

const OssEncOID& ephemeral_ed25519 = (const OssEncOID&)_v26;

static unsigned char _v29[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x06 };
static OSSC::COssEncOID _v28 = {
    9,
    _v29
};

const OssEncOID& outer_signature_binding_scheme = (const OssEncOID&)_v28;

static unsigned char _v31[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x06, 0x01 };
static OSSC::COssEncOID _v30 = {
    10,
    _v31
};

const OssEncOID& signed_outer_key = (const OssEncOID&)_v30;

static unsigned char _v33[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x07 };
static OSSC::COssEncOID _v32 = {
    9,
    _v33
};

const OssEncOID& revocation_check_schemes = (const OssEncOID&)_v32;

static unsigned char _v35[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x08 };
static OSSC::COssEncOID _v34 = {
    9,
    _v35
};

const OssEncOID& location_scheme = (const OssEncOID&)_v34;

static unsigned char _v37[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x08, 0x01 };
static OSSC::COssEncOID _v36 = {
    10,
    _v37
};

const OssEncOID& location_url_id = (const OssEncOID&)_v36;

static unsigned char _v39[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x08, 0x02 };
static OSSC::COssEncOID _v38 = {
    10,
    _v39
};

const OssEncOID& location_ethereum_v1_id = (const OssEncOID&)_v38;

static unsigned char _v41[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09 };
static OSSC::COssEncOID _v40 = {
    9,
    _v41
};

const OssEncOID& hash_scheme = (const OssEncOID&)_v40;

static unsigned char _v43[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x01 };
static OSSC::COssEncOID _v42 = {
    10,
    _v43
};

const OssEncOID& sha3_256_id = (const OssEncOID&)_v42;

static unsigned char _v45[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x02 };
static OSSC::COssEncOID _v44 = {
    10,
    _v45
};

const OssEncOID& keccak_256_id = (const OssEncOID&)_v44;

static unsigned char _v47[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x03 };
static OSSC::COssEncOID _v46 = {
    10,
    _v47
};

const OssEncOID& sha_256_id = (const OssEncOID&)_v46;

static unsigned char _v49[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0A };
static OSSC::COssEncOID _v48 = {
    9,
    _v49
};

const OssEncOID& revocation_scheme = (const OssEncOID&)_v48;

static unsigned char _v51[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0A, 0x01 };
static OSSC::COssEncOID _v50 = {
    10,
    _v51
};

const OssEncOID& commitment_revocation_id = (const OssEncOID&)_v50;

static unsigned char _v53[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B };
static OSSC::COssEncOID _v52 = {
    9,
    _v53
};

const OssEncOID& entity_key_scheme = (const OssEncOID&)_v52;

static unsigned char _v55[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x01 };
static OSSC::COssEncOID _v54 = {
    10,
    _v55
};

const OssEncOID& ed25519_id = (const OssEncOID&)_v54;

static unsigned char _v57[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x02 };
static OSSC::COssEncOID _v56 = {
    10,
    _v57
};

const OssEncOID& curve25519_id = (const OssEncOID&)_v56;

static unsigned char _v59[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x03 };
static OSSC::COssEncOID _v58 = {
    10,
    _v59
};

const OssEncOID& oaque_bn256_s20_attributeset_id = (const OssEncOID&)_v58;

static unsigned char _v61[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x04 };
static OSSC::COssEncOID _v60 = {
    10,
    _v61
};

const OssEncOID& oaque_bn256_s20_params_id = (const OssEncOID&)_v60;

static unsigned char _v63[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x05 };
static OSSC::COssEncOID _v62 = {
    10,
    _v63
};

const OssEncOID& ibe_bn256_params_id = (const OssEncOID&)_v62;

static unsigned char _v65[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x06 };
static OSSC::COssEncOID _v64 = {
    10,
    _v65
};

const OssEncOID& ibe_bn256_public_id = (const OssEncOID&)_v64;

static unsigned char _v67[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0C };
static OSSC::COssEncOID _v66 = {
    9,
    _v67
};

const OssEncOID& policy_scheme = (const OssEncOID&)_v66;

static unsigned char _v69[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0C, 0x01 };
static OSSC::COssEncOID _v68 = {
    10,
    _v69
};

const OssEncOID& trust_level = (const OssEncOID&)_v68;

static unsigned char _v71[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0C, 0x02 };
static OSSC::COssEncOID _v70 = {
    10,
    _v71
};

const OssEncOID& resource_tree = (const OssEncOID&)_v70;

static unsigned char _v73[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D };
static OSSC::COssEncOID _v72 = {
    9,
    _v73
};

const OssEncOID& policy_addendum_scheme = (const OssEncOID&)_v72;

static unsigned char _v75[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x01 };
static OSSC::COssEncOID _v74 = {
    10,
    _v75
};

const OssEncOID& wr1_domain_visibility_key = (const OssEncOID&)_v74;

static unsigned char _v77[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x02 };
static OSSC::COssEncOID _v76 = {
    10,
    _v77
};

const OssEncOID& wr1_partition_key = (const OssEncOID&)_v76;

static unsigned char _v79[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x03 };
static OSSC::COssEncOID _v78 = {
    10,
    _v79
};

const OssEncOID& wr1_oaque_encryption_key = (const OssEncOID&)_v78;

static unsigned char _v81[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E };
static OSSC::COssEncOID _v80 = {
    9,
    _v81
};

const OssEncOID& entity_secret_key_scheme = (const OssEncOID&)_v80;

static unsigned char _v83[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x01 };
static OSSC::COssEncOID _v82 = {
    10,
    _v83
};

const OssEncOID& ed25519_secret_id = (const OssEncOID&)_v82;

static unsigned char _v85[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x02 };
static OSSC::COssEncOID _v84 = {
    10,
    _v85
};

const OssEncOID& curve25519_secret_id = (const OssEncOID&)_v84;

static unsigned char _v87[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x03 };
static OSSC::COssEncOID _v86 = {
    10,
    _v87
};

const OssEncOID& oaque_bn256_s20_private_key_id = (const OssEncOID&)_v86;

static unsigned char _v89[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x04 };
static OSSC::COssEncOID _v88 = {
    10,
    _v89
};

const OssEncOID& oaque_bn256_s20_master_key_id = (const OssEncOID&)_v88;

static unsigned char _v91[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x05 };
static OSSC::COssEncOID _v90 = {
    10,
    _v91
};

const OssEncOID& bn256_ibe_master_key_id = (const OssEncOID&)_v90;

static unsigned char _v93[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x06 };
static OSSC::COssEncOID _v92 = {
    10,
    _v93
};

const OssEncOID& bn256_ibe_private_key_id = (const OssEncOID&)_v92;

static unsigned char _v95[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0F };
static OSSC::COssEncOID _v94 = {
    9,
    _v95
};

const OssEncOID& entity_keyring_scheme = (const OssEncOID&)_v94;

static unsigned char _v97[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0F, 0x01 };
static OSSC::COssEncOID _v96 = {
    10,
    _v97
};

const OssEncOID& plaintext_keyring_id = (const OssEncOID&)_v96;

static unsigned char _v99[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0F, 0x02 };
static OSSC::COssEncOID _v98 = {
    10,
    _v99
};

const OssEncOID& aes128_gcm_pbkdf2 = (const OssEncOID&)_v98;


struct _TYPE_IDENTIFIER {
    OSSC::COssEncOID id;
    unsigned short Type;
};
/* Local control table initialization */

extern "C" void _oss_run_TOED_on_AMD64_LINUX_64_BIT(void);

extern "C" {
static void _oss_post_init(struct ossGlobal *world);

/* TOED internal function declarations */

#ifdef OSS_COPY_VALUE
static int _CPWAVE_Schema(struct ossGlobal * _g, int pduNum, void * src, void ** pdst);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _CMWAVE_Schema(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata);
#endif /* OSS_COMPARE_VALUE */

#ifdef OSS_NO_DETAIL_MM_ERROR_CODES
static void _oeWAVE_Schema(OssGlobal * _g, int _pdunum, void * _inbuf);
static void * _odWAVE_Schema(OssGlobal * _g, int _pdunum);
#endif
#if OSS_TOED_API_LEVEL >= 34
static void _jeWAVE_Schema(OssGlobal * _g, int _pdunum, void * _inbuf);
static void * _jdWAVE_Schema(OssGlobal * _g, int _pdunum);
#endif
static const _oss_xapi_entries_struct _oss_xapi_entries = {
     OSS_COMPILER_API_LEVEL
#ifdef OSS_COPY_VALUE
    ,_CPWAVE_Schema
#else
    ,NULL
#endif
#ifdef OSS_COMPARE_VALUE
    ,_CMWAVE_Schema
#else
    ,NULL
#endif
    ,NULL
    ,NULL
    ,102
    ,NULL
    ,NULL
#if OSS_TOED_API_LEVEL >= 24
    ,NULL
    ,NULL
    ,100
#endif
#ifdef OSS_NO_DETAIL_MM_ERROR_CODES
    ,100
    ,_oeWAVE_Schema
    ,_odWAVE_Schema
#endif
#if OSS_TOED_API_LEVEL >= 34
    ,100
    ,_jeWAVE_Schema
    ,_jdWAVE_Schema
#endif
};

/* Local control table initialization */

static unsigned char _privateFlags[] = {0x09,0x00,0x00};
extern "C" void _ossinit_objects(struct ossGlobal *world) {
    _EncDecGlobals *_oss_c;

    _oss_run_TOED_on_AMD64_LINUX_64_BIT();
    ossPrivateSetMoreFlags(world, 17, _privateFlags);
    ossLinkBer(world);
    if (world) {
        _oss_c = (_EncDecGlobals *)world->encDecVar;
        _oss_c->der = 1;
    }
    ossSetEncodingRules(world, OSS_DER);
    ossInitXAPIentries(world, &_oss_xapi_entries);
    _oss_post_init(world);
}

/* TOED internal function declarations */


struct _WaveWireObject {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _Hash {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _Location {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _seq1 {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _RevocationOption {
    ossBoolean  critical;
    _seq1  scheme;
};

struct _seqof1 {
    struct _seqof1 * next;
    _RevocationOption  value;
};

struct _Extension {
    OSSC::COssEncOID  extnID;
    ossBoolean  critical;
    OSSC::COssString  value;
};

struct _seqof2 {
    struct _seqof2 * next;
    _Extension  value;
};

struct _seq2 {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _seq3 {
    _Hash  subject;
    _Location  subjectLocation;
    _seqof1 * revocations;
    _seqof2 * publicExtensions;
    _seq2  body;
};

struct _seq4 {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _WaveAttestation {
    _seq3  tbs;
    _seq4  outerSignature;
};

struct _seq5 {
    char *  notBefore;
    char *  notAfter;
};

struct _seq6 {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _seq7 {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _AttestationVerifierBody {
    _Hash  attester;
    _Location  attesterLocation;
    _seq5  validity;
    _seq6  policy;
    _seqof2 * extensions;
    _seq7  outerSignatureBinding;
};

struct _PolicyAddendum {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _seqof3 {
    struct _seqof3 * next;
    _PolicyAddendum  value;
};

struct _AttestationBody {
    _AttestationVerifierBody  verifierBody;
    _seqof3 * proverPolicyAddendums;
    _seqof2 * proverExtensions;
};

struct _setof1 {
    struct _setof1 * next;
    OSS_INT32  value;
};

struct _seq8 {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _EntityPublicKey {
    _setof1 * capabilityFlags;
    _seq8  key;
};

struct _seqof4 {
    struct _seqof4 * next;
    _EntityPublicKey  value;
};

struct _seq9 {
    _EntityPublicKey  verifyingKey;
    _seqof4 * keys;
    _seq5  validity;
    _seqof1 * revocations;
    _seqof2 * extensions;
};

struct _WaveEntity {
    _seq9  tbs;
    OSSC::COssString  signature;
};
static long _edWaveEntity(OssGlobal * _g, char ** _out_pos, long * _max_len, _WaveEntity * _in_data);
static void _d_WaveEntity(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _WaveEntity * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_WaveEntity(OssGlobal * _g, _WaveEntity * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_WaveEntity(OssGlobal * _g, _WaveEntity * _data_ptr);
#endif

struct _seq10 {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _WaveEntitySecret {
    _WaveEntity  entity;
    _seq10  keyring;
};

struct _EntityPrivateKey {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _EntityKeyringEntry {
    _EntityPublicKey  EntityKeyringEntry_public;
    _EntityPrivateKey  secret;
};

struct _seqof5 {
    struct _seqof5 * next;
    _EntityKeyringEntry  value;
};

struct _EntityKeyring {
    _seqof5 * keys;
};
static long _edEntityKeyringEntry(OssGlobal * _g, char ** _out_pos, long * _max_len, _EntityKeyringEntry * _in_data);
static void _d_EntityKeyringEntry(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EntityKeyringEntry * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_EntityKeyringEntry(OssGlobal * _g, _EntityKeyringEntry * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_EntityKeyringEntry(OssGlobal * _g, _EntityKeyringEntry * _data_ptr);
#endif

struct _seqof6 {
    struct _seqof6 * next;
    _Location  value;
};

struct _AttestationVerifierKey {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _seqof7 {
    struct _seqof7 * next;
    _AttestationVerifierKey  value;
};

struct _RevocationCheck {
    OSSC::COssEncOID  type_id;
    OSSC::COssConstrainedOpenType  value;
};

struct _seqof8 {
    struct _seqof8 * next;
    _RevocationCheck  value;
};

struct _AttestationReference {
    OSS_UINT32 bit_mask;
    _Hash  hash;
    OSSC::COssString  content;
    _seqof6 * location;
    _seqof7 * keys;
    _seqof8 * revocationChecks;
    _seqof2 * extensions;
};

struct _seqof11 {
    struct _seqof11 * next;
    _AttestationReference  value;
};

struct _seqof12 {
    struct _seqof12 * next;
    _setof1 * value;
};

struct _seqof14 {
    struct _seqof14 * next;
    OSSC::COssString  value;
};

struct _WaveExplicitProof {
    _seqof11 * attestations;
    _seqof12 * paths;
    _seqof14 * entities;
    _seqof2 * extensions;
};

struct _RTreeStatement {
    OSS_UINT32 bit_mask;
    _Hash  permissionSet;
    _seqof14 * permissions;
    OSSC::COssString  resource;
    OSSC::COssString  comment;
};

struct _seqof15 {
    struct _seqof15 * next;
    _RTreeStatement  value;
};

struct _RTreePolicy {
    _Hash  RTreePolicy_namespace;
    OSS_INT32  indirections;
    _seqof15 * statements;
};

struct _LocationURL {
    OSSC::COssString  value;
    OSS_INT32  apiVersion;
};

struct _LocationEthereum {
    OSS_INT32  chainID;
    OSS_INT32  contractAddress;
};

struct _PSKBodyCiphertext {
    OSSC::COssString  attestationBodyCiphertext;
    _EntityPublicKey  encryptedUnder;
};

struct _WR1BodyCiphertext {
    OSSC::COssString  verifierBodyCiphertext;
    OSSC::COssString  proverBodyCiphertext;
    OSSC::COssString  envelopeCiphertext;
    OSSC::COssString  envelopeKey_ibe_bn256;
    OSSC::COssString  envelopeKey_curve25519;
};

struct _WR1Envelope {
    OSSC::COssString  bodyKeys_oaque;
    _seqof14 * partition;
};

struct _WR1ProverBody {
    _seqof3 * addendums;
    _seqof2 * extensions;
};

struct _WR1VerifierBody {
    _AttestationVerifierBody  attestationVerifierBody;
};

struct _Ed25519OuterSignature {
    OSSC::COssString  verifyingKey;
    OSSC::COssString  signature;
};

struct _seq11 {
    OSSC::COssEncOID  outerSignatureScheme;
    OSSC::COssString  verifyingKey;
};

struct _SignedOuterKey {
    _seq11  tbs;
    OSSC::COssString  signature;
};

struct _TrustLevel {
    OSS_UINT32  trust;
};

struct _CommitmentRevocationOption {
    _Hash  hash;
    _Location  location;
};

struct _Public_OAQUE {
    OSSC::COssString  params;
    _seqof14 * attributeset;
};

struct _Public_BN256_IBE {
    OSSC::COssString  params;
    OSSC::COssString  id;
};

struct _KeyringAESCiphertext {
    OSSC::COssString  ciphertext;
    OSSC::COssString  salt;
    OSS_INT32  iterations;
};
static long _edHash(OssGlobal * _g, char ** _out_pos, long * _max_len, _Hash * _in_data);
static void _d_Hash(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Hash * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Hash(OssGlobal * _g, _Hash * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Hash(OssGlobal * _g, _Hash * _data_ptr);
#endif
static long _edLocation(OssGlobal * _g, char ** _out_pos, long * _max_len, _Location * _in_data);
static void _d_Location(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Location * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Location(OssGlobal * _g, _Location * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Location(OssGlobal * _g, _Location * _data_ptr);
#endif
static long _edExtension(OssGlobal * _g, char ** _out_pos, long * _max_len, _Extension * _in_data);
static void _d_Extension(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Extension * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_Extension(OssGlobal * _g, _Extension * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_Extension(OssGlobal * _g, _Extension * _data_ptr);
#endif
static long _ed_seqof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof1 ** _in_data);
static void _d__seqof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof1 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr);
#endif
static long _ed_seqof2(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof2 ** _in_data);
static void _d__seqof2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof2 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof2(OssGlobal * _g, _seqof2 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof2(OssGlobal * _g, _seqof2 ** _data_ptr);
#endif
static long _ed_seq5(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq5 * _in_data);
static void _d__seq5(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq5 * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seq5(OssGlobal * _g, _seq5 * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seq5(OssGlobal * _g, _seq5 * _data_ptr);
#endif
static long _edAttestationVerifierBody(OssGlobal * _g, char ** _out_pos, long * _max_len, _AttestationVerifierBody * _in_data);
static void _d_AttestationVerifierBody(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AttestationVerifierBody * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_AttestationVerifierBody(OssGlobal * _g, _AttestationVerifierBody * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_AttestationVerifierBody(OssGlobal * _g, _AttestationVerifierBody * _data_ptr);
#endif
static long _ed_seqof3(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof3 ** _in_data);
static void _d__seqof3(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof3 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof3(OssGlobal * _g, _seqof3 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof3(OssGlobal * _g, _seqof3 ** _data_ptr);
#endif
static long _edEntityPublicKey(OssGlobal * _g, char ** _out_pos, long * _max_len, _EntityPublicKey * _in_data);
static void _d_EntityPublicKey(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EntityPublicKey * _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f_EntityPublicKey(OssGlobal * _g, _EntityPublicKey * _data_ptr);
#endif
#ifdef OSSPRINT
static void _p_EntityPublicKey(OssGlobal * _g, _EntityPublicKey * _data_ptr);
#endif
static long _ed_seqof13(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof14 ** _in_data);
static void _d__seqof13(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof14 ** _out_data);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _f__seqof13(OssGlobal * _g, _seqof14 ** _data_ptr);
#endif
#ifdef OSSPRINT
static void _p__seqof13(OssGlobal * _g, _seqof14 ** _data_ptr);
#endif
static void _eWaveWireObject(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWaveWireObject(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWaveWireObject(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWaveWireObject(OssGlobal * _g, void * _data);
#endif
static void _eWaveAttestation(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWaveAttestation(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWaveAttestation(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWaveAttestation(OssGlobal * _g, void * _data);
#endif
static void _eAttestationBody(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAttestationBody(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAttestationBody(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAttestationBody(OssGlobal * _g, void * _data);
#endif
static void _eWaveEntity(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWaveEntity(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWaveEntity(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWaveEntity(OssGlobal * _g, void * _data);
#endif
static void _eWaveEntitySecret(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWaveEntitySecret(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWaveEntitySecret(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWaveEntitySecret(OssGlobal * _g, void * _data);
#endif
static void _eEntityKeyring(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEntityKeyring(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEntityKeyring(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEntityKeyring(OssGlobal * _g, void * _data);
#endif
static void _eEntityKeyringEntry(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEntityKeyringEntry(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEntityKeyringEntry(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEntityKeyringEntry(OssGlobal * _g, void * _data);
#endif
static void _eWaveExplicitProof(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWaveExplicitProof(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWaveExplicitProof(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWaveExplicitProof(OssGlobal * _g, void * _data);
#endif
static void _eRTreePolicy(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dRTreePolicy(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fRTreePolicy(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pRTreePolicy(OssGlobal * _g, void * _data);
#endif
static void _eHashSha3_256(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dHashSha3_256(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fHashSha3_256(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pHashSha3_256(OssGlobal * _g, void * _data);
#endif
static void _eHashSha_256(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dHashSha_256(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fHashSha_256(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pHashSha_256(OssGlobal * _g, void * _data);
#endif
static void _eHashKeccak_256(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dHashKeccak_256(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fHashKeccak_256(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pHashKeccak_256(OssGlobal * _g, void * _data);
#endif
static void _eLocationURL(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dLocationURL(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fLocationURL(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pLocationURL(OssGlobal * _g, void * _data);
#endif
static void _eLocationEthereum(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dLocationEthereum(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fLocationEthereum(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pLocationEthereum(OssGlobal * _g, void * _data);
#endif
static void _ePSKBodyCiphertext(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPSKBodyCiphertext(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPSKBodyCiphertext(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPSKBodyCiphertext(OssGlobal * _g, void * _data);
#endif
static void _eWR1BodyCiphertext(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWR1BodyCiphertext(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWR1BodyCiphertext(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWR1BodyCiphertext(OssGlobal * _g, void * _data);
#endif
static void _eWR1Envelope(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWR1Envelope(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWR1Envelope(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWR1Envelope(OssGlobal * _g, void * _data);
#endif
static void _eWR1ProverBody(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWR1ProverBody(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWR1ProverBody(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWR1ProverBody(OssGlobal * _g, void * _data);
#endif
static void _eWR1VerifierBody(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dWR1VerifierBody(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fWR1VerifierBody(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pWR1VerifierBody(OssGlobal * _g, void * _data);
#endif
static void _eEd25519OuterSignature(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dEd25519OuterSignature(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fEd25519OuterSignature(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pEd25519OuterSignature(OssGlobal * _g, void * _data);
#endif
static void _eSignedOuterKey(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dSignedOuterKey(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fSignedOuterKey(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pSignedOuterKey(OssGlobal * _g, void * _data);
#endif
static void _eTrustLevel(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dTrustLevel(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fTrustLevel(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pTrustLevel(OssGlobal * _g, void * _data);
#endif
static void _eCommitmentRevocationOption(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dCommitmentRevocationOption(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fCommitmentRevocationOption(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pCommitmentRevocationOption(OssGlobal * _g, void * _data);
#endif
static void _eAVKeyAES128_GCM(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dAVKeyAES128_GCM(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAVKeyAES128_GCM(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAVKeyAES128_GCM(OssGlobal * _g, void * _data);
#endif
static void _ePrivate_Ed25519(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPrivate_Ed25519(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPrivate_Ed25519(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPrivate_Ed25519(OssGlobal * _g, void * _data);
#endif
static void _ePrivate_Curve25519(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPrivate_Curve25519(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPrivate_Curve25519(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPrivate_Curve25519(OssGlobal * _g, void * _data);
#endif
static void _ePrivate_BN256_OAQUE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPrivate_BN256_OAQUE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPrivate_BN256_OAQUE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPrivate_BN256_OAQUE(OssGlobal * _g, void * _data);
#endif
static void _ePrivate_BN256_IBE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPrivate_BN256_IBE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPrivate_BN256_IBE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPrivate_BN256_IBE(OssGlobal * _g, void * _data);
#endif
static void _eMaster_BN256_OAQUE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dMaster_BN256_OAQUE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fMaster_BN256_OAQUE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pMaster_BN256_OAQUE(OssGlobal * _g, void * _data);
#endif
static void _eMaster_BN256_IBE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dMaster_BN256_IBE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fMaster_BN256_IBE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pMaster_BN256_IBE(OssGlobal * _g, void * _data);
#endif
static void _ePublic_Ed25519(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPublic_Ed25519(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPublic_Ed25519(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPublic_Ed25519(OssGlobal * _g, void * _data);
#endif
static void _ePublic_Curve25519(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPublic_Curve25519(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPublic_Curve25519(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPublic_Curve25519(OssGlobal * _g, void * _data);
#endif
static void _ePublic_OAQUE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPublic_OAQUE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPublic_OAQUE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPublic_OAQUE(OssGlobal * _g, void * _data);
#endif
static void _eParams_BN256_OAQUE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dParams_BN256_OAQUE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fParams_BN256_OAQUE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pParams_BN256_OAQUE(OssGlobal * _g, void * _data);
#endif
static void _eParams_BN256_IBE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dParams_BN256_IBE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fParams_BN256_IBE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pParams_BN256_IBE(OssGlobal * _g, void * _data);
#endif
static void _ePublic_BN256_IBE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dPublic_BN256_IBE(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fPublic_BN256_IBE(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pPublic_BN256_IBE(OssGlobal * _g, void * _data);
#endif
static void _eKeyringAESCiphertext(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void * _dKeyringAESCiphertext(OssGlobal * _g);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fKeyringAESCiphertext(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pKeyringAESCiphertext(OssGlobal * _g, void * _data);
#endif
static void _emWAVE_Schema(struct ossGlobal * _g, int _pdunum, void * _inbuf);
static void _dmWAVE_Schema(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static int _fmWAVE_Schema(struct ossGlobal * _g, int _pdunum, void * _data);
#endif
#ifdef OSSPRINT
static int _pmWAVE_Schema(struct ossGlobal * _g, int _pdunum, void * _data);
#endif



#ifdef OSS_COPY_VALUE
static _WaveEntity  * _cpWaveEntity(OssGlobal * _g, _WaveEntity  * psVal, _WaveEntity  * pdVal);
static _EntityKeyringEntry  * _cpEntityKeyringEntry(OssGlobal * _g, _EntityKeyringEntry  * psVal, _EntityKeyringEntry  * pdVal);
static _Hash  * _cpHash(OssGlobal * _g, _Hash  * psVal, _Hash  * pdVal);
static _Location  * _cpLocation(OssGlobal * _g, _Location  * psVal, _Location  * pdVal);
static _Extension  * _cpExtension(OssGlobal * _g, _Extension  * psVal, _Extension  * pdVal);
static _seqof1 * * _cp_seqof1(OssGlobal * _g, _seqof1 * * psVal, _seqof1 * * pdVal);
static _seqof2 * * _cp_seqof2(OssGlobal * _g, _seqof2 * * psVal, _seqof2 * * pdVal);
static _seq5  * _cp_seq5(OssGlobal * _g, _seq5  * psVal, _seq5  * pdVal);
static _AttestationVerifierBody  * _cpAttestationVerifierBody(OssGlobal * _g, _AttestationVerifierBody  * psVal, _AttestationVerifierBody  * pdVal);
static _seqof3 * * _cp_seqof3(OssGlobal * _g, _seqof3 * * psVal, _seqof3 * * pdVal);
static _EntityPublicKey  * _cpEntityPublicKey(OssGlobal * _g, _EntityPublicKey  * psVal, _EntityPublicKey  * pdVal);
static _seqof14 * * _cp_seqof13(OssGlobal * _g, _seqof14 * * psVal, _seqof14 * * pdVal);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _cmWaveEntity(OssGlobal * _g, _WaveEntity  * _odata, _WaveEntity  * _cdata);
static int _cmEntityKeyringEntry(OssGlobal * _g, _EntityKeyringEntry  * _odata, _EntityKeyringEntry  * _cdata);
static int _cmHash(OssGlobal * _g, _Hash  * _odata, _Hash  * _cdata);
static int _cmLocation(OssGlobal * _g, _Location  * _odata, _Location  * _cdata);
static int _cmExtension(OssGlobal * _g, _Extension  * _odata, _Extension  * _cdata);
static int _cm_seqof1(OssGlobal * _g, _seqof1 * * _odata, _seqof1 * * _cdata);
static int _cm_seqof2(OssGlobal * _g, _seqof2 * * _odata, _seqof2 * * _cdata);
static int _cm_seq5(OssGlobal * _g, _seq5  * _odata, _seq5  * _cdata);
static int _cmAttestationVerifierBody(OssGlobal * _g, _AttestationVerifierBody  * _odata, _AttestationVerifierBody  * _cdata);
static int _cm_seqof3(OssGlobal * _g, _seqof3 * * _odata, _seqof3 * * _cdata);
static int _cmEntityPublicKey(OssGlobal * _g, _EntityPublicKey  * _odata, _EntityPublicKey  * _cdata);
static int _cm_seqof13(OssGlobal * _g, _seqof14 * * _odata, _seqof14 * * _cdata);
#endif /* OSS_COMPARE_VALUE */

static void (*_Encoders[37])(OssGlobal *, void *, char **, long *, unsigned int) = {
    _eWaveWireObject,
    _eWaveAttestation,
    _eAttestationBody,
    _eWaveEntity,
    _eWaveEntitySecret,
    _eEntityKeyring,
    _eEntityKeyringEntry,
    _eWaveExplicitProof,
    _eRTreePolicy,
    _eHashSha3_256,
    _eHashSha_256,
    _eHashKeccak_256,
    _eLocationURL,
    _eLocationEthereum,
    _ePSKBodyCiphertext,
    _eWR1BodyCiphertext,
    _eWR1Envelope,
    _eWR1ProverBody,
    _eWR1VerifierBody,
    _eEd25519OuterSignature,
    _eSignedOuterKey,
    _eTrustLevel,
    _eCommitmentRevocationOption,
    _eAVKeyAES128_GCM,
    _ePrivate_Ed25519,
    _ePrivate_Curve25519,
    _ePrivate_BN256_OAQUE,
    _ePrivate_BN256_IBE,
    _eMaster_BN256_OAQUE,
    _eMaster_BN256_IBE,
    _ePublic_Ed25519,
    _ePublic_Curve25519,
    _ePublic_OAQUE,
    _eParams_BN256_OAQUE,
    _eParams_BN256_IBE,
    _ePublic_BN256_IBE,
    _eKeyringAESCiphertext
};
static void *(*_Decoders[37])(OssGlobal *) = {
    _dWaveWireObject,
    _dWaveAttestation,
    _dAttestationBody,
    _dWaveEntity,
    _dWaveEntitySecret,
    _dEntityKeyring,
    _dEntityKeyringEntry,
    _dWaveExplicitProof,
    _dRTreePolicy,
    _dHashSha3_256,
    _dHashSha_256,
    _dHashKeccak_256,
    _dLocationURL,
    _dLocationEthereum,
    _dPSKBodyCiphertext,
    _dWR1BodyCiphertext,
    _dWR1Envelope,
    _dWR1ProverBody,
    _dWR1VerifierBody,
    _dEd25519OuterSignature,
    _dSignedOuterKey,
    _dTrustLevel,
    _dCommitmentRevocationOption,
    _dAVKeyAES128_GCM,
    _dPrivate_Ed25519,
    _dPrivate_Curve25519,
    _dPrivate_BN256_OAQUE,
    _dPrivate_BN256_IBE,
    _dMaster_BN256_OAQUE,
    _dMaster_BN256_IBE,
    _dPublic_Ed25519,
    _dPublic_Curve25519,
    _dPublic_OAQUE,
    _dParams_BN256_OAQUE,
    _dParams_BN256_IBE,
    _dPublic_BN256_IBE,
    _dKeyringAESCiphertext
};
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void (*_FreePDU[37])(OssGlobal *, void *) = {
    _fWaveWireObject,
    _fWaveAttestation,
    _fAttestationBody,
    _fWaveEntity,
    _fWaveEntitySecret,
    _fEntityKeyring,
    _fEntityKeyringEntry,
    _fWaveExplicitProof,
    _fRTreePolicy,
    _fHashSha3_256,
    _fHashSha_256,
    _fHashKeccak_256,
    _fLocationURL,
    _fLocationEthereum,
    _fPSKBodyCiphertext,
    _fWR1BodyCiphertext,
    _fWR1Envelope,
    _fWR1ProverBody,
    _fWR1VerifierBody,
    _fEd25519OuterSignature,
    _fSignedOuterKey,
    _fTrustLevel,
    _fCommitmentRevocationOption,
    _fAVKeyAES128_GCM,
    _fPrivate_Ed25519,
    _fPrivate_Curve25519,
    _fPrivate_BN256_OAQUE,
    _fPrivate_BN256_IBE,
    _fMaster_BN256_OAQUE,
    _fMaster_BN256_IBE,
    _fPublic_Ed25519,
    _fPublic_Curve25519,
    _fPublic_OAQUE,
    _fParams_BN256_OAQUE,
    _fParams_BN256_IBE,
    _fPublic_BN256_IBE,
    _fKeyringAESCiphertext
};
#endif
#ifdef OSSPRINT
static _print_pdu_ _PrintPDU[37] = {
    { _pWaveWireObject, (char *)"WaveWireObject" },
    { _pWaveAttestation, (char *)"WaveAttestation" },
    { _pAttestationBody, (char *)"AttestationBody" },
    { _pWaveEntity, (char *)"WaveEntity" },
    { _pWaveEntitySecret, (char *)"WaveEntitySecret" },
    { _pEntityKeyring, (char *)"EntityKeyring" },
    { _pEntityKeyringEntry, (char *)"EntityKeyringEntry" },
    { _pWaveExplicitProof, (char *)"WaveExplicitProof" },
    { _pRTreePolicy, (char *)"RTreePolicy" },
    { _pHashSha3_256, (char *)"HashSha3-256" },
    { _pHashSha_256, (char *)"HashSha-256" },
    { _pHashKeccak_256, (char *)"HashKeccak-256" },
    { _pLocationURL, (char *)"LocationURL" },
    { _pLocationEthereum, (char *)"LocationEthereum" },
    { _pPSKBodyCiphertext, (char *)"PSKBodyCiphertext" },
    { _pWR1BodyCiphertext, (char *)"WR1BodyCiphertext" },
    { _pWR1Envelope, (char *)"WR1Envelope" },
    { _pWR1ProverBody, (char *)"WR1ProverBody" },
    { _pWR1VerifierBody, (char *)"WR1VerifierBody" },
    { _pEd25519OuterSignature, (char *)"Ed25519OuterSignature" },
    { _pSignedOuterKey, (char *)"SignedOuterKey" },
    { _pTrustLevel, (char *)"TrustLevel" },
    { _pCommitmentRevocationOption, (char *)"CommitmentRevocationOption" },
    { _pAVKeyAES128_GCM, (char *)"AVKeyAES128-GCM" },
    { _pPrivate_Ed25519, (char *)"Private-Ed25519" },
    { _pPrivate_Curve25519, (char *)"Private-Curve25519" },
    { _pPrivate_BN256_OAQUE, (char *)"Private-BN256-OAQUE" },
    { _pPrivate_BN256_IBE, (char *)"Private-BN256-IBE" },
    { _pMaster_BN256_OAQUE, (char *)"Master-BN256-OAQUE" },
    { _pMaster_BN256_IBE, (char *)"Master-BN256-IBE" },
    { _pPublic_Ed25519, (char *)"Public-Ed25519" },
    { _pPublic_Curve25519, (char *)"Public-Curve25519" },
    { _pPublic_OAQUE, (char *)"Public-OAQUE" },
    { _pParams_BN256_OAQUE, (char *)"Params-BN256-OAQUE" },
    { _pParams_BN256_IBE, (char *)"Params-BN256-IBE" },
    { _pPublic_BN256_IBE, (char *)"Public-BN256-IBE" },
    { _pKeyringAESCiphertext, (char *)"KeyringAESCiphertext" }
};
#endif

/* TOED internal function implementations */

#if OSSDEBUG > 1
static const _Context_Id _context_id[] = {
    {(char *)"signature", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"tbs", (char *)"SEQUENCE", _sequence_type},
    {(char *)"extensions", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"revocations", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"validity", (char *)"SEQUENCE", _sequence_type},
    {(char *)"keys", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"EntityPublicKey", _sequence_type},
    {(char *)"verifyingKey", (char *)"EntityPublicKey", _sequence_type},
    {(char *)"secret", (char *)"EntityPrivateKey", _sequence_type},
    {(char *)"value", (char *)"OpenType", _opentype},
    {(char *)"type-id", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"public", (char *)"EntityPublicKey", _sequence_type},
    {(char *)"value", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"critical", (char *)"BOOLEAN", _boolean_type},
    {(char *)"extnID", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {NULL, (char *)"RevocationOption", _sequence_type},
    {(char *)"scheme", (char *)"SEQUENCE", _sequence_type},
    {NULL, (char *)"Extension", _sequence_type},
    {(char *)"notAfter", (char *)"Character String", _charstring_type},
    {(char *)"notBefore", (char *)"Character String", _charstring_type},
    {(char *)"outerSignatureBinding", (char *)"SEQUENCE", _sequence_type},
    {(char *)"policy", (char *)"SEQUENCE", _sequence_type},
    {(char *)"attesterLocation", (char *)"Location", _sequence_type},
    {(char *)"attester", (char *)"EntityHash", _sequence_type},
    {NULL, (char *)"PolicyAddendum", _sequence_type},
    {(char *)"key", (char *)"SEQUENCE", _sequence_type},
    {(char *)"capabilityFlags", (char *)"SET OF", _set_of_type},
    {NULL, (char *)"Capability", _integer_type},
    {NULL, (char *)"OCTET STRING", _octetstring_type},
    {(char *)"WaveWireObject", (char *)"SEQUENCE", _sequence_type},
    {(char *)"WaveAttestation", (char *)"SEQUENCE", _sequence_type},
    {(char *)"outerSignature", (char *)"SEQUENCE", _sequence_type},
    {(char *)"body", (char *)"SEQUENCE", _sequence_type},
    {(char *)"publicExtensions", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"subjectLocation", (char *)"Location", _sequence_type},
    {(char *)"subject", (char *)"EntityHash", _sequence_type},
    {(char *)"AttestationBody", (char *)"SEQUENCE", _sequence_type},
    {(char *)"proverExtensions", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"proverPolicyAddendums", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"verifierBody", (char *)"AttestationVerifierBody", _sequence_type},
    {(char *)"WaveEntity", (char *)"SEQUENCE", _sequence_type},
    {(char *)"WaveEntitySecret", (char *)"SEQUENCE", _sequence_type},
    {(char *)"keyring", (char *)"SEQUENCE", _sequence_type},
    {(char *)"entity", (char *)"WaveEntity", _sequence_type},
    {(char *)"EntityKeyring", (char *)"SEQUENCE", _sequence_type},
    {NULL, (char *)"EntityKeyringEntry", _sequence_type},
    {(char *)"EntityKeyringEntry", (char *)"SEQUENCE", _sequence_type},
    {(char *)"WaveExplicitProof", (char *)"SEQUENCE", _sequence_type},
    {(char *)"entities", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"paths", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"INTEGER", _integer_type},
    {(char *)"attestations", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"AttestationReference", _sequence_type},
    {(char *)"revocationChecks", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"RevocationCheck", _sequence_type},
    {NULL, (char *)"AttestationVerifierKey", _sequence_type},
    {(char *)"location", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"Location", _sequence_type},
    {(char *)"content", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"hash", (char *)"AttestationHash", _sequence_type},
    {(char *)"RTreePolicy", (char *)"SEQUENCE", _sequence_type},
    {(char *)"statements", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"RTreeStatement", _sequence_type},
    {(char *)"comment", (char *)"Character String", _charstring_type},
    {(char *)"resource", (char *)"Character String", _charstring_type},
    {(char *)"permissions", (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)"Character String", _charstring_type},
    {(char *)"permissionSet", (char *)"EntityHash", _sequence_type},
    {(char *)"indirections", (char *)"INTEGER", _integer_type},
    {(char *)"namespace", (char *)"EntityHash", _sequence_type},
    {(char *)"HashSha3-256", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"HashSha-256", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"HashKeccak-256", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"LocationURL", (char *)"SEQUENCE", _sequence_type},
    {(char *)"apiVersion", (char *)"INTEGER", _integer_type},
    {(char *)"value", (char *)"Character String", _charstring_type},
    {(char *)"LocationEthereum", (char *)"SEQUENCE", _sequence_type},
    {(char *)"contractAddress", (char *)"INTEGER", _integer_type},
    {(char *)"chainID", (char *)"INTEGER", _integer_type},
    {(char *)"PSKBodyCiphertext", (char *)"SEQUENCE", _sequence_type},
    {(char *)"encryptedUnder", (char *)"EntityPublicKey", _sequence_type},
    {(char *)"attestationBodyCiphertext", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"WR1BodyCiphertext", (char *)"SEQUENCE", _sequence_type},
    {(char *)"envelopeKey-curve25519", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"envelopeKey-ibe-bn256", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"envelopeCiphertext", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"proverBodyCiphertext", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"verifierBodyCiphertext", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"WR1Envelope", (char *)"SEQUENCE", _sequence_type},
    {(char *)"partition", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"bodyKeys-oaque", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"WR1ProverBody", (char *)"SEQUENCE", _sequence_type},
    {(char *)"addendums", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"WR1VerifierBody", (char *)"SEQUENCE", _sequence_type},
    {(char *)"attestationVerifierBody", (char *)"AttestationVerifierBody", _sequence_type},
    {(char *)"Ed25519OuterSignature", (char *)"SEQUENCE", _sequence_type},
    {(char *)"verifyingKey", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"SignedOuterKey", (char *)"SEQUENCE", _sequence_type},
    {(char *)"outerSignatureScheme", (char *)"OBJECT IDENTIFIER", _object_identifier_type},
    {(char *)"TrustLevel", (char *)"SEQUENCE", _sequence_type},
    {(char *)"trust", (char *)"INTEGER", _integer_type},
    {(char *)"CommitmentRevocationOption", (char *)"SEQUENCE", _sequence_type},
    {(char *)"location", (char *)"Location", _sequence_type},
    {(char *)"hash", (char *)"Hash", _sequence_type},
    {(char *)"AVKeyAES128-GCM", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Private-Ed25519", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Private-Curve25519", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Private-BN256-OAQUE", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Private-BN256-IBE", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Master-BN256-OAQUE", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Master-BN256-IBE", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Public-Ed25519", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Public-Curve25519", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Public-OAQUE", (char *)"SEQUENCE", _sequence_type},
    {(char *)"attributeset", (char *)"SEQUENCE OF", _sequence_of_type},
    {(char *)"params", (char *)"Params-BN256-OAQUE", _octetstring_type},
    {(char *)"Params-BN256-OAQUE", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Params-BN256-IBE", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"Public-BN256-IBE", (char *)"SEQUENCE", _sequence_type},
    {(char *)"id", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"params", (char *)"Params-BN256-IBE", _octetstring_type},
    {(char *)"KeyringAESCiphertext", (char *)"SEQUENCE", _sequence_type},
    {(char *)"iterations", (char *)"INTEGER", _integer_type},
    {(char *)"salt", (char *)"OCTET STRING", _octetstring_type},
    {(char *)"ciphertext", (char *)"OCTET STRING", _octetstring_type}
};
#endif



#ifdef OSS_COPY_VALUE
static void _oss_cpy_new_open_type (OssGlobal *_g, int *_pduNum,
		OssBuf *_obuf, OssBuf *_cbuf, void *_odecoded, void **_cdecoded);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _oss_cmp_new_open_type (OssGlobal *_g, int _pduNum1, int _pduNum2,
		OssBuf *_obuf1, OssBuf *_obuf2, void *_decoded1, void *_decoded2);
#endif /* OSS_COMPARE_VALUE */

#ifdef OSS_NO_DETAIL_MM_ERROR_CODES
static void _oeWAVE_Schema(OssGlobal * _g, int _pdunum, void * _inbuf)
{
    _oss_toed_error(_g, _unlinked_encrules_err, "OER/COER");
    (void)_pdunum;	/* to avoid C-compilation warning */
    (void)_inbuf;	/* to avoid C-compilation warning */
}

static void * _odWAVE_Schema(OssGlobal * _g, int _pdunum)
{
    _oss_toed_error(_g, _unlinked_encrules_err, "OER/COER");
    (void)_pdunum;	/* to avoid C-compilation warning */
    return NULL;
}

#endif
#if OSS_TOED_API_LEVEL >= 34
static void _jeWAVE_Schema(OssGlobal * _g, int _pdunum, void * _inbuf)
{
    _oss_toed_error(_g, _unlinked_encrules_err, "JSON");
    (void)_pdunum;	/* to avoid C-compilation warning */
    (void)_inbuf;	/* to avoid C-compilation warning */
}

static void * _jdWAVE_Schema(OssGlobal * _g, int _pdunum)
{
    _oss_toed_error(_g, _unlinked_encrules_err, "JSON");
    (void)_pdunum;	/* to avoid C-compilation warning */
    return NULL;
}

#endif
static long _edWaveEntity(OssGlobal * _g, char ** _out_pos, long * _max_len, _WaveEntity * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->signature.value, _in_data->signature.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(1)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 2)
	    _data_len = _ed_seqof2(_g, _out_pos, &_out_len, &_in_data->tbs.extensions);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(3)
	    _data_len = _ed_seqof1(_g, _out_pos, &_out_len, &_in_data->tbs.revocations);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(4)
	    _data_len = _ed_seq5(_g, _out_pos, &_out_len, &_in_data->tbs.validity);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(5)
	    {
		_seqof4 * _temp;
		unsigned long count;
		unsigned long _lindex;
		long _total_len = 0;
		OSS_UINT32 _sp;
		void **_st = _oss_load_enc_stack(_g, &_sp);
		OSS_CNTX_NEW(_oss_c, 6)
		for (_temp = _in_data->tbs.keys, count = 0; _temp; _temp = _temp->next) {
		    OSS_CNTX_SETOCC(count + 1)
		    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		    _st[_sp++] = _temp;
		    count++;
		}
		for (_lindex = 0; _lindex < count; _lindex++) {
		    OSS_CNTX_SETOCC(count - _lindex)
		    _temp = (_seqof4 *)_st[--_sp];
		    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		    _oss_save_enc_stack(_g, _sp);
		    _data_len = _edEntityPublicKey(_g, _out_pos, &_out_len, &_temp->value);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _st = _oss_load_enc_stack(_g, &_sp);
		    _total_len += _data_len;
		}
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(7)
	    _data_len = _edEntityPublicKey(_g, _out_pos, &_out_len, &_in_data->tbs.verifyingKey);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edEntityKeyringEntry(OssGlobal * _g, char ** _out_pos, long * _max_len, _EntityKeyringEntry * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 8)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 9)
	    if (_in_data->secret.value.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->secret.value.encoded.value, _in_data->secret.value.encoded.length);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_SET(10)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->secret.type_id.value, _in_data->secret.type_id.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_SET(11)
	_data_len = _edEntityPublicKey(_g, _out_pos, &_out_len, &_in_data->EntityKeyringEntry_public);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edHash(OssGlobal * _g, char ** _out_pos, long * _max_len, _Hash * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 9)
	if (_in_data->value.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->value.encoded.value, _in_data->value.encoded.length);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_SET(10)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->type_id.value, _in_data->type_id.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edLocation(OssGlobal * _g, char ** _out_pos, long * _max_len, _Location * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 9)
	if (_in_data->value.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->value.encoded.value, _in_data->value.encoded.length);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_SET(10)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->type_id.value, _in_data->type_id.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edExtension(OssGlobal * _g, char ** _out_pos, long * _max_len, _Extension * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 12)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value.value, _in_data->value.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(13)
	_data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _in_data->critical);
	_total_len += _data_len;
	OSS_CNTX_SET(14)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->extnID.value, _in_data->extnID.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof1(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof1 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof1 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 15)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof1 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 16)
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 9)
		    if (_temp->value.scheme.value.encoded.length == 0)
			_oss_enc_error(_g, _zero_length_OpenType, 0);
		    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.scheme.value.encoded.value, _temp->value.scheme.value.encoded.length);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		    _total_len += _data_len;
		    OSS_CNTX_SET(10)
		    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.scheme.type_id.value, _temp->value.scheme.type_id.length, -1);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		    _total_len += _data_len;
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
		_total_len += _data_len;
		OSS_CNTX_SET(13)
		_data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _temp->value.critical);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof2(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof2 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof2 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 17)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof2 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _edExtension(_g, _out_pos, &_out_len, &_temp->value);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seq5(OssGlobal * _g, char ** _out_pos, long * _max_len, _seq5 * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 18)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->notAfter == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->notAfter, -1, 1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
	_total_len += _data_len;
	OSS_CNTX_SET(19)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->notBefore == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->notBefore, -1, 1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edAttestationVerifierBody(OssGlobal * _g, char ** _out_pos, long * _max_len, _AttestationVerifierBody * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 20)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 9)
	    if (_in_data->outerSignatureBinding.value.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->outerSignatureBinding.value.encoded.value, _in_data->outerSignatureBinding.value.encoded.length);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_SET(10)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->outerSignatureBinding.type_id.value, _in_data->outerSignatureBinding.type_id.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_SET(2)
	_data_len = _ed_seqof2(_g, _out_pos, &_out_len, &_in_data->extensions);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(21)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 9)
	    if (_in_data->policy.value.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->policy.value.encoded.value, _in_data->policy.value.encoded.length);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_SET(10)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->policy.type_id.value, _in_data->policy.type_id.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_SET(4)
	_data_len = _ed_seq5(_g, _out_pos, &_out_len, &_in_data->validity);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(22)
	_data_len = _edLocation(_g, _out_pos, &_out_len, &_in_data->attesterLocation);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_SET(23)
	_data_len = _edHash(_g, _out_pos, &_out_len, &_in_data->attester);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof3(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof3 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	_seqof3 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 24)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof3 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _oss_save_enc_stack(_g, _sp);
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 9)
		if (_temp->value.value.encoded.length == 0)
		    _oss_enc_error(_g, _zero_length_OpenType, 0);
		_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp->value.value.encoded.value, _temp->value.value.encoded.length);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		_total_len += _data_len;
		OSS_CNTX_SET(10)
		_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp->value.type_id.value, _temp->value.type_id.length, -1);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	    _st = _oss_load_enc_stack(_g, &_sp);
	    _total_len += _data_len;
	}
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _edEntityPublicKey(OssGlobal * _g, char ** _out_pos, long * _max_len, _EntityPublicKey * _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 25)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 9)
	    if (_in_data->key.value.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->key.value.encoded.value, _in_data->key.value.encoded.length);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_SET(10)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->key.type_id.value, _in_data->key.type_id.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_SET(26)
	{
	    _setof1 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 27)
	    for (_temp = _in_data->capabilityFlags, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    if (count > 1) _oss_beginBlock(_g, count, _out_pos, &_out_len);
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_setof1 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		if (count > 1) _oss_nextItem(_g, &_out_len);
		_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value, 0x2);
		_total_len += _data_len;
	    }
	    _oss_save_enc_stack(_g, _sp);
	    if (count > 1) _oss_endBlock(_g, _out_pos, &_out_len, 0);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x31);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static long _ed_seqof13(OssGlobal * _g, char ** _out_pos, long * _max_len, _seqof14 ** _in_data)
{
#if OSSDEBUG > 1
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    long _out_len = *_max_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;

    {
	_seqof14 * _temp;
	unsigned long count;
	unsigned long _lindex;
	long _total_len = 0;
	OSS_UINT32 _sp;
	void **_st = _oss_load_enc_stack(_g, &_sp);
	OSS_CNTX_NEW(_oss_c, 28)
	for (_temp = *_in_data, count = 0; _temp; _temp = _temp->next) {
	    OSS_CNTX_SETOCC(count + 1)
	    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
	    _st[_sp++] = _temp;
	    count++;
	}
	for (_lindex = 0; _lindex < count; _lindex++) {
	    OSS_CNTX_SETOCC(count - _lindex)
	    _temp = (_seqof14 *)_st[--_sp];
	    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.value, _temp->value.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	    _total_len += _data_len;
	}
	_oss_save_enc_stack(_g, _sp);
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    *_max_len = _out_len;
    return _data_len;
}

static void _eWaveWireObject(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveWireObject	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_WaveWireObject *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(1,29)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 9)
	if (_in_data->value.encoded.length == 0)
	    _oss_enc_error(_g, _zero_length_OpenType, 0);
	_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->value.encoded.value, _in_data->value.encoded.length);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	_total_len += _data_len;
	OSS_CNTX_SET(10)
	_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->type_id.value, _in_data->type_id.length, -1);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eWaveAttestation(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveAttestation	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_WaveAttestation *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(2,30)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 31)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 9)
	    if (_in_data->outerSignature.value.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->outerSignature.value.encoded.value, _in_data->outerSignature.value.encoded.length);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_SET(10)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->outerSignature.type_id.value, _in_data->outerSignature.type_id.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_SET(1)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 32)
	    {
		long _total_len = 0;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 9)
		if (_in_data->tbs.body.value.encoded.length == 0)
		    _oss_enc_error(_g, _zero_length_OpenType, 0);
		_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->tbs.body.value.encoded.value, _in_data->tbs.body.value.encoded.length);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
		_total_len += _data_len;
		OSS_CNTX_SET(10)
		_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->tbs.body.type_id.value, _in_data->tbs.body.type_id.length, -1);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
		_total_len += _data_len;
		OSS_CNTX_POP(_oss_c)
		_data_len = _total_len;
	    }
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	    _total_len += _data_len;
	    OSS_CNTX_SET(33)
	    _data_len = _ed_seqof2(_g, _out_pos, &_out_len, &_in_data->tbs.publicExtensions);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(3)
	    _data_len = _ed_seqof1(_g, _out_pos, &_out_len, &_in_data->tbs.revocations);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	    _total_len += _data_len;
	    OSS_CNTX_SET(34)
	    _data_len = _edLocation(_g, _out_pos, &_out_len, &_in_data->tbs.subjectLocation);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	    _total_len += _data_len;
	    OSS_CNTX_SET(35)
	    _data_len = _edHash(_g, _out_pos, &_out_len, &_in_data->tbs.subject);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAttestationBody(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AttestationBody	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_AttestationBody *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(3,36)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 37)
	_data_len = _ed_seqof2(_g, _out_pos, &_out_len, &_in_data->proverExtensions);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(38)
	_data_len = _ed_seqof3(_g, _out_pos, &_out_len, &_in_data->proverPolicyAddendums);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(39)
	_data_len = _edAttestationVerifierBody(_g, _out_pos, &_out_len, &_in_data->verifierBody);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eWaveEntity(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveEntity	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_WaveEntity *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(4,40)
    _data_len = _edWaveEntity(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eWaveEntitySecret(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveEntitySecret	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_WaveEntitySecret *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(5,41)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 42)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 9)
	    if (_in_data->keyring.value.encoded.length == 0)
		_oss_enc_error(_g, _zero_length_OpenType, 0);
	    _data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _in_data->keyring.value.encoded.value, _in_data->keyring.value.encoded.length);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
	    _total_len += _data_len;
	    OSS_CNTX_SET(10)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->keyring.type_id.value, _in_data->keyring.type_id.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_SET(43)
	_data_len = _edWaveEntity(_g, _out_pos, &_out_len, &_in_data->entity);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEntityKeyring(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EntityKeyring	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_EntityKeyring *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(6,44)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 5)
	{
	    _seqof5 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 45)
	    for (_temp = _in_data->keys, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof5 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		_oss_save_enc_stack(_g, _sp);
		_data_len = _edEntityKeyringEntry(_g, _out_pos, &_out_len, &_temp->value);
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEntityKeyringEntry(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EntityKeyringEntry	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_EntityKeyringEntry *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(7,46)
    _data_len = _edEntityKeyringEntry(_g, _out_pos, &_out_len, _in_data);
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eWaveExplicitProof(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveExplicitProof	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_WaveExplicitProof *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(8,47)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 2)
	_data_len = _ed_seqof2(_g, _out_pos, &_out_len, &_in_data->extensions);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(48)
	_data_len = _ed_seqof13(_g, _out_pos, &_out_len, &_in_data->entities);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(49)
	{
	    _seqof12 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 50)
	    for (_temp = _in_data->paths, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof12 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		{
		    _setof1 * _temp1;
		    unsigned long count;
		    unsigned long _lindex;
		    long _total_len = 0;
		    OSS_CNTX_NEW(_oss_c, 51)
		    for (_temp1 = _temp->value, count = 0; _temp1; _temp1 = _temp1->next) {
			OSS_CNTX_SETOCC(count + 1)
			if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			_st[_sp++] = _temp1;
			count++;
		    }
		    for (_lindex = 0; _lindex < count; _lindex++) {
			OSS_CNTX_SETOCC(count - _lindex)
			_temp1 = (_setof1 *)_st[--_sp];
			if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp1->value, 0x2);
			_total_len += _data_len;
		    }
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_total_len += _data_len;
	    }
	    _oss_save_enc_stack(_g, _sp);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(52)
	{
	    _seqof11 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 53)
	    for (_temp = _in_data->attestations, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof11 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		_oss_save_enc_stack(_g, _sp);
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 2)
		    {
			_seqof2 * _temp1;
			unsigned long count;
			unsigned long _lindex;
			long _total_len = 0;
			OSS_CNTX_NEW(_oss_c, 17)
			for (_temp1 = _temp->value.extensions, count = 0; _temp1; _temp1 = _temp1->next) {
			    OSS_CNTX_SETOCC(count + 1)
			    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			    _st[_sp++] = _temp1;
			    count++;
			}
			for (_lindex = 0; _lindex < count; _lindex++) {
			    OSS_CNTX_SETOCC(count - _lindex)
			    _temp1 = (_seqof2 *)_st[--_sp];
			    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			    _data_len = _edExtension(_g, _out_pos, &_out_len, &_temp1->value);
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
			    _total_len += _data_len;
			}
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA4);
		    _total_len += _data_len;
		    OSS_CNTX_SET(54)
		    {
			_seqof8 * _temp1;
			unsigned long count;
			unsigned long _lindex;
			long _total_len = 0;
			OSS_CNTX_NEW(_oss_c, 55)
			for (_temp1 = _temp->value.revocationChecks, count = 0; _temp1; _temp1 = _temp1->next) {
			    OSS_CNTX_SETOCC(count + 1)
			    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			    _st[_sp++] = _temp1;
			    count++;
			}
			for (_lindex = 0; _lindex < count; _lindex++) {
			    OSS_CNTX_SETOCC(count - _lindex)
			    _temp1 = (_seqof8 *)_st[--_sp];
			    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			    _oss_save_enc_stack(_g, _sp);
			    {
				long _total_len = 0;
				OSS_CNTX_INIT

				OSS_CNTX_PUSH(_oss_c, 9)
				if (_temp1->value.value.encoded.length == 0)
				    _oss_enc_error(_g, _zero_length_OpenType, 0);
				_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp1->value.value.encoded.value, _temp1->value.value.encoded.length);
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
				_total_len += _data_len;
				OSS_CNTX_SET(10)
				_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp1->value.type_id.value, _temp1->value.type_id.length, -1);
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
				_total_len += _data_len;
				OSS_CNTX_POP(_oss_c)
				_data_len = _total_len;
			    }
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
			    _st = _oss_load_enc_stack(_g, &_sp);
			    _total_len += _data_len;
			}
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA3);
		    _total_len += _data_len;
		    OSS_CNTX_SET(5)
		    {
			_seqof7 * _temp1;
			unsigned long count;
			unsigned long _lindex;
			long _total_len = 0;
			OSS_CNTX_NEW(_oss_c, 56)
			for (_temp1 = _temp->value.keys, count = 0; _temp1; _temp1 = _temp1->next) {
			    OSS_CNTX_SETOCC(count + 1)
			    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			    _st[_sp++] = _temp1;
			    count++;
			}
			for (_lindex = 0; _lindex < count; _lindex++) {
			    OSS_CNTX_SETOCC(count - _lindex)
			    _temp1 = (_seqof7 *)_st[--_sp];
			    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			    _oss_save_enc_stack(_g, _sp);
			    {
				long _total_len = 0;
				OSS_CNTX_INIT

				OSS_CNTX_PUSH(_oss_c, 9)
				if (_temp1->value.value.encoded.length == 0)
				    _oss_enc_error(_g, _zero_length_OpenType, 0);
				_data_len = _oss_write_bytes_d(_g, _out_pos, &_out_len, _temp1->value.value.encoded.value, _temp1->value.value.encoded.length);
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0xA0);
				_total_len += _data_len;
				OSS_CNTX_SET(10)
				_data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _temp1->value.type_id.value, _temp1->value.type_id.length, -1);
				_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
				_total_len += _data_len;
				OSS_CNTX_POP(_oss_c)
				_data_len = _total_len;
			    }
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
			    _st = _oss_load_enc_stack(_g, &_sp);
			    _total_len += _data_len;
			}
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA2);
		    _total_len += _data_len;
		    OSS_CNTX_SET(57)
		    {
			_seqof6 * _temp1;
			unsigned long count;
			unsigned long _lindex;
			long _total_len = 0;
			OSS_CNTX_NEW(_oss_c, 58)
			for (_temp1 = _temp->value.location, count = 0; _temp1; _temp1 = _temp1->next) {
			    OSS_CNTX_SETOCC(count + 1)
			    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			    _st[_sp++] = _temp1;
			    count++;
			}
			for (_lindex = 0; _lindex < count; _lindex++) {
			    OSS_CNTX_SETOCC(count - _lindex)
			    _temp1 = (_seqof6 *)_st[--_sp];
			    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			    _oss_save_enc_stack(_g, _sp);
			    _data_len = _edLocation(_g, _out_pos, &_out_len, &_temp1->value);
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
			    _st = _oss_load_enc_stack(_g, &_sp);
			    _total_len += _data_len;
			}
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, 0x30, 0xA1);
		    _total_len += _data_len;
		    OSS_CNTX_SET(59)
		    if (_temp->value.bit_mask & 0x80000000) {
			_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.content.value, _temp->value.content.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length2(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4, 0xA0);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(60)
		    _data_len = _edHash(_g, _out_pos, &_out_len, &_temp->value.hash);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
		    _total_len += _data_len;
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eRTreePolicy(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RTreePolicy	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_RTreePolicy *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(9,61)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 62)
	{
	    _seqof15 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 63)
	    for (_temp = _in_data->statements, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof15 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		_oss_save_enc_stack(_g, _sp);
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 64)
		    if (_temp->value.bit_mask & 0x80000000) {
			_data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.comment.value, _temp->value.comment.length, -1);
			if (_data_len < 0) {
			    _constructed = TRUE;
			    _data_len = -_data_len;
			} else
			    _constructed = FALSE;
			_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
			_total_len += _data_len;
		    }
		    OSS_CNTX_SET(65)
		    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.resource.value, _temp->value.resource.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
		    _total_len += _data_len;
		    OSS_CNTX_SET(66)
		    {
			_seqof14 * _temp1;
			unsigned long count;
			unsigned long _lindex;
			long _total_len = 0;
			OSS_CNTX_NEW(_oss_c, 67)
			for (_temp1 = _temp->value.permissions, count = 0; _temp1; _temp1 = _temp1->next) {
			    OSS_CNTX_SETOCC(count + 1)
			    if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
			    _st[_sp++] = _temp1;
			    count++;
			}
			for (_lindex = 0; _lindex < count; _lindex++) {
			    OSS_CNTX_SETOCC(count - _lindex)
			    _temp1 = (_seqof14 *)_st[--_sp];
			    if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
			    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp1->value.value, _temp1->value.length, -1);
			    if (_data_len < 0) {
				_constructed = TRUE;
				_data_len = -_data_len;
			    } else
				_constructed = FALSE;
			    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
			    _total_len += _data_len;
			}
			OSS_CNTX_POP(_oss_c)
			_data_len = _total_len;
		    }
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		    _total_len += _data_len;
		    OSS_CNTX_SET(68)
		    _data_len = _edHash(_g, _out_pos, &_out_len, &_temp->value.permissionSet);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
		    _total_len += _data_len;
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_st = _oss_load_enc_stack(_g, &_sp);
		_total_len += _data_len;
	    }
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(69)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->indirections, 0x2);
	_total_len += _data_len;
	OSS_CNTX_SET(70)
	_data_len = _edHash(_g, _out_pos, &_out_len, &_in_data->RTreePolicy_namespace);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eHashSha3_256(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(10,71)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eHashSha_256(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(11,72)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eHashKeccak_256(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(12,73)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eLocationURL(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LocationURL	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_LocationURL *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(13,74)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 75)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->apiVersion, 0x2);
	_total_len += _data_len;
	OSS_CNTX_SET(76)
	_data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value.value, _in_data->value.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eLocationEthereum(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LocationEthereum	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_LocationEthereum *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(14,77)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 78)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->contractAddress, 0x2);
	_total_len += _data_len;
	OSS_CNTX_SET(79)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->chainID, 0x2);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePSKBodyCiphertext(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PSKBodyCiphertext	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_PSKBodyCiphertext *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(15,80)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 81)
	_data_len = _edEntityPublicKey(_g, _out_pos, &_out_len, &_in_data->encryptedUnder);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(82)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->attestationBodyCiphertext.value, _in_data->attestationBodyCiphertext.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eWR1BodyCiphertext(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WR1BodyCiphertext	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_WR1BodyCiphertext *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(16,83)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 84)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->envelopeKey_curve25519.value, _in_data->envelopeKey_curve25519.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(85)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->envelopeKey_ibe_bn256.value, _in_data->envelopeKey_ibe_bn256.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(86)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->envelopeCiphertext.value, _in_data->envelopeCiphertext.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(87)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->proverBodyCiphertext.value, _in_data->proverBodyCiphertext.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(88)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->verifierBodyCiphertext.value, _in_data->verifierBodyCiphertext.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eWR1Envelope(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WR1Envelope	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_WR1Envelope *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(17,89)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 90)
	_data_len = _ed_seqof13(_g, _out_pos, &_out_len, &_in_data->partition);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(91)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->bodyKeys_oaque.value, _in_data->bodyKeys_oaque.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eWR1ProverBody(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WR1ProverBody	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_WR1ProverBody *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(18,92)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 2)
	_data_len = _ed_seqof2(_g, _out_pos, &_out_len, &_in_data->extensions);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(93)
	_data_len = _ed_seqof3(_g, _out_pos, &_out_len, &_in_data->addendums);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eWR1VerifierBody(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WR1VerifierBody	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_WR1VerifierBody *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(19,94)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 95)
	_data_len = _edAttestationVerifierBody(_g, _out_pos, &_out_len, &_in_data->attestationVerifierBody);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eEd25519OuterSignature(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Ed25519OuterSignature	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_Ed25519OuterSignature *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(20,96)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->signature.value, _in_data->signature.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(97)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->verifyingKey.value, _in_data->verifyingKey.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eSignedOuterKey(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SignedOuterKey	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_SignedOuterKey *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(21,98)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 0)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->signature.value, _in_data->signature.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(1)
	{
	    long _total_len = 0;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 97)
	    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->tbs.verifyingKey.value, _in_data->tbs.verifyingKey.length, -1);
	    if (_data_len < 0) {
		_constructed = TRUE;
		_data_len = -_data_len;
	    } else
		_constructed = FALSE;
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	    _total_len += _data_len;
	    OSS_CNTX_SET(99)
	    _data_len = _oss_encd_eobjid_ia(_g, _out_pos, &_out_len, _in_data->tbs.outerSignatureScheme.value, _in_data->tbs.outerSignatureScheme.length, -1);
	    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x6);
	    _total_len += _data_len;
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eTrustLevel(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TrustLevel	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_TrustLevel *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(22,100)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 101)
	_data_len = _oss_encd_uint_tl(_g, _out_pos, &_out_len, _in_data->trust, 0x2);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eCommitmentRevocationOption(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CommitmentRevocationOption	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    OSS_CNTX_INITZERO

    _in_data = (_CommitmentRevocationOption *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(23,102)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 103)
	_data_len = _edLocation(_g, _out_pos, &_out_len, &_in_data->location);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_SET(104)
	_data_len = _edHash(_g, _out_pos, &_out_len, &_in_data->hash);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x28);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eAVKeyAES128_GCM(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(24,105)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePrivate_Ed25519(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(25,106)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePrivate_Curve25519(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(26,107)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePrivate_BN256_OAQUE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(27,108)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePrivate_BN256_IBE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(28,109)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eMaster_BN256_OAQUE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(29,110)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eMaster_BN256_IBE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(30,111)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePublic_Ed25519(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(31,112)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePublic_Curve25519(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(32,113)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePublic_OAQUE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Public_OAQUE	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_Public_OAQUE *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(33,114)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 115)
	_data_len = _ed_seqof13(_g, _out_pos, &_out_len, &_in_data->attributeset);
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(116)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->params.value, _in_data->params.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eParams_BN256_OAQUE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(34,117)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eParams_BN256_IBE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (OSSC::COssString *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(35,118)
    _data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->value, _in_data->length, -1);
    if (_data_len < 0) {
	_constructed = TRUE;
	_data_len = -_data_len;
    } else
	_constructed = FALSE;
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _ePublic_BN256_IBE(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Public_BN256_IBE	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_Public_BN256_IBE *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(36,119)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 120)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->id.value, _in_data->id.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(121)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->params.value, _in_data->params.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _eKeyringAESCiphertext(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KeyringAESCiphertext	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_KeyringAESCiphertext *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(37,122)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 123)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->iterations, 0x2);
	_total_len += _data_len;
	OSS_CNTX_SET(124)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->salt.value, _in_data->salt.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_SET(125)
	_data_len = _oss_encd_uoct_ia(_g, _out_pos, &_out_len, (unsigned char *)_in_data->ciphertext.value, _in_data->ciphertext.length, -1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x24 : 0x4);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _emWAVE_Schema(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char **_outbuf = &_oss_c->_oss_outbufpos;
    long *_outlen = &_oss_c->_oss_outbuflen;
    unsigned int _flags = _g->encodingFlags;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, NULL, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (_pdunum < 1 || _pdunum > 37)
	_oss_enc_error(_g, _pdu_range, _pdunum);
    else
	_Encoders[_pdunum - 1](_g, _inbuf, _outbuf, _outlen, _flags);
#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, *_outbuf, *_outlen);
#endif
}

static void _d_WaveEntity(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _WaveEntity * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 1)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 7)
	    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else {
		if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
		} else
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		_oss_c->_tag_decoded = FALSE;
	    }
	    _data_tag = 0x10;
	    _d_EntityPublicKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbs.verifyingKey);
	    OSS_CNTX_SET(5)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_seqof4 * _head = NULL;
		_seqof4 * _cur;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
		unsigned long count = 0;
#endif
		OSS_CNTX_INIT

		do {
		    OSS_CNTX_PUSH(_oss_c, 6)
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
		    _head = _cur;
		    for (;;) {
			_seqof4 * _temp = _cur;
#if OSSDEBUG > 1
			count++;
#endif
			if (_data_tag != 0x10)
			    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
			OSS_CNTX_SETOCC(count)
			_oss_c->_tag_decoded = FALSE;
			if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
			_d_EntityPublicKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
			if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			    if (_bufpos > _end_pos)
				_oss_dec_error(_g, _inconsis_len, 0L);
#endif
			    break;
			}
			if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			    _buflen--;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			    _bufpos++;
			} else
			    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
				break;
			    }
			_oss_c->_tag_decoded = TRUE;
			_cur = (_seqof4 *)_oss_dec_const_alloc(_g, sizeof(_seqof4));
			_temp->next = _cur;
		    }
		    _cur->next = NULL;
		} while (0);
		_out_data->tbs.keys = _head;
		OSS_CNTX_POP(_oss_c)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_SET(4)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seq5(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbs.validity);
	    OSS_CNTX_SET(3)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seqof1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbs.revocations);
	    OSS_CNTX_SET(2)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seqof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbs.extensions);
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(0)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->signature.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->signature.value, -(long)UINT_MAX);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_EntityKeyringEntry(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EntityKeyringEntry * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 11)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x10) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x10 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x10;
	_d_EntityPublicKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->EntityKeyringEntry_public);
	OSS_CNTX_SET(8)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 10)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	    _data_tag = 0x6;
	    _out_data->secret.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->secret.type_id.value, -1);
	    OSS_CNTX_SET(9)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->secret.value.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->secret.value.encoded);
	    _out_data->secret.value.pduNum = 0;
	    *(void **)&_out_data->secret.value.decoded = NULL;
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_Hash(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Hash * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 10)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->type_id.value, -1);
	OSS_CNTX_SET(9)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->value.userField = NULL;
#endif
	_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->value.encoded);
	_out_data->value.pduNum = 0;
	*(void **)&_out_data->value.decoded = NULL;
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_Location(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Location * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 10)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->type_id.value, -1);
	OSS_CNTX_SET(9)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->value.userField = NULL;
#endif
	_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->value.encoded);
	_out_data->value.pduNum = 0;
	*(void **)&_out_data->value.decoded = NULL;
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_Extension(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _Extension * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 14)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x6) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x6 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x60000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x6;
	_out_data->extnID.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->extnID.value, -1);
	OSS_CNTX_SET(13)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1);
	_data_tag = 0x1;
	_out_data->critical = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(12)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->value.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value.value, -(long)UINT_MAX);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof1(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof1 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof1 * _head = NULL;
	_seqof1 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 15)
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
	    _head = _cur;
	    for (;;) {
		_seqof1 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 13)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1);
		    _data_tag = 0x1;
		    _temp->value.critical = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
		    OSS_CNTX_SET(16)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
		    _data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 10)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
			_data_tag = 0x6;
			_temp->value.scheme.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.scheme.type_id.value, -1);
			OSS_CNTX_SET(9)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
			_data_tag = 0x8000;
			if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
			_temp->value.scheme.value.userField = NULL;
#endif
			_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.scheme.value.encoded);
			_temp->value.scheme.value.pduNum = 0;
			*(void **)&_temp->value.scheme.value.decoded = NULL;
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				_buflen--;
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof2(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof2 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof2 * _head = NULL;
	_seqof2 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 17)
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof2 *)_oss_dec_const_alloc(_g, sizeof(_seqof2));
	    _head = _cur;
	    for (;;) {
		_seqof2 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x10)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_d_Extension(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof2 *)_oss_dec_const_alloc(_g, sizeof(_seqof2));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seq5(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seq5 * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 19)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 23 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x17) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x17 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x170000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x17;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->notBefore, -1, 1);
	OSS_CNTX_SET(18)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 23 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x17);
	_data_tag = 0x17;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->notAfter, -1, 1);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_AttestationVerifierBody(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _AttestationVerifierBody * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 23)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x8) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x8 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x8;
	_d_Hash(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->attester);
	OSS_CNTX_SET(22)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
	_d_Location(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->attesterLocation);
	OSS_CNTX_SET(4)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seq5(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->validity);
	OSS_CNTX_SET(21)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 10)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	    _data_tag = 0x6;
	    _out_data->policy.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->policy.type_id.value, -1);
	    OSS_CNTX_SET(9)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->policy.value.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->policy.value.encoded);
	    _out_data->policy.value.pduNum = 0;
	    *(void **)&_out_data->policy.value.decoded = NULL;
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(2)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->extensions);
	OSS_CNTX_SET(20)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 10)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	    _data_tag = 0x6;
	    _out_data->outerSignatureBinding.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->outerSignatureBinding.type_id.value, -1);
	    OSS_CNTX_SET(9)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->outerSignatureBinding.value.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->outerSignatureBinding.value.encoded);
	    _out_data->outerSignatureBinding.value.pduNum = 0;
	    *(void **)&_out_data->outerSignatureBinding.value.decoded = NULL;
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof3(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof3 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof3 * _head = NULL;
	_seqof3 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 24)
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof3 *)_oss_dec_const_alloc(_g, sizeof(_seqof3));
	    _head = _cur;
	    for (;;) {
		_seqof3 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x8)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		{
		    int _indef_tags = 0;
		    long _total_len = _data_length;
		    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 10)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		    _data_tag = 0x6;
		    _temp->value.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.type_id.value, -1);
		    OSS_CNTX_SET(9)
		    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		    _data_tag = 0x8000;
		    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		    _temp->value.value.userField = NULL;
#endif
		    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value.encoded);
		    _temp->value.value.pduNum = 0;
		    *(void **)&_temp->value.value.decoded = NULL;
		    while (_indef_tags > 0) {
			if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    if (!_buflen || _bufpos[0])
				_oss_dec_error(_g, _expec_eoc, 0L);
			    else
				_oss_dec_error(_g, _non_std_eoc, 0L);
			_indef_tags--;
		    }
		    OSS_CNTX_POP(_oss_c)
		    if (_bufpos != _end_pos) {
			if (_total_len < 0) {
			    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				_buflen--;
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			    if (_data_tag)
				_oss_dec_error(_g, _expec_eoc, 0L);
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			} else
			    _oss_dec_error(_g, _inconsis_len, 0L);
		    }
		}
#ifndef OSS_NO_NESTING_CONTROL
		if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof3 *)_oss_dec_const_alloc(_g, sizeof(_seqof3));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d_EntityPublicKey(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _EntityPublicKey * _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 26)
	if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 49 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else {
	    if (!_oss_c->_tag_decoded || _data_tag == 0x11) {
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x11 : 0);
	    } else
		_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x110000);
	    _oss_c->_tag_decoded = FALSE;
	}
	_data_tag = 0x11;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _setof1 * _head = NULL;
	    _setof1 * _cur;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 27)
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
		_head = _cur;
		for (;;) {
		    _setof1 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x2)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _temp->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->capabilityFlags = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(25)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 10)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	    _data_tag = 0x6;
	    _out_data->key.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->key.type_id.value, -1);
	    OSS_CNTX_SET(9)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->key.value.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->key.value.encoded);
	    _out_data->key.value.pduNum = 0;
	    *(void **)&_out_data->key.value.decoded = NULL;
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void _d__seqof13(OssGlobal * _g, char ** _in_pos, long * _buf_len, long _data_length, unsigned int _data_tag, _seqof14 ** _out_data)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char *_bufpos = *_in_pos;
    long _buflen = *_buf_len;

#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	_seqof14 * _head = NULL;
	_seqof14 * _cur;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	unsigned long count = 0;
#endif
	OSS_CNTX_INIT

	do {
	    OSS_CNTX_PUSH(_oss_c, 28)
	    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_bufpos > _end_pos)
		    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
		break;
	    }
	    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		_buflen--;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		_bufpos++;
	    } else
		if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		    break;
		}
	    _oss_c->_tag_decoded = TRUE;
	    _cur = (_seqof14 *)_oss_dec_const_alloc(_g, sizeof(_seqof14));
	    _head = _cur;
	    for (;;) {
		_seqof14 * _temp = _cur;
#if OSSDEBUG > 1
		count++;
#endif
		if (_data_tag != 0x4)
		    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x40000);
		OSS_CNTX_SETOCC(count)
		_oss_c->_tag_decoded = FALSE;
		if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		_temp->value.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.value, -(long)UINT_MAX);
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof14 *)_oss_dec_const_alloc(_g, sizeof(_seqof14));
		_temp->next = _cur;
	    }
	    _cur->next = NULL;
	} while (0);
	*_out_data = _head;
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    *_in_pos = _bufpos;
    *_buf_len = _buflen;
}

static void * _dWaveWireObject(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveWireObject *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,29)
    _out_data = (_WaveWireObject *)_oss_dec_const_alloc(_g, sizeof(_WaveWireObject));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
    _data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	int _indef_tags = 0;
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 10)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	_data_tag = 0x6;
	_out_data->type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->type_id.value, -1);
	OSS_CNTX_SET(9)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	_data_tag = 0x8000;
	if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	_out_data->value.userField = NULL;
#endif
	_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->value.encoded);
	_out_data->value.pduNum = 0;
	*(void **)&_out_data->value.decoded = NULL;
	while (_indef_tags > 0) {
	    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		if (!_buflen || _bufpos[0])
		    _oss_dec_error(_g, _expec_eoc, 0L);
		else
		    _oss_dec_error(_g, _non_std_eoc, 0L);
	    _indef_tags--;
	}
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dWaveAttestation(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveAttestation *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(2,30)
    _out_data = (_WaveAttestation *)_oss_dec_const_alloc(_g, sizeof(_WaveAttestation));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 1)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 35)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_Hash(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbs.subject);
	    OSS_CNTX_SET(34)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
	    _d_Location(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbs.subjectLocation);
	    OSS_CNTX_SET(3)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seqof1(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbs.revocations);
	    OSS_CNTX_SET(33)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	    _data_tag = 0x10;
	    _d__seqof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->tbs.publicExtensions);
	    OSS_CNTX_SET(32)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	    _data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		int _indef_tags = 0;
		long _total_len = _data_length;
		char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
		OSS_CNTX_INIT

		OSS_CNTX_PUSH(_oss_c, 10)
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
		_data_tag = 0x6;
		_out_data->tbs.body.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->tbs.body.type_id.value, -1);
		OSS_CNTX_SET(9)
		if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
		_data_tag = 0x8000;
		if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
		_out_data->tbs.body.value.userField = NULL;
#endif
		_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->tbs.body.value.encoded);
		_out_data->tbs.body.value.pduNum = 0;
		*(void **)&_out_data->tbs.body.value.decoded = NULL;
		while (_indef_tags > 0) {
		    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
			_buflen -= 2;
			_bufpos += 2;
		    } else
			if (!_buflen || _bufpos[0])
			    _oss_dec_error(_g, _expec_eoc, 0L);
			else
			    _oss_dec_error(_g, _non_std_eoc, 0L);
		    _indef_tags--;
		}
		OSS_CNTX_POP(_oss_c)
		if (_bufpos != _end_pos) {
		    if (_total_len < 0) {
			if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			    _buflen--;
			    _bufpos++;
			} else
			    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

			if (_data_tag)
			    _oss_dec_error(_g, _expec_eoc, 0L);
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
		    } else
			_oss_dec_error(_g, _inconsis_len, 0L);
		}
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(31)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 10)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	    _data_tag = 0x6;
	    _out_data->outerSignature.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->outerSignature.type_id.value, -1);
	    OSS_CNTX_SET(9)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->outerSignature.value.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->outerSignature.value.encoded);
	    _out_data->outerSignature.value.pduNum = 0;
	    *(void **)&_out_data->outerSignature.value.decoded = NULL;
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAttestationBody(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AttestationBody *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(3,36)
    _out_data = (_AttestationBody *)_oss_dec_const_alloc(_g, sizeof(_AttestationBody));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 39)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_AttestationVerifierBody(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->verifierBody);
	OSS_CNTX_SET(38)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof3(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->proverPolicyAddendums);
	OSS_CNTX_SET(37)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->proverExtensions);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dWaveEntity(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveEntity *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(4,40)
    _out_data = (_WaveEntity *)_oss_dec_const_alloc(_g, sizeof(_WaveEntity));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_WaveEntity(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dWaveEntitySecret(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveEntitySecret *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(5,41)
    _out_data = (_WaveEntitySecret *)_oss_dec_const_alloc(_g, sizeof(_WaveEntitySecret));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 43)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_WaveEntity(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->entity);
	OSS_CNTX_SET(42)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    int _indef_tags = 0;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 10)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	    _data_tag = 0x6;
	    _out_data->keyring.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->keyring.type_id.value, -1);
	    OSS_CNTX_SET(9)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
	    _data_tag = 0x8000;
	    if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
	    _out_data->keyring.value.userField = NULL;
#endif
	    _oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_out_data->keyring.value.encoded);
	    _out_data->keyring.value.pduNum = 0;
	    *(void **)&_out_data->keyring.value.decoded = NULL;
	    while (_indef_tags > 0) {
		if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
		    _buflen -= 2;
		    _bufpos += 2;
		} else
		    if (!_buflen || _bufpos[0])
			_oss_dec_error(_g, _expec_eoc, 0L);
		    else
			_oss_dec_error(_g, _non_std_eoc, 0L);
		_indef_tags--;
	    }
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEntityKeyring(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EntityKeyring *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(6,44)
    _out_data = (_EntityKeyring *)_oss_dec_const_alloc(_g, sizeof(_EntityKeyring));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 5)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof5 * _head = NULL;
	    _seqof5 * _cur;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 45)
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof5 *)_oss_dec_const_alloc(_g, sizeof(_seqof5));
		_head = _cur;
		for (;;) {
		    _seqof5 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
		    _d_EntityKeyringEntry(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value);
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof5 *)_oss_dec_const_alloc(_g, sizeof(_seqof5));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->keys = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEntityKeyringEntry(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _EntityKeyringEntry *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(7,46)
    _out_data = (_EntityKeyringEntry *)_oss_dec_const_alloc(_g, sizeof(_EntityKeyringEntry));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
    _d_EntityKeyringEntry(_g, &_bufpos, &_buflen, _data_length, _data_tag, _out_data);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dWaveExplicitProof(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WaveExplicitProof *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(8,47)
    _out_data = (_WaveExplicitProof *)_oss_dec_const_alloc(_g, sizeof(_WaveExplicitProof));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 52)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof11 * _head = NULL;
	    _seqof11 * _cur;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 53)
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof11 *)_oss_dec_const_alloc(_g, sizeof(_seqof11));
		_head = _cur;
		for (;;) {
		    _seqof11 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			int _indef_tags = 0;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			_temp->value.bit_mask = 0;
			OSS_CNTX_PUSH(_oss_c, 60)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
			_data_tag = 0x8;
			_d_Hash(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.hash);
			OSS_CNTX_POP(_oss_c)
			if (_bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0x8000 || _bufpos >= _end_pos)
			 {
			    _temp->value.bit_mask &= ~0x80000000;
			    memset(&_temp->value.content, 0, sizeof(_temp->value.content));
			}
else {
			    _temp->value.bit_mask |= 0x80000000;
			    OSS_CNTX_PUSH(_oss_c, 59)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
				_buflen -= 2;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0x8000) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x80 : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0x8000;
			    if (_data_length < 0) ++_indef_tags;
			    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
			    _data_tag = 0x4;
			    _temp->value.content.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.content.value, -(long)UINT_MAX);
			    while (_indef_tags > 0) {
				if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				    _buflen -= 2;
				    _bufpos += 2;
				} else
				    if (!_buflen || _bufpos[0])
					_oss_dec_error(_g, _expec_eoc, 0L);
				    else
					_oss_dec_error(_g, _non_std_eoc, 0L);
				_indef_tags--;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			OSS_CNTX_PUSH(_oss_c, 57)
			if (!_oss_c->_tag_decoded && _buflen >= 2 && (unsigned char)_bufpos[0] == 161 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else {
			    if (!_oss_c->_tag_decoded || _data_tag == 0x8001) {
				_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0x81 : 0);
			    } else
				_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80010000);
			    _oss_c->_tag_decoded = FALSE;
			}
			_data_tag = 0x8001;
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _seqof6 * _head1 = NULL;
			    _seqof6 * _cur1;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    do {
				OSS_CNTX_PUSH(_oss_c, 58)
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
				_cur1 = (_seqof6 *)_oss_dec_const_alloc(_g, sizeof(_seqof6));
				_head1 = _cur1;
				for (;;) {
				    _seqof6 * _temp1 = _cur1;
#if OSSDEBUG > 1
				    count++;
#endif
				    if (_data_tag != 0x8)
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000);
				    OSS_CNTX_SETOCC(count)
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _d_Location(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp1->value);
				    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					if (_bufpos > _end_pos)
					    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
					break;
				    }
				    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
					_bufpos++;
				    } else
					if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					    if (_oss_dec_length(_g, &_bufpos, &_buflen))
						_oss_dec_error(_g, _non_std_eoc, 0L);
					    _oss_c->_tag_decoded = FALSE;
					    break;
					}
				    _oss_c->_tag_decoded = TRUE;
				    _cur1 = (_seqof6 *)_oss_dec_const_alloc(_g, sizeof(_seqof6));
				    _temp1->next = _cur1;
				}
				_cur1->next = NULL;
			    } while (0);
			    _temp->value.location = _head1;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_SET(5)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 162 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x82);
			_data_tag = 0x8002;
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _seqof7 * _head1 = NULL;
			    _seqof7 * _cur1;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    do {
				OSS_CNTX_PUSH(_oss_c, 56)
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
				_cur1 = (_seqof7 *)_oss_dec_const_alloc(_g, sizeof(_seqof7));
				_head1 = _cur1;
				for (;;) {
				    _seqof7 * _temp1 = _cur1;
#if OSSDEBUG > 1
				    count++;
#endif
				    if (_data_tag != 0x8)
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000);
				    OSS_CNTX_SETOCC(count)
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					int _indef_tags = 0;
					long _total_len = _data_length;
					char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
					OSS_CNTX_INIT

					OSS_CNTX_PUSH(_oss_c, 10)
					if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
					_data_tag = 0x6;
					_temp1->value.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.type_id.value, -1);
					OSS_CNTX_SET(9)
					if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
					_data_tag = 0x8000;
					if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
					_temp1->value.value.userField = NULL;
#endif
					_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.value.encoded);
					_temp1->value.value.pduNum = 0;
					*(void **)&_temp1->value.value.decoded = NULL;
					while (_indef_tags > 0) {
					    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
						_buflen -= 2;
						_bufpos += 2;
					    } else
						if (!_buflen || _bufpos[0])
						    _oss_dec_error(_g, _expec_eoc, 0L);
						else
						    _oss_dec_error(_g, _non_std_eoc, 0L);
					    _indef_tags--;
					}
					OSS_CNTX_POP(_oss_c)
					if (_bufpos != _end_pos) {
					    if (_total_len < 0) {
						if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
						    _buflen--;
						    _bufpos++;
						} else
						    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

						if (_data_tag)
						    _oss_dec_error(_g, _expec_eoc, 0L);
						if (_oss_dec_length(_g, &_bufpos, &_buflen))
						    _oss_dec_error(_g, _non_std_eoc, 0L);
						_oss_c->_tag_decoded = FALSE;
					    } else
						_oss_dec_error(_g, _inconsis_len, 0L);
					}
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					if (_bufpos > _end_pos)
					    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
					break;
				    }
				    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
					_bufpos++;
				    } else
					if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					    if (_oss_dec_length(_g, &_bufpos, &_buflen))
						_oss_dec_error(_g, _non_std_eoc, 0L);
					    _oss_c->_tag_decoded = FALSE;
					    break;
					}
				    _oss_c->_tag_decoded = TRUE;
				    _cur1 = (_seqof7 *)_oss_dec_const_alloc(_g, sizeof(_seqof7));
				    _temp1->next = _cur1;
				}
				_cur1->next = NULL;
			    } while (0);
			    _temp->value.keys = _head1;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_SET(54)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 163 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x83);
			_data_tag = 0x8003;
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _seqof8 * _head1 = NULL;
			    _seqof8 * _cur1;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    do {
				OSS_CNTX_PUSH(_oss_c, 55)
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
				_cur1 = (_seqof8 *)_oss_dec_const_alloc(_g, sizeof(_seqof8));
				_head1 = _cur1;
				for (;;) {
				    _seqof8 * _temp1 = _cur1;
#if OSSDEBUG > 1
				    count++;
#endif
				    if (_data_tag != 0x8)
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x80000);
				    OSS_CNTX_SETOCC(count)
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
					    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
					    _oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
				    {
					int _indef_tags = 0;
					long _total_len = _data_length;
					char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
					OSS_CNTX_INIT

					OSS_CNTX_PUSH(_oss_c, 10)
					if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
					_data_tag = 0x6;
					_temp1->value.type_id.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.type_id.value, -1);
					OSS_CNTX_SET(9)
					if (_buflen >= 2 && (unsigned char)_bufpos[0] == 160 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
					    _buflen -= 2;
					    _bufpos += 2;
					} else
					    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x80);
					_data_tag = 0x8000;
					if (_data_length < 0) ++_indef_tags;
#ifdef OSS_OPENTYPE_HAS_USERFIELD
					_temp1->value.value.userField = NULL;
#endif
					_oss_dec_new_opentype(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.value.encoded);
					_temp1->value.value.pduNum = 0;
					*(void **)&_temp1->value.value.decoded = NULL;
					while (_indef_tags > 0) {
					    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
						_buflen -= 2;
						_bufpos += 2;
					    } else
						if (!_buflen || _bufpos[0])
						    _oss_dec_error(_g, _expec_eoc, 0L);
						else
						    _oss_dec_error(_g, _non_std_eoc, 0L);
					    _indef_tags--;
					}
					OSS_CNTX_POP(_oss_c)
					if (_bufpos != _end_pos) {
					    if (_total_len < 0) {
						if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
						    _buflen--;
						    _bufpos++;
						} else
						    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

						if (_data_tag)
						    _oss_dec_error(_g, _expec_eoc, 0L);
						if (_oss_dec_length(_g, &_bufpos, &_buflen))
						    _oss_dec_error(_g, _non_std_eoc, 0L);
						_oss_c->_tag_decoded = FALSE;
					    } else
						_oss_dec_error(_g, _inconsis_len, 0L);
					}
				    }
#ifndef OSS_NO_NESTING_CONTROL
				    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
					_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
				    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					if (_bufpos > _end_pos)
					    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
					break;
				    }
				    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
					_bufpos++;
				    } else
					if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					    if (_oss_dec_length(_g, &_bufpos, &_buflen))
						_oss_dec_error(_g, _non_std_eoc, 0L);
					    _oss_c->_tag_decoded = FALSE;
					    break;
					}
				    _oss_c->_tag_decoded = TRUE;
				    _cur1 = (_seqof8 *)_oss_dec_const_alloc(_g, sizeof(_seqof8));
				    _temp1->next = _cur1;
				}
				_cur1->next = NULL;
			    } while (0);
			    _temp->value.revocationChecks = _head1;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_SET(2)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 164 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x84);
			_data_tag = 0x8004;
			if (_data_length < 0) ++_indef_tags;
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _seqof2 * _head1 = NULL;
			    _seqof2 * _cur1;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    do {
				OSS_CNTX_PUSH(_oss_c, 17)
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
				_cur1 = (_seqof2 *)_oss_dec_const_alloc(_g, sizeof(_seqof2));
				_head1 = _cur1;
				for (;;) {
				    _seqof2 * _temp1 = _cur1;
#if OSSDEBUG > 1
				    count++;
#endif
				    if (_data_tag != 0x10)
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
				    OSS_CNTX_SETOCC(count)
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    _d_Extension(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp1->value);
				    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					if (_bufpos > _end_pos)
					    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
					break;
				    }
				    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
					_bufpos++;
				    } else
					if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					    if (_oss_dec_length(_g, &_bufpos, &_buflen))
						_oss_dec_error(_g, _non_std_eoc, 0L);
					    _oss_c->_tag_decoded = FALSE;
					    break;
					}
				    _oss_c->_tag_decoded = TRUE;
				    _cur1 = (_seqof2 *)_oss_dec_const_alloc(_g, sizeof(_seqof2));
				    _temp1->next = _cur1;
				}
				_cur1->next = NULL;
			    } while (0);
			    _temp->value.extensions = _head1;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			while (_indef_tags > 0) {
			    if (_buflen >= 2 && !_bufpos[0] && !_bufpos[1]) {
				_buflen -= 2;
				_bufpos += 2;
			    } else
				if (!_buflen || _bufpos[0])
				    _oss_dec_error(_g, _expec_eoc, 0L);
				else
				    _oss_dec_error(_g, _non_std_eoc, 0L);
			    _indef_tags--;
			}
			OSS_CNTX_POP(_oss_c)
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof11 *)_oss_dec_const_alloc(_g, sizeof(_seqof11));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->attestations = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(49)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof12 * _head = NULL;
	    _seqof12 * _cur;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 50)
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof12 *)_oss_dec_const_alloc(_g, sizeof(_seqof12));
		_head = _cur;
		for (;;) {
		    _seqof12 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    _temp->value = NULL;
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			_setof1 * _head1 = NULL;
			_setof1 * _cur1;
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			unsigned long count = 0;
#endif
			OSS_CNTX_INIT

			do {
			    OSS_CNTX_PUSH(_oss_c, 51)
			    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				if (_bufpos > _end_pos)
				    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
				break;
			    }
			    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				_bufpos++;
			    } else
				if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
				    if (_oss_dec_length(_g, &_bufpos, &_buflen))
					_oss_dec_error(_g, _non_std_eoc, 0L);
				    _oss_c->_tag_decoded = FALSE;
				    break;
				}
			    _oss_c->_tag_decoded = TRUE;
			    _cur1 = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
			    _head1 = _cur1;
			    for (;;) {
				_setof1 * _temp1 = _cur1;
#if OSSDEBUG > 1
				count++;
#endif
				if (_data_tag != 0x2)
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0x20000);
				OSS_CNTX_SETOCC(count)
				_oss_c->_tag_decoded = FALSE;
				if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				_temp1->value = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
				_cur1 = (_setof1 *)_oss_dec_const_alloc(_g, sizeof(_setof1));
				_temp1->next = _cur1;
			    }
			    _cur1->next = NULL;
			} while (0);
			_temp->value = _head1;
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof12 *)_oss_dec_const_alloc(_g, sizeof(_seqof12));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->paths = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(48)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof13(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->entities);
	OSS_CNTX_SET(2)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->extensions);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dRTreePolicy(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _RTreePolicy *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(9,61)
    _out_data = (_RTreePolicy *)_oss_dec_const_alloc(_g, sizeof(_RTreePolicy));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 70)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
	_d_Hash(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->RTreePolicy_namespace);
	OSS_CNTX_SET(69)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->indirections = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(62)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof15 * _head = NULL;
	    _seqof15 * _cur;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 63)
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof15 *)_oss_dec_const_alloc(_g, sizeof(_seqof15));
		_head = _cur;
		for (;;) {
		    _seqof15 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			_temp->value.bit_mask = 0;
			OSS_CNTX_PUSH(_oss_c, 68)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
			_data_tag = 0x8;
			_d_Hash(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_temp->value.permissionSet);
			OSS_CNTX_SET(66)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
			_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    _seqof14 * _head1 = NULL;
			    _seqof14 * _cur1;
			    long _total_len = _data_length;
			    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
			    unsigned long count = 0;
#endif
			    OSS_CNTX_INIT

			    do {
				OSS_CNTX_PUSH(_oss_c, 67)
				if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
				    if (_bufpos > _end_pos)
					_oss_dec_error(_g, _inconsis_len, 0L);
#endif
				    break;
				}
				if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
				    _buflen--;
				    _oss_c->_bitpos = _bufpos[0] & 0x20;
				    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
				    _bufpos++;
				} else
				    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					if (_oss_dec_length(_g, &_bufpos, &_buflen))
					    _oss_dec_error(_g, _non_std_eoc, 0L);
					_oss_c->_tag_decoded = FALSE;
					break;
				    }
				_oss_c->_tag_decoded = TRUE;
				_cur1 = (_seqof14 *)_oss_dec_const_alloc(_g, sizeof(_seqof14));
				_head1 = _cur1;
				for (;;) {
				    _seqof14 * _temp1 = _cur1;
#if OSSDEBUG > 1
				    count++;
#endif
				    if (_data_tag != 0xC)
					_oss_dec_error(_g, _tag_mismatch, _data_tag | 0xC0000);
				    OSS_CNTX_SETOCC(count)
				    _oss_c->_tag_decoded = FALSE;
				    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
					_buflen--;
					_bufpos++;
				    } else
					_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
				    if(_data_length) {
					_temp1->value.length = (OSS_UINT32)_oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_temp1->value.value, -(long)UINT_MAX);
				    } else {
					_temp1->value.length = 0;
					_temp1->value.value = NULL;
				    }
				    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
					if (_bufpos > _end_pos)
					    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
					break;
				    }
				    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
					_buflen--;
					_oss_c->_bitpos = _bufpos[0] & 0x20;
					_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
					_bufpos++;
				    } else
					if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
					    if (_oss_dec_length(_g, &_bufpos, &_buflen))
						_oss_dec_error(_g, _non_std_eoc, 0L);
					    _oss_c->_tag_decoded = FALSE;
					    break;
					}
				    _oss_c->_tag_decoded = TRUE;
				    _cur1 = (_seqof14 *)_oss_dec_const_alloc(_g, sizeof(_seqof14));
				    _temp1->next = _cur1;
				}
				_cur1->next = NULL;
			    } while (0);
			    _temp->value.permissions = _head1;
			    OSS_CNTX_POP(_oss_c)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			OSS_CNTX_SET(65)
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 12 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xC);
			_data_tag = 0xC;
			if(_data_length) {
			    _temp->value.resource.length = (OSS_UINT32)_oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.resource.value, -(long)UINT_MAX);
			} else {
			    _temp->value.resource.length = 0;
			    _temp->value.resource.value = NULL;
			}
			OSS_CNTX_POP(_oss_c)
			if (_bufpos < _end_pos) {
			    if (_buflen >= 1 && ((_bufpos[0]+1) & 0x1F)) {
				_buflen--;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0))<<8);
				_bufpos++;
			    } else
				_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);
			    _oss_c->_tag_decoded = TRUE;
			}
			if (_data_tag != 0xC || _bufpos >= _end_pos)
			 {
			    _temp->value.bit_mask &= ~0x80000000;
			    memset(&_temp->value.comment, 0, sizeof(_temp->value.comment));
			}
else {
			    _temp->value.bit_mask |= 0x80000000;
			    OSS_CNTX_PUSH(_oss_c, 64)
			    if (!_oss_c->_tag_decoded && _buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 12 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
				_buflen -= 2;
				_oss_c->_bitpos = _bufpos[0] & 0x20;
				_bufpos += 2;
			    } else {
				if (!_oss_c->_tag_decoded || _data_tag == 0xC) {
				    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, !_oss_c->_tag_decoded ? 0xC : 0);
				} else
				    _oss_dec_error(_g, _tag_mismatch, _data_tag | 0xC0000);
				_oss_c->_tag_decoded = FALSE;
			    }
			    _data_tag = 0xC;
			    if(_data_length) {
				_temp->value.comment.length = (OSS_UINT32)_oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.comment.value, -(long)UINT_MAX);
			    } else {
				_temp->value.comment.length = 0;
				_temp->value.comment.value = NULL;
			    }
			    OSS_CNTX_POP(_oss_c)
			}
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (!_oss_c->_tag_decoded)
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof15 *)_oss_dec_const_alloc(_g, sizeof(_seqof15));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->statements = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dHashSha3_256(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(10,71)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dHashSha_256(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(11,72)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dHashKeccak_256(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(12,73)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dLocationURL(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LocationURL *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(13,74)
    _out_data = (_LocationURL *)_oss_dec_const_alloc(_g, sizeof(_LocationURL));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 76)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 12 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xC);
	_data_tag = 0xC;
	if(_data_length) {
	    _out_data->value.length = (OSS_UINT32)_oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value.value, -(long)UINT_MAX);
	} else {
	    _out_data->value.length = 0;
	    _out_data->value.value = NULL;
	}
	OSS_CNTX_SET(75)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->apiVersion = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dLocationEthereum(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _LocationEthereum *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(14,77)
    _out_data = (_LocationEthereum *)_oss_dec_const_alloc(_g, sizeof(_LocationEthereum));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 79)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->chainID = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(78)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->contractAddress = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPSKBodyCiphertext(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _PSKBodyCiphertext *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(15,80)
    _out_data = (_PSKBodyCiphertext *)_oss_dec_const_alloc(_g, sizeof(_PSKBodyCiphertext));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 82)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->attestationBodyCiphertext.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->attestationBodyCiphertext.value, -(long)UINT_MAX);
	OSS_CNTX_SET(81)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_EntityPublicKey(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->encryptedUnder);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dWR1BodyCiphertext(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WR1BodyCiphertext *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(16,83)
    _out_data = (_WR1BodyCiphertext *)_oss_dec_const_alloc(_g, sizeof(_WR1BodyCiphertext));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 88)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->verifierBodyCiphertext.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->verifierBodyCiphertext.value, -(long)UINT_MAX);
	OSS_CNTX_SET(87)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->proverBodyCiphertext.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->proverBodyCiphertext.value, -(long)UINT_MAX);
	OSS_CNTX_SET(86)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->envelopeCiphertext.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->envelopeCiphertext.value, -(long)UINT_MAX);
	OSS_CNTX_SET(85)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->envelopeKey_ibe_bn256.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->envelopeKey_ibe_bn256.value, -(long)UINT_MAX);
	OSS_CNTX_SET(84)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->envelopeKey_curve25519.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->envelopeKey_curve25519.value, -(long)UINT_MAX);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dWR1Envelope(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WR1Envelope *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(17,89)
    _out_data = (_WR1Envelope *)_oss_dec_const_alloc(_g, sizeof(_WR1Envelope));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 91)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->bodyKeys_oaque.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->bodyKeys_oaque.value, -(long)UINT_MAX);
	OSS_CNTX_SET(90)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof13(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->partition);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dWR1ProverBody(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WR1ProverBody *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(18,92)
    _out_data = (_WR1ProverBody *)_oss_dec_const_alloc(_g, sizeof(_WR1ProverBody));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 93)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof3(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->addendums);
	OSS_CNTX_SET(2)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof2(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->extensions);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dWR1VerifierBody(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _WR1VerifierBody *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(19,94)
    _out_data = (_WR1VerifierBody *)_oss_dec_const_alloc(_g, sizeof(_WR1VerifierBody));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 95)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d_AttestationVerifierBody(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->attestationVerifierBody);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dEd25519OuterSignature(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Ed25519OuterSignature *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(20,96)
    _out_data = (_Ed25519OuterSignature *)_oss_dec_const_alloc(_g, sizeof(_Ed25519OuterSignature));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 97)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->verifyingKey.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->verifyingKey.value, -(long)UINT_MAX);
	OSS_CNTX_SET(0)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->signature.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->signature.value, -(long)UINT_MAX);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dSignedOuterKey(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _SignedOuterKey *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(21,98)
    _out_data = (_SignedOuterKey *)_oss_dec_const_alloc(_g, sizeof(_SignedOuterKey));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 1)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 99)
	    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 6 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x6);
	    _data_tag = 0x6;
	    _out_data->tbs.outerSignatureScheme.length = (OSS_UINT32)_oss_dec_eobjid_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->tbs.outerSignatureScheme.value, -1);
	    OSS_CNTX_SET(97)
	    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
		_buflen -= 2;
		_oss_c->_bitpos = _bufpos[0] & 0x20;
		_bufpos += 2;
	    } else
		_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	    _data_tag = 0x4;
	    _out_data->tbs.verifyingKey.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->tbs.verifyingKey.value, -(long)UINT_MAX);
	    OSS_CNTX_POP(_oss_c)
	    if (_bufpos != _end_pos) {
		if (_total_len < 0) {
		    if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
			_buflen--;
			_bufpos++;
		    } else
			_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		    if (_data_tag)
			_oss_dec_error(_g, _expec_eoc, 0L);
		    if (_oss_dec_length(_g, &_bufpos, &_buflen))
			_oss_dec_error(_g, _non_std_eoc, 0L);
		    _oss_c->_tag_decoded = FALSE;
		} else
		    _oss_dec_error(_g, _inconsis_len, 0L);
	    }
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_SET(0)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->signature.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->signature.value, -(long)UINT_MAX);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dTrustLevel(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _TrustLevel *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(22,100)
    _out_data = (_TrustLevel *)_oss_dec_const_alloc(_g, sizeof(_TrustLevel));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 101)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->trust = _oss_dec_uiint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dCommitmentRevocationOption(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _CommitmentRevocationOption *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(23,102)
    _out_data = (_CommitmentRevocationOption *)_oss_dec_const_alloc(_g, sizeof(_CommitmentRevocationOption));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 104)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
	_d_Hash(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->hash);
	OSS_CNTX_SET(103)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 40 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x8);
	_data_tag = 0x8;
	_d_Location(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->location);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dAVKeyAES128_GCM(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(24,105)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPrivate_Ed25519(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(25,106)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPrivate_Curve25519(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(26,107)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPrivate_BN256_OAQUE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(27,108)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPrivate_BN256_IBE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(28,109)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dMaster_BN256_OAQUE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(29,110)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dMaster_BN256_IBE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(30,111)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPublic_Ed25519(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(31,112)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPublic_Curve25519(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(32,113)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPublic_OAQUE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Public_OAQUE *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(33,114)
    _out_data = (_Public_OAQUE *)_oss_dec_const_alloc(_g, sizeof(_Public_OAQUE));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 116)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->params.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->params.value, -(long)UINT_MAX);
	OSS_CNTX_SET(115)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
	_d__seqof13(_g, &_bufpos, &_buflen, _data_length, _data_tag, &_out_data->attributeset);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dParams_BN256_OAQUE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(34,117)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dParams_BN256_IBE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    OSSC::COssString *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(35,118)
    _out_data = (OSSC::COssString *)_oss_dec_const_alloc(_g, sizeof(OSSC::COssString));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	_buflen -= 2;
	_oss_c->_bitpos = _bufpos[0] & 0x20;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
    _data_tag = 0x4;
    _out_data->length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->value, -(long)UINT_MAX);
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dPublic_BN256_IBE(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Public_BN256_IBE *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(36,119)
    _out_data = (_Public_BN256_IBE *)_oss_dec_const_alloc(_g, sizeof(_Public_BN256_IBE));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 121)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->params.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->params.value, -(long)UINT_MAX);
	OSS_CNTX_SET(120)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->id.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->id.value, -(long)UINT_MAX);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dKeyringAESCiphertext(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _KeyringAESCiphertext *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(37,122)
    _out_data = (_KeyringAESCiphertext *)_oss_dec_const_alloc(_g, sizeof(_KeyringAESCiphertext));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 125)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->ciphertext.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->ciphertext.value, -(long)UINT_MAX);
	OSS_CNTX_SET(124)
	if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 4 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _oss_c->_bitpos = _bufpos[0] & 0x20;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x4);
	_data_tag = 0x4;
	_out_data->salt.length = (OSS_UINT32)_oss_dec_uoct_ia(_g, &_bufpos, &_buflen, _data_length, &_out_data->salt.value, -(long)UINT_MAX);
	OSS_CNTX_SET(123)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->iterations = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void _dmWAVE_Schema(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;

    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, NULL);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (*_pdunum < 1 || *_pdunum > 37)
	_oss_dec_error(_g, _pdu_range, *_pdunum);
    *_outbuf = _Decoders[*_pdunum - 1](_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

#if (OSS_TOED_API_LEVEL < 22) || !defined(OSSNOFREEPDU)
#if OSS_TOED_API_LEVEL < 32
#define _oss_dec_free(_g, v)   if (v) _oss_dec_free(_g, v)
#define _oss_free_creal(_g, v) if (v) _oss_free_creal(_g, v)
#endif
static void _f_WaveEntity(OssGlobal * _g, _WaveEntity * _data_ptr)
{
    if (_data_ptr) {
	_f_EntityPublicKey(_g, &_data_ptr->tbs.verifyingKey);
	if (_data_ptr->tbs.keys) {
	    _seqof4 * _tempa = _data_ptr->tbs.keys;
	    _seqof4 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_EntityPublicKey(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
	_f__seq5(_g, &_data_ptr->tbs.validity);
	_f__seqof1(_g, &_data_ptr->tbs.revocations);
	_f__seqof2(_g, &_data_ptr->tbs.extensions);
	    _oss_dec_free(_g, _data_ptr->signature.value);
    }
}

static void _f_EntityKeyringEntry(OssGlobal * _g, _EntityKeyringEntry * _data_ptr)
{
    if (_data_ptr) {
	_f_EntityPublicKey(_g, &_data_ptr->EntityKeyringEntry_public);
	    _oss_dec_free(_g, _data_ptr->secret.type_id.value);
	if (_data_ptr->secret.value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->secret.value.encoded.value);
	if (_data_ptr->secret.value.pduNum != 0 && *(void **)&_data_ptr->secret.value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->secret.value.pduNum, *(void **)&_data_ptr->secret.value.decoded);
    }
}

static void _f_Hash(OssGlobal * _g, _Hash * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->type_id.value);
	if (_data_ptr->value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->value.encoded.value);
	if (_data_ptr->value.pduNum != 0 && *(void **)&_data_ptr->value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded);
    }
}

static void _f_Location(OssGlobal * _g, _Location * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->type_id.value);
	if (_data_ptr->value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->value.encoded.value);
	if (_data_ptr->value.pduNum != 0 && *(void **)&_data_ptr->value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded);
    }
}

static void _f_Extension(OssGlobal * _g, _Extension * _data_ptr)
{
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->extnID.value);
	    _oss_dec_free(_g, _data_ptr->value.value);
    }
}

static void _f__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof1 * _tempa = *_data_ptr;
	    _seqof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa->value.scheme.type_id.value);
		if (_tempa->value.scheme.value.encoded.value)
		    _oss_dec_free(_g, _tempa->value.scheme.value.encoded.value);
		if (_tempa->value.scheme.value.pduNum != 0 && *(void **)&_tempa->value.scheme.value.decoded)
		    _fmWAVE_Schema(_g, _tempa->value.scheme.value.pduNum, *(void **)&_tempa->value.scheme.value.decoded);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f__seqof2(OssGlobal * _g, _seqof2 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof2 * _tempa = *_data_ptr;
	    _seqof2 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Extension(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f__seq5(OssGlobal * _g, _seq5 * _data_ptr)
{
    if (_data_ptr) {
	_oss_dec_free(_g, _data_ptr->notBefore);
	_oss_dec_free(_g, _data_ptr->notAfter);
    }
}

static void _f_AttestationVerifierBody(OssGlobal * _g, _AttestationVerifierBody * _data_ptr)
{
    if (_data_ptr) {
	_f_Hash(_g, &_data_ptr->attester);
	_f_Location(_g, &_data_ptr->attesterLocation);
	_f__seq5(_g, &_data_ptr->validity);
	    _oss_dec_free(_g, _data_ptr->policy.type_id.value);
	if (_data_ptr->policy.value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->policy.value.encoded.value);
	if (_data_ptr->policy.value.pduNum != 0 && *(void **)&_data_ptr->policy.value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->policy.value.pduNum, *(void **)&_data_ptr->policy.value.decoded);
	_f__seqof2(_g, &_data_ptr->extensions);
	    _oss_dec_free(_g, _data_ptr->outerSignatureBinding.type_id.value);
	if (_data_ptr->outerSignatureBinding.value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->outerSignatureBinding.value.encoded.value);
	if (_data_ptr->outerSignatureBinding.value.pduNum != 0 && *(void **)&_data_ptr->outerSignatureBinding.value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->outerSignatureBinding.value.pduNum, *(void **)&_data_ptr->outerSignatureBinding.value.decoded);
    }
}

static void _f__seqof3(OssGlobal * _g, _seqof3 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof3 * _tempa = *_data_ptr;
	    _seqof3 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa->value.type_id.value);
		if (_tempa->value.value.encoded.value)
		    _oss_dec_free(_g, _tempa->value.value.encoded.value);
		if (_tempa->value.value.pduNum != 0 && *(void **)&_tempa->value.value.decoded)
		    _fmWAVE_Schema(_g, _tempa->value.value.pduNum, *(void **)&_tempa->value.value.decoded);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _f_EntityPublicKey(OssGlobal * _g, _EntityPublicKey * _data_ptr)
{
    if (_data_ptr) {
	if (_data_ptr->capabilityFlags) {
	    _setof1 * _tempa = _data_ptr->capabilityFlags;
	    _setof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
	    _oss_dec_free(_g, _data_ptr->key.type_id.value);
	if (_data_ptr->key.value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->key.value.encoded.value);
	if (_data_ptr->key.value.pduNum != 0 && *(void **)&_data_ptr->key.value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->key.value.pduNum, *(void **)&_data_ptr->key.value.decoded);
    }
}

static void _f__seqof13(OssGlobal * _g, _seqof14 ** _data_ptr)
{
    if (_data_ptr) {
	if (*_data_ptr) {
	    _seqof14 * _tempa = *_data_ptr;
	    _seqof14 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa->value.value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
}

static void _fWaveWireObject(OssGlobal * _g, void * _data)
{
    _WaveWireObject	*_data_ptr;
    _data_ptr = (_WaveWireObject *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->type_id.value);
	if (_data_ptr->value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->value.encoded.value);
	if (_data_ptr->value.pduNum != 0 && *(void **)&_data_ptr->value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fWaveAttestation(OssGlobal * _g, void * _data)
{
    _WaveAttestation	*_data_ptr;
    _data_ptr = (_WaveAttestation *)_data;
    if (_data_ptr) {
	_f_Hash(_g, &_data_ptr->tbs.subject);
	_f_Location(_g, &_data_ptr->tbs.subjectLocation);
	_f__seqof1(_g, &_data_ptr->tbs.revocations);
	_f__seqof2(_g, &_data_ptr->tbs.publicExtensions);
	    _oss_dec_free(_g, _data_ptr->tbs.body.type_id.value);
	if (_data_ptr->tbs.body.value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->tbs.body.value.encoded.value);
	if (_data_ptr->tbs.body.value.pduNum != 0 && *(void **)&_data_ptr->tbs.body.value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->tbs.body.value.pduNum, *(void **)&_data_ptr->tbs.body.value.decoded);
	    _oss_dec_free(_g, _data_ptr->outerSignature.type_id.value);
	if (_data_ptr->outerSignature.value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->outerSignature.value.encoded.value);
	if (_data_ptr->outerSignature.value.pduNum != 0 && *(void **)&_data_ptr->outerSignature.value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->outerSignature.value.pduNum, *(void **)&_data_ptr->outerSignature.value.decoded);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAttestationBody(OssGlobal * _g, void * _data)
{
    _AttestationBody	*_data_ptr;
    _data_ptr = (_AttestationBody *)_data;
    if (_data_ptr) {
	_f_AttestationVerifierBody(_g, &_data_ptr->verifierBody);
	_f__seqof3(_g, &_data_ptr->proverPolicyAddendums);
	_f__seqof2(_g, &_data_ptr->proverExtensions);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fWaveEntity(OssGlobal * _g, void * _data)
{
    _WaveEntity	*_data_ptr;
    _data_ptr = (_WaveEntity *)_data;
    _f_WaveEntity(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fWaveEntitySecret(OssGlobal * _g, void * _data)
{
    _WaveEntitySecret	*_data_ptr;
    _data_ptr = (_WaveEntitySecret *)_data;
    if (_data_ptr) {
	_f_WaveEntity(_g, &_data_ptr->entity);
	    _oss_dec_free(_g, _data_ptr->keyring.type_id.value);
	if (_data_ptr->keyring.value.encoded.value)
	    _oss_dec_free(_g, _data_ptr->keyring.value.encoded.value);
	if (_data_ptr->keyring.value.pduNum != 0 && *(void **)&_data_ptr->keyring.value.decoded)
	    _fmWAVE_Schema(_g, _data_ptr->keyring.value.pduNum, *(void **)&_data_ptr->keyring.value.decoded);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fEntityKeyring(OssGlobal * _g, void * _data)
{
    _EntityKeyring	*_data_ptr;
    _data_ptr = (_EntityKeyring *)_data;
    if (_data_ptr) {
	if (_data_ptr->keys) {
	    _seqof5 * _tempa = _data_ptr->keys;
	    _seqof5 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_EntityKeyringEntry(_g, &_tempa->value);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fEntityKeyringEntry(OssGlobal * _g, void * _data)
{
    _EntityKeyringEntry	*_data_ptr;
    _data_ptr = (_EntityKeyringEntry *)_data;
    _f_EntityKeyringEntry(_g, _data_ptr);
    _oss_dec_free(_g, _data_ptr);
}

static void _fWaveExplicitProof(OssGlobal * _g, void * _data)
{
    _WaveExplicitProof	*_data_ptr;
    _data_ptr = (_WaveExplicitProof *)_data;
    if (_data_ptr) {
	if (_data_ptr->attestations) {
	    _seqof11 * _tempa = _data_ptr->attestations;
	    _seqof11 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Hash(_g, &_tempa->value.hash);
		if (_tempa->value.bit_mask & 0x80000000) {
			_oss_dec_free(_g, _tempa->value.content.value);
		}
		if (_tempa->value.location) {
		    _seqof6 * _temp1a = _tempa->value.location;
		    _seqof6 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			_f_Location(_g, &_temp1a->value);
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		if (_tempa->value.keys) {
		    _seqof7 * _temp1a = _tempa->value.keys;
		    _seqof7 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			    _oss_dec_free(_g, _temp1a->value.type_id.value);
			if (_temp1a->value.value.encoded.value)
			    _oss_dec_free(_g, _temp1a->value.value.encoded.value);
			if (_temp1a->value.value.pduNum != 0 && *(void **)&_temp1a->value.value.decoded)
			    _fmWAVE_Schema(_g, _temp1a->value.value.pduNum, *(void **)&_temp1a->value.value.decoded);
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		if (_tempa->value.revocationChecks) {
		    _seqof8 * _temp1a = _tempa->value.revocationChecks;
		    _seqof8 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			    _oss_dec_free(_g, _temp1a->value.type_id.value);
			if (_temp1a->value.value.encoded.value)
			    _oss_dec_free(_g, _temp1a->value.value.encoded.value);
			if (_temp1a->value.value.pduNum != 0 && *(void **)&_temp1a->value.value.decoded)
			    _fmWAVE_Schema(_g, _temp1a->value.value.pduNum, *(void **)&_temp1a->value.value.decoded);
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		if (_tempa->value.extensions) {
		    _seqof2 * _temp1a = _tempa->value.extensions;
		    _seqof2 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			_f_Extension(_g, &_temp1a->value);
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
	if (_data_ptr->paths) {
	    _seqof12 * _tempa = _data_ptr->paths;
	    _seqof12 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		if (_tempa->value) {
		    _setof1 * _temp1a = _tempa->value;
		    _setof1 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
	_f__seqof13(_g, &_data_ptr->entities);
	_f__seqof2(_g, &_data_ptr->extensions);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fRTreePolicy(OssGlobal * _g, void * _data)
{
    _RTreePolicy	*_data_ptr;
    _data_ptr = (_RTreePolicy *)_data;
    if (_data_ptr) {
	_f_Hash(_g, &_data_ptr->RTreePolicy_namespace);
	if (_data_ptr->statements) {
	    _seqof15 * _tempa = _data_ptr->statements;
	    _seqof15 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_f_Hash(_g, &_tempa->value.permissionSet);
		if (_tempa->value.permissions) {
		    _seqof14 * _temp1a = _tempa->value.permissions;
		    _seqof14 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			    _oss_dec_free(_g, _temp1a->value.value);
			_oss_dec_free(_g, _temp1a);
			_temp1a = _temp1b;
		    }
		}
		    _oss_dec_free(_g, _tempa->value.resource.value);
		if (_tempa->value.bit_mask & 0x80000000) {
			_oss_dec_free(_g, _tempa->value.comment.value);
		}
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fHashSha3_256(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fHashSha_256(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fHashKeccak_256(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fLocationURL(OssGlobal * _g, void * _data)
{
    _LocationURL	*_data_ptr;
    _data_ptr = (_LocationURL *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fLocationEthereum(OssGlobal * _g, void * _data)
{
    _LocationEthereum	*_data_ptr;
    _data_ptr = (_LocationEthereum *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fPSKBodyCiphertext(OssGlobal * _g, void * _data)
{
    _PSKBodyCiphertext	*_data_ptr;
    _data_ptr = (_PSKBodyCiphertext *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->attestationBodyCiphertext.value);
	_f_EntityPublicKey(_g, &_data_ptr->encryptedUnder);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fWR1BodyCiphertext(OssGlobal * _g, void * _data)
{
    _WR1BodyCiphertext	*_data_ptr;
    _data_ptr = (_WR1BodyCiphertext *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->verifierBodyCiphertext.value);
	    _oss_dec_free(_g, _data_ptr->proverBodyCiphertext.value);
	    _oss_dec_free(_g, _data_ptr->envelopeCiphertext.value);
	    _oss_dec_free(_g, _data_ptr->envelopeKey_ibe_bn256.value);
	    _oss_dec_free(_g, _data_ptr->envelopeKey_curve25519.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fWR1Envelope(OssGlobal * _g, void * _data)
{
    _WR1Envelope	*_data_ptr;
    _data_ptr = (_WR1Envelope *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->bodyKeys_oaque.value);
	_f__seqof13(_g, &_data_ptr->partition);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fWR1ProverBody(OssGlobal * _g, void * _data)
{
    _WR1ProverBody	*_data_ptr;
    _data_ptr = (_WR1ProverBody *)_data;
    if (_data_ptr) {
	_f__seqof3(_g, &_data_ptr->addendums);
	_f__seqof2(_g, &_data_ptr->extensions);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fWR1VerifierBody(OssGlobal * _g, void * _data)
{
    _WR1VerifierBody	*_data_ptr;
    _data_ptr = (_WR1VerifierBody *)_data;
    if (_data_ptr) {
	_f_AttestationVerifierBody(_g, &_data_ptr->attestationVerifierBody);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fEd25519OuterSignature(OssGlobal * _g, void * _data)
{
    _Ed25519OuterSignature	*_data_ptr;
    _data_ptr = (_Ed25519OuterSignature *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->verifyingKey.value);
	    _oss_dec_free(_g, _data_ptr->signature.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fSignedOuterKey(OssGlobal * _g, void * _data)
{
    _SignedOuterKey	*_data_ptr;
    _data_ptr = (_SignedOuterKey *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->tbs.outerSignatureScheme.value);
	    _oss_dec_free(_g, _data_ptr->tbs.verifyingKey.value);
	    _oss_dec_free(_g, _data_ptr->signature.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fTrustLevel(OssGlobal * _g, void * _data)
{
    _TrustLevel	*_data_ptr;
    _data_ptr = (_TrustLevel *)_data;
    _oss_dec_free(_g, _data_ptr);
}

static void _fCommitmentRevocationOption(OssGlobal * _g, void * _data)
{
    _CommitmentRevocationOption	*_data_ptr;
    _data_ptr = (_CommitmentRevocationOption *)_data;
    if (_data_ptr) {
	_f_Hash(_g, &_data_ptr->hash);
	_f_Location(_g, &_data_ptr->location);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fAVKeyAES128_GCM(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPrivate_Ed25519(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPrivate_Curve25519(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPrivate_BN256_OAQUE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPrivate_BN256_IBE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fMaster_BN256_OAQUE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fMaster_BN256_IBE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPublic_Ed25519(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPublic_Curve25519(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPublic_OAQUE(OssGlobal * _g, void * _data)
{
    _Public_OAQUE	*_data_ptr;
    _data_ptr = (_Public_OAQUE *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->params.value);
	_f__seqof13(_g, &_data_ptr->attributeset);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fParams_BN256_OAQUE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fParams_BN256_IBE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fPublic_BN256_IBE(OssGlobal * _g, void * _data)
{
    _Public_BN256_IBE	*_data_ptr;
    _data_ptr = (_Public_BN256_IBE *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->params.value);
	    _oss_dec_free(_g, _data_ptr->id.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static void _fKeyringAESCiphertext(OssGlobal * _g, void * _data)
{
    _KeyringAESCiphertext	*_data_ptr;
    _data_ptr = (_KeyringAESCiphertext *)_data;
    if (_data_ptr) {
	    _oss_dec_free(_g, _data_ptr->ciphertext.value);
	    _oss_dec_free(_g, _data_ptr->salt.value);
    }
    _oss_dec_free(_g, _data_ptr);
}

static int _fmWAVE_Schema(struct ossGlobal * _g, int _pdunum, void * _data)
{
    if (_pdunum < 1 || _pdunum > 37)
	return PDU_RANGE;
    else
	_FreePDU[_pdunum - 1](_g, _data);

    return PDU_FREED;
}

#endif
#ifdef OSSPRINT
static void _p_WaveEntity(OssGlobal * _g, _WaveEntity * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "tbs ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "verifyingKey ");
	    _p_EntityPublicKey(_g, &_data_ptr->tbs.verifyingKey);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "keys ");
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    if (_data_ptr->tbs.keys) {
		_seqof4 * _tempa = _data_ptr->tbs.keys;
		_seqof4 * _tempb;
		while (_tempa) {
		    _tempb = _tempa->next;
		    _p_EntityPublicKey(_g, &_tempa->value);
		    _tempa = _tempb;
		    if (_tempa)
			ossPrint(_g, ",");
		}
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "validity ");
	    _p__seq5(_g, &_data_ptr->tbs.validity);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "revocations ");
	    _p__seqof1(_g, &_data_ptr->tbs.revocations);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "extensions ");
	    _p__seqof2(_g, &_data_ptr->tbs.extensions);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "signature ");
	_oss_prt_oct(_g, _data_ptr->signature.value, _data_ptr->signature.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_EntityKeyringEntry(OssGlobal * _g, _EntityKeyringEntry * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "public ");
	_p_EntityPublicKey(_g, &_data_ptr->EntityKeyringEntry_public);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "secret ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "type-id ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->secret.type_id.length;
		_e.value = _data_ptr->secret.type_id.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "value ");
	    _oss_prt_new_opentype(_g, _data_ptr->secret.value.pduNum, *(void **)&_data_ptr->secret.value.decoded, &_data_ptr->secret.value.encoded);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Hash(OssGlobal * _g, _Hash * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "type-id ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->type_id.length;
	    _e.value = _data_ptr->type_id.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "value ");
	_oss_prt_new_opentype(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded, &_data_ptr->value.encoded);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Location(OssGlobal * _g, _Location * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "type-id ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->type_id.length;
	    _e.value = _data_ptr->type_id.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "value ");
	_oss_prt_new_opentype(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded, &_data_ptr->value.encoded);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_Extension(OssGlobal * _g, _Extension * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "extnID ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->extnID.length;
	    _e.value = _data_ptr->extnID.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "critical ");
	ossPrint(_g, _data_ptr->critical ? "TRUE" : "FALSE");
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "value ");
	_oss_prt_oct(_g, _data_ptr->value.value, _data_ptr->value.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seqof1(OssGlobal * _g, _seqof1 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof1 * _tempa = *_data_ptr;
	_seqof1 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "critical ");
		ossPrint(_g, _tempa->value.critical ? "TRUE" : "FALSE");
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "scheme ");
		{
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "type-id ");
		    {
			OssBuf _val;
			OssEncodedOID _e;
			_val.length = 0;
			_val.value = NULL;
			_e.length = (unsigned short)_tempa->value.scheme.type_id.length;
			_e.value = _tempa->value.scheme.type_id.value;
			ossEncodedOidToAsnVal(_g, &_e, &_val);
			if (_val.length) {
			    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			    _oss_dec_free(_g, _val.value);
			} else
			    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		    }
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "value ");
		    _oss_prt_new_opentype(_g, _tempa->value.scheme.value.pduNum, *(void **)&_tempa->value.scheme.value.decoded, &_tempa->value.scheme.value.encoded);
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__seqof2(OssGlobal * _g, _seqof2 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof2 * _tempa = *_data_ptr;
	_seqof2 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _p_Extension(_g, &_tempa->value);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p__seq5(OssGlobal * _g, _seq5 * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "notBefore ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->notBefore == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->notBefore);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "notAfter ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->notAfter == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->notAfter);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p_AttestationVerifierBody(OssGlobal * _g, _AttestationVerifierBody * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "attester ");
	_p_Hash(_g, &_data_ptr->attester);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "attesterLocation ");
	_p_Location(_g, &_data_ptr->attesterLocation);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "validity ");
	_p__seq5(_g, &_data_ptr->validity);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "policy ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "type-id ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->policy.type_id.length;
		_e.value = _data_ptr->policy.type_id.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "value ");
	    _oss_prt_new_opentype(_g, _data_ptr->policy.value.pduNum, *(void **)&_data_ptr->policy.value.decoded, &_data_ptr->policy.value.encoded);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "extensions ");
	_p__seqof2(_g, &_data_ptr->extensions);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "outerSignatureBinding ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "type-id ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->outerSignatureBinding.type_id.length;
		_e.value = _data_ptr->outerSignatureBinding.type_id.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "value ");
	    _oss_prt_new_opentype(_g, _data_ptr->outerSignatureBinding.value.pduNum, *(void **)&_data_ptr->outerSignatureBinding.value.decoded, &_data_ptr->outerSignatureBinding.value.encoded);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seqof3(OssGlobal * _g, _seqof3 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof3 * _tempa = *_data_ptr;
	_seqof3 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "type-id ");
		{
		    OssBuf _val;
		    OssEncodedOID _e;
		    _val.length = 0;
		    _val.value = NULL;
		    _e.length = (unsigned short)_tempa->value.type_id.length;
		    _e.value = _tempa->value.type_id.value;
		    ossEncodedOidToAsnVal(_g, &_e, &_val);
		    if (_val.length) {
			ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			_oss_dec_free(_g, _val.value);
		    } else
			_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		}
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "value ");
		_oss_prt_new_opentype(_g, _tempa->value.value.pduNum, *(void **)&_tempa->value.value.decoded, &_tempa->value.value.encoded);
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static void _p_EntityPublicKey(OssGlobal * _g, _EntityPublicKey * _data_ptr)
{
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "capabilityFlags ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->capabilityFlags) {
	    _setof1 * _tempa = _data_ptr->capabilityFlags;
	    _setof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 0);
		{
		    LONG_LONG value = _tempa->value;

		    ossPrint(_g, LLONG_FMT, value);
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "key ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "type-id ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->key.type_id.length;
		_e.value = _data_ptr->key.type_id.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "value ");
	    _oss_prt_new_opentype(_g, _data_ptr->key.value.pduNum, *(void **)&_data_ptr->key.value.decoded, &_data_ptr->key.value.encoded);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

}

static void _p__seqof13(OssGlobal * _g, _seqof14 ** _data_ptr)
{
    _oss_indent(_g, 1);
    ossPrint(_g, "{");
    if (*_data_ptr) {
	_seqof14 * _tempa = *_data_ptr;
	_seqof14 * _tempb;
	while (_tempa) {
	    _tempb = _tempa->next;
	    _oss_indent(_g, 0);
	    _oss_prt_oct(_g, _tempa->value.value, _tempa->value.length);
	    _tempa = _tempb;
	    if (_tempa)
		ossPrint(_g, ",");
	}
    }
    _oss_indent(_g, -1);
    ossPrint(_g, "}");

}

static int _pWaveWireObject(OssGlobal * _g, void * _data)
{
    _WaveWireObject	*_data_ptr;
    _data_ptr = (_WaveWireObject *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "type-id ");
	{
	    OssBuf _val;
	    OssEncodedOID _e;
	    _val.length = 0;
	    _val.value = NULL;
	    _e.length = (unsigned short)_data_ptr->type_id.length;
	    _e.value = _data_ptr->type_id.value;
	    ossEncodedOidToAsnVal(_g, &_e, &_val);
	    if (_val.length) {
		ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		_oss_dec_free(_g, _val.value);
	    } else
		_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "value ");
	_oss_prt_new_opentype(_g, _data_ptr->value.pduNum, *(void **)&_data_ptr->value.decoded, &_data_ptr->value.encoded);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pWaveAttestation(OssGlobal * _g, void * _data)
{
    _WaveAttestation	*_data_ptr;
    _data_ptr = (_WaveAttestation *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "tbs ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subject ");
	    _p_Hash(_g, &_data_ptr->tbs.subject);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "subjectLocation ");
	    _p_Location(_g, &_data_ptr->tbs.subjectLocation);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "revocations ");
	    _p__seqof1(_g, &_data_ptr->tbs.revocations);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "publicExtensions ");
	    _p__seqof2(_g, &_data_ptr->tbs.publicExtensions);
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "body ");
	    {
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		_oss_indent(_g, 0);
		ossPrint(_g, "type-id ");
		{
		    OssBuf _val;
		    OssEncodedOID _e;
		    _val.length = 0;
		    _val.value = NULL;
		    _e.length = (unsigned short)_data_ptr->tbs.body.type_id.length;
		    _e.value = _data_ptr->tbs.body.type_id.value;
		    ossEncodedOidToAsnVal(_g, &_e, &_val);
		    if (_val.length) {
			ossPrint(_g, "%.*s", (int)_val.length, _val.value);
			_oss_dec_free(_g, _val.value);
		    } else
			_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
		}
		ossPrint(_g, ",");
		_oss_indent(_g, 0);
		ossPrint(_g, "value ");
		_oss_prt_new_opentype(_g, _data_ptr->tbs.body.value.pduNum, *(void **)&_data_ptr->tbs.body.value.decoded, &_data_ptr->tbs.body.value.encoded);
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
	    }
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "outerSignature ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "type-id ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->outerSignature.type_id.length;
		_e.value = _data_ptr->outerSignature.type_id.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "value ");
	    _oss_prt_new_opentype(_g, _data_ptr->outerSignature.value.pduNum, *(void **)&_data_ptr->outerSignature.value.decoded, &_data_ptr->outerSignature.value.encoded);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAttestationBody(OssGlobal * _g, void * _data)
{
    _AttestationBody	*_data_ptr;
    _data_ptr = (_AttestationBody *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "verifierBody ");
	_p_AttestationVerifierBody(_g, &_data_ptr->verifierBody);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "proverPolicyAddendums ");
	_p__seqof3(_g, &_data_ptr->proverPolicyAddendums);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "proverExtensions ");
	_p__seqof2(_g, &_data_ptr->proverExtensions);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pWaveEntity(OssGlobal * _g, void * _data)
{
    _WaveEntity	*_data_ptr;
    _data_ptr = (_WaveEntity *)_data;
    _p_WaveEntity(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pWaveEntitySecret(OssGlobal * _g, void * _data)
{
    _WaveEntitySecret	*_data_ptr;
    _data_ptr = (_WaveEntitySecret *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "entity ");
	_p_WaveEntity(_g, &_data_ptr->entity);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "keyring ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "type-id ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->keyring.type_id.length;
		_e.value = _data_ptr->keyring.type_id.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "value ");
	    _oss_prt_new_opentype(_g, _data_ptr->keyring.value.pduNum, *(void **)&_data_ptr->keyring.value.decoded, &_data_ptr->keyring.value.encoded);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pEntityKeyring(OssGlobal * _g, void * _data)
{
    _EntityKeyring	*_data_ptr;
    _data_ptr = (_EntityKeyring *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "keys ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->keys) {
	    _seqof5 * _tempa = _data_ptr->keys;
	    _seqof5 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_p_EntityKeyringEntry(_g, &_tempa->value);
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pEntityKeyringEntry(OssGlobal * _g, void * _data)
{
    _EntityKeyringEntry	*_data_ptr;
    _data_ptr = (_EntityKeyringEntry *)_data;
    _p_EntityKeyringEntry(_g, _data_ptr);

    return PDU_PRINTED;
}

static int _pWaveExplicitProof(OssGlobal * _g, void * _data)
{
    _WaveExplicitProof	*_data_ptr;
    _data_ptr = (_WaveExplicitProof *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "attestations ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->attestations) {
	    _seqof11 * _tempa = _data_ptr->attestations;
	    _seqof11 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		{
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "hash ");
		    _p_Hash(_g, &_tempa->value.hash);
		    if (_tempa->value.bit_mask & 0x80000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "content ");
			_oss_prt_oct(_g, _tempa->value.content.value, _tempa->value.content.length);
		    }
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "location ");
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_tempa->value.location) {
			_seqof6 * _temp1a = _tempa->value.location;
			_seqof6 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    _p_Location(_g, &_temp1a->value);
			    _temp1a = _temp1b;
			    if (_temp1a)
				ossPrint(_g, ",");
			}
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "keys ");
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_tempa->value.keys) {
			_seqof7 * _temp1a = _tempa->value.keys;
			_seqof7 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    {
				_oss_indent(_g, 1);
				ossPrint(_g, "{");
				_oss_indent(_g, 0);
				ossPrint(_g, "type-id ");
				{
				    OssBuf _val;
				    OssEncodedOID _e;
				    _val.length = 0;
				    _val.value = NULL;
				    _e.length = (unsigned short)_temp1a->value.type_id.length;
				    _e.value = _temp1a->value.type_id.value;
				    ossEncodedOidToAsnVal(_g, &_e, &_val);
				    if (_val.length) {
					ossPrint(_g, "%.*s", (int)_val.length, _val.value);
					_oss_dec_free(_g, _val.value);
				    } else
					_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
				}
				ossPrint(_g, ",");
				_oss_indent(_g, 0);
				ossPrint(_g, "value ");
				_oss_prt_new_opentype(_g, _temp1a->value.value.pduNum, *(void **)&_temp1a->value.value.decoded, &_temp1a->value.value.encoded);
				_oss_indent(_g, -1);
				ossPrint(_g, "}");
			    }
			    _temp1a = _temp1b;
			    if (_temp1a)
				ossPrint(_g, ",");
			}
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "revocationChecks ");
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_tempa->value.revocationChecks) {
			_seqof8 * _temp1a = _tempa->value.revocationChecks;
			_seqof8 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    {
				_oss_indent(_g, 1);
				ossPrint(_g, "{");
				_oss_indent(_g, 0);
				ossPrint(_g, "type-id ");
				{
				    OssBuf _val;
				    OssEncodedOID _e;
				    _val.length = 0;
				    _val.value = NULL;
				    _e.length = (unsigned short)_temp1a->value.type_id.length;
				    _e.value = _temp1a->value.type_id.value;
				    ossEncodedOidToAsnVal(_g, &_e, &_val);
				    if (_val.length) {
					ossPrint(_g, "%.*s", (int)_val.length, _val.value);
					_oss_dec_free(_g, _val.value);
				    } else
					_oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
				}
				ossPrint(_g, ",");
				_oss_indent(_g, 0);
				ossPrint(_g, "value ");
				_oss_prt_new_opentype(_g, _temp1a->value.value.pduNum, *(void **)&_temp1a->value.value.decoded, &_temp1a->value.value.encoded);
				_oss_indent(_g, -1);
				ossPrint(_g, "}");
			    }
			    _temp1a = _temp1b;
			    if (_temp1a)
				ossPrint(_g, ",");
			}
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "extensions ");
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_tempa->value.extensions) {
			_seqof2 * _temp1a = _tempa->value.extensions;
			_seqof2 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    _p_Extension(_g, &_temp1a->value);
			    _temp1a = _temp1b;
			    if (_temp1a)
				ossPrint(_g, ",");
			}
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "paths ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->paths) {
	    _seqof12 * _tempa = _data_ptr->paths;
	    _seqof12 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		_oss_indent(_g, 1);
		ossPrint(_g, "{");
		if (_tempa->value) {
		    _setof1 * _temp1a = _tempa->value;
		    _setof1 * _temp1b;
		    while (_temp1a) {
			_temp1b = _temp1a->next;
			_oss_indent(_g, 0);
			{
			    LONG_LONG value = _temp1a->value;

			    ossPrint(_g, LLONG_FMT, value);
			}
			_temp1a = _temp1b;
			if (_temp1a)
			    ossPrint(_g, ",");
		    }
		}
		_oss_indent(_g, -1);
		ossPrint(_g, "}");
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "entities ");
	_p__seqof13(_g, &_data_ptr->entities);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "extensions ");
	_p__seqof2(_g, &_data_ptr->extensions);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pRTreePolicy(OssGlobal * _g, void * _data)
{
    _RTreePolicy	*_data_ptr;
    _data_ptr = (_RTreePolicy *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "namespace ");
	_p_Hash(_g, &_data_ptr->RTreePolicy_namespace);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "indirections ");
	{
	    LONG_LONG value = _data_ptr->indirections;

	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "statements ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->statements) {
	    _seqof15 * _tempa = _data_ptr->statements;
	    _seqof15 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		{
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "permissionSet ");
		    _p_Hash(_g, &_tempa->value.permissionSet);
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "permissions ");
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    if (_tempa->value.permissions) {
			_seqof14 * _temp1a = _tempa->value.permissions;
			_seqof14 * _temp1b;
			while (_temp1a) {
			    _temp1b = _temp1a->next;
			    _oss_indent(_g, 0);
			    _oss_prt_mbchar(_g, (unsigned char *)_temp1a->value.value, _temp1a->value.length, 1);
			    _temp1a = _temp1b;
			    if (_temp1a)
				ossPrint(_g, ",");
			}
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "resource ");
		    _oss_prt_mbchar(_g, (unsigned char *)_tempa->value.resource.value, _tempa->value.resource.length, 1);
		    if (_tempa->value.bit_mask & 0x80000000) {
			ossPrint(_g, ",");
			_oss_indent(_g, 0);
			ossPrint(_g, "comment ");
			_oss_prt_mbchar(_g, (unsigned char *)_tempa->value.comment.value, _tempa->value.comment.length, 1);
		    }
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pHashSha3_256(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pHashSha_256(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pHashKeccak_256(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pLocationURL(OssGlobal * _g, void * _data)
{
    _LocationURL	*_data_ptr;
    _data_ptr = (_LocationURL *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "value ");
	_oss_prt_mbchar(_g, (unsigned char *)_data_ptr->value.value, _data_ptr->value.length, 1);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "apiVersion ");
	{
	    LONG_LONG value = _data_ptr->apiVersion;

	    ossPrint(_g, LLONG_FMT, value);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pLocationEthereum(OssGlobal * _g, void * _data)
{
    _LocationEthereum	*_data_ptr;
    _data_ptr = (_LocationEthereum *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "chainID ");
	{
	    LONG_LONG value = _data_ptr->chainID;

	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "contractAddress ");
	{
	    LONG_LONG value = _data_ptr->contractAddress;

	    ossPrint(_g, LLONG_FMT, value);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pPSKBodyCiphertext(OssGlobal * _g, void * _data)
{
    _PSKBodyCiphertext	*_data_ptr;
    _data_ptr = (_PSKBodyCiphertext *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "attestationBodyCiphertext ");
	_oss_prt_oct(_g, _data_ptr->attestationBodyCiphertext.value, _data_ptr->attestationBodyCiphertext.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "encryptedUnder ");
	_p_EntityPublicKey(_g, &_data_ptr->encryptedUnder);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pWR1BodyCiphertext(OssGlobal * _g, void * _data)
{
    _WR1BodyCiphertext	*_data_ptr;
    _data_ptr = (_WR1BodyCiphertext *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "verifierBodyCiphertext ");
	_oss_prt_oct(_g, _data_ptr->verifierBodyCiphertext.value, _data_ptr->verifierBodyCiphertext.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "proverBodyCiphertext ");
	_oss_prt_oct(_g, _data_ptr->proverBodyCiphertext.value, _data_ptr->proverBodyCiphertext.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "envelopeCiphertext ");
	_oss_prt_oct(_g, _data_ptr->envelopeCiphertext.value, _data_ptr->envelopeCiphertext.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "envelopeKey-ibe-bn256 ");
	_oss_prt_oct(_g, _data_ptr->envelopeKey_ibe_bn256.value, _data_ptr->envelopeKey_ibe_bn256.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "envelopeKey-curve25519 ");
	_oss_prt_oct(_g, _data_ptr->envelopeKey_curve25519.value, _data_ptr->envelopeKey_curve25519.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pWR1Envelope(OssGlobal * _g, void * _data)
{
    _WR1Envelope	*_data_ptr;
    _data_ptr = (_WR1Envelope *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "bodyKeys-oaque ");
	_oss_prt_oct(_g, _data_ptr->bodyKeys_oaque.value, _data_ptr->bodyKeys_oaque.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "partition ");
	_p__seqof13(_g, &_data_ptr->partition);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pWR1ProverBody(OssGlobal * _g, void * _data)
{
    _WR1ProverBody	*_data_ptr;
    _data_ptr = (_WR1ProverBody *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "addendums ");
	_p__seqof3(_g, &_data_ptr->addendums);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "extensions ");
	_p__seqof2(_g, &_data_ptr->extensions);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pWR1VerifierBody(OssGlobal * _g, void * _data)
{
    _WR1VerifierBody	*_data_ptr;
    _data_ptr = (_WR1VerifierBody *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "attestationVerifierBody ");
	_p_AttestationVerifierBody(_g, &_data_ptr->attestationVerifierBody);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pEd25519OuterSignature(OssGlobal * _g, void * _data)
{
    _Ed25519OuterSignature	*_data_ptr;
    _data_ptr = (_Ed25519OuterSignature *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "verifyingKey ");
	_oss_prt_oct(_g, _data_ptr->verifyingKey.value, _data_ptr->verifyingKey.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "signature ");
	_oss_prt_oct(_g, _data_ptr->signature.value, _data_ptr->signature.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pSignedOuterKey(OssGlobal * _g, void * _data)
{
    _SignedOuterKey	*_data_ptr;
    _data_ptr = (_SignedOuterKey *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "tbs ");
	{
	    _oss_indent(_g, 1);
	    ossPrint(_g, "{");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "outerSignatureScheme ");
	    {
		OssBuf _val;
		OssEncodedOID _e;
		_val.length = 0;
		_val.value = NULL;
		_e.length = (unsigned short)_data_ptr->tbs.outerSignatureScheme.length;
		_e.value = _data_ptr->tbs.outerSignatureScheme.value;
		ossEncodedOidToAsnVal(_g, &_e, &_val);
		if (_val.length) {
		    ossPrint(_g, "%.*s", (int)_val.length, _val.value);
		    _oss_dec_free(_g, _val.value);
		} else
		    _oss_prt_hex(_g, (char *)"'",(unsigned char *)_e.value, (long)_e.length, (char *)"'H");
	    }
	    ossPrint(_g, ",");
	    _oss_indent(_g, 0);
	    ossPrint(_g, "verifyingKey ");
	    _oss_prt_oct(_g, _data_ptr->tbs.verifyingKey.value, _data_ptr->tbs.verifyingKey.length);
	    _oss_indent(_g, -1);
	    ossPrint(_g, "}");
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "signature ");
	_oss_prt_oct(_g, _data_ptr->signature.value, _data_ptr->signature.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pTrustLevel(OssGlobal * _g, void * _data)
{
    _TrustLevel	*_data_ptr;
    _data_ptr = (_TrustLevel *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "trust ");
	{
	    ULONG_LONG value = _data_ptr->trust;
	    ossPrint(_g, ULLONG_FMT, value);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pCommitmentRevocationOption(OssGlobal * _g, void * _data)
{
    _CommitmentRevocationOption	*_data_ptr;
    _data_ptr = (_CommitmentRevocationOption *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "hash ");
	_p_Hash(_g, &_data_ptr->hash);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "location ");
	_p_Location(_g, &_data_ptr->location);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pAVKeyAES128_GCM(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPrivate_Ed25519(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPrivate_Curve25519(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPrivate_BN256_OAQUE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPrivate_BN256_IBE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pMaster_BN256_OAQUE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pMaster_BN256_IBE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPublic_Ed25519(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPublic_Curve25519(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPublic_OAQUE(OssGlobal * _g, void * _data)
{
    _Public_OAQUE	*_data_ptr;
    _data_ptr = (_Public_OAQUE *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "params ");
	_oss_prt_oct(_g, _data_ptr->params.value, _data_ptr->params.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "attributeset ");
	_p__seqof13(_g, &_data_ptr->attributeset);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pParams_BN256_OAQUE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pParams_BN256_IBE(OssGlobal * _g, void * _data)
{
    OSSC::COssString	*_data_ptr;
    _data_ptr = (OSSC::COssString *)_data;
    _oss_prt_oct(_g, _data_ptr->value, _data_ptr->length);

    return PDU_PRINTED;
}

static int _pPublic_BN256_IBE(OssGlobal * _g, void * _data)
{
    _Public_BN256_IBE	*_data_ptr;
    _data_ptr = (_Public_BN256_IBE *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "params ");
	_oss_prt_oct(_g, _data_ptr->params.value, _data_ptr->params.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "id ");
	_oss_prt_oct(_g, _data_ptr->id.value, _data_ptr->id.length);
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pKeyringAESCiphertext(OssGlobal * _g, void * _data)
{
    _KeyringAESCiphertext	*_data_ptr;
    _data_ptr = (_KeyringAESCiphertext *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "ciphertext ");
	_oss_prt_oct(_g, _data_ptr->ciphertext.value, _data_ptr->ciphertext.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "salt ");
	_oss_prt_oct(_g, _data_ptr->salt.value, _data_ptr->salt.length);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "iterations ");
	{
	    LONG_LONG value = _data_ptr->iterations;

	    ossPrint(_g, LLONG_FMT, value);
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

static int _pmWAVE_Schema(struct ossGlobal * _g, int _pdunum, void * _data)
{
    int _rc = _pdunum < 0;

    if (_rc)
	_pdunum = -_pdunum;
    if (_pdunum < 1 || _pdunum > 37 || !_PrintPDU[_pdunum - 1]._pf)
	return PDU_RANGE;
    else {
	if (_rc) {
	    ossPrint(_g, "%s : ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	} else {
	    ossPrint(_g, "value %s ::= ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	    ossPrint(_g, "\n");
	}
    }

    return _rc;
}

#endif

#ifdef OSS_COPY_VALUE
#define _oss_c ((_EncDecGlobals*)_g->encDecVar)

static _WaveEntity  * _cpWaveEntity(OssGlobal * _g, _WaveEntity  * psVal, _WaveEntity  * pdVal)
{
    if (!pdVal) {
	pdVal = (_WaveEntity  *)_oss_dec_const_alloc(_g, sizeof(_WaveEntity ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	{
	    _cpEntityPublicKey(_g, &(((*psVal).tbs).verifyingKey), &(((*pdVal).tbs).verifyingKey));
	}
	{
	    ((*pdVal).tbs).keys = NULL;
	    if (((*psVal).tbs).keys) {
		_seqof4 *  s_oss_tmp_3 = ((*psVal).tbs).keys;
		_seqof4 *  d_oss_tmp_3;

		((*pdVal).tbs).keys = d_oss_tmp_3 = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
		do {
		    memcpy(d_oss_tmp_3, s_oss_tmp_3, sizeof(_seqof4));
		    {
			_cpEntityPublicKey(_g, &(s_oss_tmp_3->value), &(d_oss_tmp_3->value));
		    }
		    if (s_oss_tmp_3->next)
			d_oss_tmp_3->next = (_seqof4 *)_oss_dec_getmem_internal(_g, sizeof(_seqof4));
		    s_oss_tmp_3 = s_oss_tmp_3->next;
		    d_oss_tmp_3 = d_oss_tmp_3->next;
		} while (s_oss_tmp_3);
	    }
	}
	{
	    _cp_seq5(_g, &(((*psVal).tbs).validity), &(((*pdVal).tbs).validity));
	}
	{
	    _cp_seqof1(_g, &(((*psVal).tbs).revocations), &(((*pdVal).tbs).revocations));
	}
	{
	    _cp_seqof2(_g, &(((*psVal).tbs).extensions), &(((*pdVal).tbs).extensions));
	}
    }
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).signature), &((*pdVal).signature), sizeof(((*pdVal).signature).length), sizeof(((*pdVal).signature).value[0]), (unsigned int)((char *)&((*psVal).signature).value - (char *)&((*psVal).signature)));
    }
    return pdVal;
}


static _EntityKeyringEntry  * _cpEntityKeyringEntry(OssGlobal * _g, _EntityKeyringEntry  * psVal, _EntityKeyringEntry  * pdVal)
{
    if (!pdVal) {
	pdVal = (_EntityKeyringEntry  *)_oss_dec_const_alloc(_g, sizeof(_EntityKeyringEntry ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpEntityPublicKey(_g, &((*psVal).EntityKeyringEntry_public), &((*pdVal).EntityKeyringEntry_public));
    }
    {
	{
	    _oss_cpy_unbnd_octet_ia(_g, &(((*psVal).secret).type_id), &(((*pdVal).secret).type_id), sizeof((((*pdVal).secret).type_id).length), sizeof((((*pdVal).secret).type_id).value[0]), (unsigned int)((char *)&(((*psVal).secret).type_id).value - (char *)&(((*psVal).secret).type_id)));
	}
	{
	    int         _pduNum = (((*psVal).secret).value).pduNum;
	    _oss_cpy_new_open_type(_g, &_pduNum, &(((*psVal).secret).value).encoded, &(((*pdVal).secret).value).encoded, *(void **)&(((*psVal).secret).value).decoded, (void **)&(((*pdVal).secret).value).decoded);
	    (((*pdVal).secret).value).pduNum = _pduNum;
	}
    }
    return pdVal;
}


static _Hash  * _cpHash(OssGlobal * _g, _Hash  * psVal, _Hash  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Hash  *)_oss_dec_const_alloc(_g, sizeof(_Hash ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).type_id), &((*pdVal).type_id), sizeof(((*pdVal).type_id).length), sizeof(((*pdVal).type_id).value[0]), (unsigned int)((char *)&((*psVal).type_id).value - (char *)&((*psVal).type_id)));
    }
    {
	int         _pduNum = ((*psVal).value).pduNum;
	_oss_cpy_new_open_type(_g, &_pduNum, &((*psVal).value).encoded, &((*pdVal).value).encoded, *(void **)&((*psVal).value).decoded, (void **)&((*pdVal).value).decoded);
	((*pdVal).value).pduNum = _pduNum;
    }
    return pdVal;
}


static _Location  * _cpLocation(OssGlobal * _g, _Location  * psVal, _Location  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Location  *)_oss_dec_const_alloc(_g, sizeof(_Location ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).type_id), &((*pdVal).type_id), sizeof(((*pdVal).type_id).length), sizeof(((*pdVal).type_id).value[0]), (unsigned int)((char *)&((*psVal).type_id).value - (char *)&((*psVal).type_id)));
    }
    {
	int         _pduNum = ((*psVal).value).pduNum;
	_oss_cpy_new_open_type(_g, &_pduNum, &((*psVal).value).encoded, &((*pdVal).value).encoded, *(void **)&((*psVal).value).decoded, (void **)&((*pdVal).value).decoded);
	((*pdVal).value).pduNum = _pduNum;
    }
    return pdVal;
}


static _Extension  * _cpExtension(OssGlobal * _g, _Extension  * psVal, _Extension  * pdVal)
{
    if (!pdVal) {
	pdVal = (_Extension  *)_oss_dec_const_alloc(_g, sizeof(_Extension ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).extnID), &((*pdVal).extnID), sizeof(((*pdVal).extnID).length), sizeof(((*pdVal).extnID).value[0]), (unsigned int)((char *)&((*psVal).extnID).value - (char *)&((*psVal).extnID)));
    }
    {
	_oss_cpy_unbnd_octet_ia(_g, &((*psVal).value), &((*pdVal).value), sizeof(((*pdVal).value).length), sizeof(((*pdVal).value).value[0]), (unsigned int)((char *)&((*psVal).value).value - (char *)&((*psVal).value)));
    }
    return pdVal;
}


static _seqof1 * * _cp_seqof1(OssGlobal * _g, _seqof1 * * psVal, _seqof1 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof1 * *)_oss_dec_const_alloc(_g, sizeof(_seqof1 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof1 *  s_oss_tmp_1 = *psVal;
	_seqof1 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_seqof1));
	    {
		{
		    {
			_oss_cpy_unbnd_octet_ia(_g, &(((s_oss_tmp_1->value).scheme).type_id), &(((d_oss_tmp_1->value).scheme).type_id), sizeof((((d_oss_tmp_1->value).scheme).type_id).length), sizeof((((d_oss_tmp_1->value).scheme).type_id).value[0]), (unsigned int)((char *)&(((s_oss_tmp_1->value).scheme).type_id).value - (char *)&(((s_oss_tmp_1->value).scheme).type_id)));
		    }
		    {
			int         _pduNum = (((s_oss_tmp_1->value).scheme).value).pduNum;
			_oss_cpy_new_open_type(_g, &_pduNum, &(((s_oss_tmp_1->value).scheme).value).encoded, &(((d_oss_tmp_1->value).scheme).value).encoded, *(void **)&(((s_oss_tmp_1->value).scheme).value).decoded, (void **)&(((d_oss_tmp_1->value).scheme).value).decoded);
			(((d_oss_tmp_1->value).scheme).value).pduNum = _pduNum;
		    }
		}
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _seqof2 * * _cp_seqof2(OssGlobal * _g, _seqof2 * * psVal, _seqof2 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof2 * *)_oss_dec_const_alloc(_g, sizeof(_seqof2 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof2 *  s_oss_tmp_1 = *psVal;
	_seqof2 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof2 *)_oss_dec_getmem_internal(_g, sizeof(_seqof2));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_seqof2));
	    {
		_cpExtension(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof2 *)_oss_dec_getmem_internal(_g, sizeof(_seqof2));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _seq5  * _cp_seq5(OssGlobal * _g, _seq5  * psVal, _seq5  * pdVal)
{
    if (!pdVal) {
	pdVal = (_seq5  *)_oss_dec_const_alloc(_g, sizeof(_seq5 ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).notBefore) + 1);

	(*pdVal).notBefore = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).notBefore, (*psVal).notBefore);
    }
    {
	size_t  len_1 = (size_t)sizeof(char) * (strlen((*psVal).notAfter) + 1);

	(*pdVal).notAfter = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
	strcpy((*pdVal).notAfter, (*psVal).notAfter);
    }
    return pdVal;
}


static _AttestationVerifierBody  * _cpAttestationVerifierBody(OssGlobal * _g, _AttestationVerifierBody  * psVal, _AttestationVerifierBody  * pdVal)
{
    if (!pdVal) {
	pdVal = (_AttestationVerifierBody  *)_oss_dec_const_alloc(_g, sizeof(_AttestationVerifierBody ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_cpHash(_g, &((*psVal).attester), &((*pdVal).attester));
    }
    {
	_cpLocation(_g, &((*psVal).attesterLocation), &((*pdVal).attesterLocation));
    }
    {
	_cp_seq5(_g, &((*psVal).validity), &((*pdVal).validity));
    }
    {
	{
	    _oss_cpy_unbnd_octet_ia(_g, &(((*psVal).policy).type_id), &(((*pdVal).policy).type_id), sizeof((((*pdVal).policy).type_id).length), sizeof((((*pdVal).policy).type_id).value[0]), (unsigned int)((char *)&(((*psVal).policy).type_id).value - (char *)&(((*psVal).policy).type_id)));
	}
	{
	    int         _pduNum = (((*psVal).policy).value).pduNum;
	    _oss_cpy_new_open_type(_g, &_pduNum, &(((*psVal).policy).value).encoded, &(((*pdVal).policy).value).encoded, *(void **)&(((*psVal).policy).value).decoded, (void **)&(((*pdVal).policy).value).decoded);
	    (((*pdVal).policy).value).pduNum = _pduNum;
	}
    }
    {
	_cp_seqof2(_g, &((*psVal).extensions), &((*pdVal).extensions));
    }
    {
	{
	    _oss_cpy_unbnd_octet_ia(_g, &(((*psVal).outerSignatureBinding).type_id), &(((*pdVal).outerSignatureBinding).type_id), sizeof((((*pdVal).outerSignatureBinding).type_id).length), sizeof((((*pdVal).outerSignatureBinding).type_id).value[0]), (unsigned int)((char *)&(((*psVal).outerSignatureBinding).type_id).value - (char *)&(((*psVal).outerSignatureBinding).type_id)));
	}
	{
	    int         _pduNum = (((*psVal).outerSignatureBinding).value).pduNum;
	    _oss_cpy_new_open_type(_g, &_pduNum, &(((*psVal).outerSignatureBinding).value).encoded, &(((*pdVal).outerSignatureBinding).value).encoded, *(void **)&(((*psVal).outerSignatureBinding).value).decoded, (void **)&(((*pdVal).outerSignatureBinding).value).decoded);
	    (((*pdVal).outerSignatureBinding).value).pduNum = _pduNum;
	}
    }
    return pdVal;
}


static _seqof3 * * _cp_seqof3(OssGlobal * _g, _seqof3 * * psVal, _seqof3 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof3 * *)_oss_dec_const_alloc(_g, sizeof(_seqof3 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof3 *  s_oss_tmp_1 = *psVal;
	_seqof3 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof3 *)_oss_dec_getmem_internal(_g, sizeof(_seqof3));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_seqof3));
	    {
		{
		    _oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_1->value).type_id), &((d_oss_tmp_1->value).type_id), sizeof(((d_oss_tmp_1->value).type_id).length), sizeof(((d_oss_tmp_1->value).type_id).value[0]), (unsigned int)((char *)&((s_oss_tmp_1->value).type_id).value - (char *)&((s_oss_tmp_1->value).type_id)));
		}
		{
		    int         _pduNum = ((s_oss_tmp_1->value).value).pduNum;
		    _oss_cpy_new_open_type(_g, &_pduNum, &((s_oss_tmp_1->value).value).encoded, &((d_oss_tmp_1->value).value).encoded, *(void **)&((s_oss_tmp_1->value).value).decoded, (void **)&((d_oss_tmp_1->value).value).decoded);
		    ((d_oss_tmp_1->value).value).pduNum = _pduNum;
		}
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof3 *)_oss_dec_getmem_internal(_g, sizeof(_seqof3));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static _EntityPublicKey  * _cpEntityPublicKey(OssGlobal * _g, _EntityPublicKey  * psVal, _EntityPublicKey  * pdVal)
{
    if (!pdVal) {
	pdVal = (_EntityPublicKey  *)_oss_dec_const_alloc(_g, sizeof(_EntityPublicKey ));
    }
    memcpy(pdVal, psVal, sizeof(*pdVal));
    {
	_oss_cpy_link_obj(_g, (void**)(&((*psVal).capabilityFlags)), (void**)(&((*pdVal).capabilityFlags)), sizeof(_setof1));
    }
    {
	{
	    _oss_cpy_unbnd_octet_ia(_g, &(((*psVal).key).type_id), &(((*pdVal).key).type_id), sizeof((((*pdVal).key).type_id).length), sizeof((((*pdVal).key).type_id).value[0]), (unsigned int)((char *)&(((*psVal).key).type_id).value - (char *)&(((*psVal).key).type_id)));
	}
	{
	    int         _pduNum = (((*psVal).key).value).pduNum;
	    _oss_cpy_new_open_type(_g, &_pduNum, &(((*psVal).key).value).encoded, &(((*pdVal).key).value).encoded, *(void **)&(((*psVal).key).value).decoded, (void **)&(((*pdVal).key).value).decoded);
	    (((*pdVal).key).value).pduNum = _pduNum;
	}
    }
    return pdVal;
}


static _seqof14 * * _cp_seqof13(OssGlobal * _g, _seqof14 * * psVal, _seqof14 * * pdVal)
{
    if (!pdVal) {
	pdVal = (_seqof14 * *)_oss_dec_const_alloc(_g, sizeof(_seqof14 *));
    }
    *pdVal = NULL;
    if (*psVal) {
	_seqof14 *  s_oss_tmp_1 = *psVal;
	_seqof14 *  d_oss_tmp_1;

	*pdVal = d_oss_tmp_1 = (_seqof14 *)_oss_dec_getmem_internal(_g, sizeof(_seqof14));
	do {
	    memcpy(d_oss_tmp_1, s_oss_tmp_1, sizeof(_seqof14));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_1->value), &(d_oss_tmp_1->value), sizeof((d_oss_tmp_1->value).length), sizeof((d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_1->value).value - (char *)&(s_oss_tmp_1->value)));
	    }
	    if (s_oss_tmp_1->next)
		d_oss_tmp_1->next = (_seqof14 *)_oss_dec_getmem_internal(_g, sizeof(_seqof14));
	    s_oss_tmp_1 = s_oss_tmp_1->next;
	    d_oss_tmp_1 = d_oss_tmp_1->next;
	} while (s_oss_tmp_1);
    }
    return pdVal;
}


static int _CPWAVE_Schema(struct ossGlobal * _g, int pduNum, void * src, void ** pdst)
{
    int res = 0;
    void *pdVal = NULL;

    if (pduNum <= 0 || pduNum > 38)
	return PDU_RANGE;
    switch (pduNum) {
	case 1: {
	    pdVal = (_WaveWireObject  *)_oss_dec_const_alloc(_g, sizeof(_WaveWireObject ));
	    memcpy((_WaveWireObject  *)pdVal, (_WaveWireObject  *)src, sizeof(*(_WaveWireObject  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_WaveWireObject  *)src).type_id), &((*(_WaveWireObject  *)pdVal).type_id), sizeof(((*(_WaveWireObject  *)pdVal).type_id).length), sizeof(((*(_WaveWireObject  *)pdVal).type_id).value[0]), (unsigned int)((char *)&((*(_WaveWireObject  *)src).type_id).value - (char *)&((*(_WaveWireObject  *)src).type_id)));
	    }
	    {
		int         _pduNum = ((*(_WaveWireObject  *)src).value).pduNum;
		_oss_cpy_new_open_type(_g, &_pduNum, &((*(_WaveWireObject  *)src).value).encoded, &((*(_WaveWireObject  *)pdVal).value).encoded, *(void **)&((*(_WaveWireObject  *)src).value).decoded, (void **)&((*(_WaveWireObject  *)pdVal).value).decoded);
		((*(_WaveWireObject  *)pdVal).value).pduNum = _pduNum;
	    }
	} break;
	case 2: {
	    pdVal = (_WaveAttestation  *)_oss_dec_const_alloc(_g, sizeof(_WaveAttestation ));
	    memcpy((_WaveAttestation  *)pdVal, (_WaveAttestation  *)src, sizeof(*(_WaveAttestation  *)pdVal));
	    {
		{
		    _cpHash(_g, &(((*(_WaveAttestation  *)src).tbs).subject), &(((*(_WaveAttestation  *)pdVal).tbs).subject));
		}
		{
		    _cpLocation(_g, &(((*(_WaveAttestation  *)src).tbs).subjectLocation), &(((*(_WaveAttestation  *)pdVal).tbs).subjectLocation));
		}
		{
		    _cp_seqof1(_g, &(((*(_WaveAttestation  *)src).tbs).revocations), &(((*(_WaveAttestation  *)pdVal).tbs).revocations));
		}
		{
		    _cp_seqof2(_g, &(((*(_WaveAttestation  *)src).tbs).publicExtensions), &(((*(_WaveAttestation  *)pdVal).tbs).publicExtensions));
		}
		{
		    {
			_oss_cpy_unbnd_octet_ia(_g, &((((*(_WaveAttestation  *)src).tbs).body).type_id), &((((*(_WaveAttestation  *)pdVal).tbs).body).type_id), sizeof(((((*(_WaveAttestation  *)pdVal).tbs).body).type_id).length), sizeof(((((*(_WaveAttestation  *)pdVal).tbs).body).type_id).value[0]), (unsigned int)((char *)&((((*(_WaveAttestation  *)src).tbs).body).type_id).value - (char *)&((((*(_WaveAttestation  *)src).tbs).body).type_id)));
		    }
		    {
			int         _pduNum = ((((*(_WaveAttestation  *)src).tbs).body).value).pduNum;
			_oss_cpy_new_open_type(_g, &_pduNum, &((((*(_WaveAttestation  *)src).tbs).body).value).encoded, &((((*(_WaveAttestation  *)pdVal).tbs).body).value).encoded, *(void **)&((((*(_WaveAttestation  *)src).tbs).body).value).decoded, (void **)&((((*(_WaveAttestation  *)pdVal).tbs).body).value).decoded);
			((((*(_WaveAttestation  *)pdVal).tbs).body).value).pduNum = _pduNum;
		    }
		}
	    }
	    {
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_WaveAttestation  *)src).outerSignature).type_id), &(((*(_WaveAttestation  *)pdVal).outerSignature).type_id), sizeof((((*(_WaveAttestation  *)pdVal).outerSignature).type_id).length), sizeof((((*(_WaveAttestation  *)pdVal).outerSignature).type_id).value[0]), (unsigned int)((char *)&(((*(_WaveAttestation  *)src).outerSignature).type_id).value - (char *)&(((*(_WaveAttestation  *)src).outerSignature).type_id)));
		}
		{
		    int         _pduNum = (((*(_WaveAttestation  *)src).outerSignature).value).pduNum;
		    _oss_cpy_new_open_type(_g, &_pduNum, &(((*(_WaveAttestation  *)src).outerSignature).value).encoded, &(((*(_WaveAttestation  *)pdVal).outerSignature).value).encoded, *(void **)&(((*(_WaveAttestation  *)src).outerSignature).value).decoded, (void **)&(((*(_WaveAttestation  *)pdVal).outerSignature).value).decoded);
		    (((*(_WaveAttestation  *)pdVal).outerSignature).value).pduNum = _pduNum;
		}
	    }
	} break;
	case 3: {
	    pdVal = (_AttestationBody  *)_oss_dec_const_alloc(_g, sizeof(_AttestationBody ));
	    memcpy((_AttestationBody  *)pdVal, (_AttestationBody  *)src, sizeof(*(_AttestationBody  *)pdVal));
	    {
		_cpAttestationVerifierBody(_g, &((*(_AttestationBody  *)src).verifierBody), &((*(_AttestationBody  *)pdVal).verifierBody));
	    }
	    {
		_cp_seqof3(_g, &((*(_AttestationBody  *)src).proverPolicyAddendums), &((*(_AttestationBody  *)pdVal).proverPolicyAddendums));
	    }
	    {
		_cp_seqof2(_g, &((*(_AttestationBody  *)src).proverExtensions), &((*(_AttestationBody  *)pdVal).proverExtensions));
	    }
	} break;
	case 4: {
	    pdVal = _cpWaveEntity(_g, (_WaveEntity  *)src, (_WaveEntity  *)pdVal);
	} break;
	case 5: {
	    pdVal = (_WaveEntitySecret  *)_oss_dec_const_alloc(_g, sizeof(_WaveEntitySecret ));
	    memcpy((_WaveEntitySecret  *)pdVal, (_WaveEntitySecret  *)src, sizeof(*(_WaveEntitySecret  *)pdVal));
	    {
		_cpWaveEntity(_g, &((*(_WaveEntitySecret  *)src).entity), &((*(_WaveEntitySecret  *)pdVal).entity));
	    }
	    {
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_WaveEntitySecret  *)src).keyring).type_id), &(((*(_WaveEntitySecret  *)pdVal).keyring).type_id), sizeof((((*(_WaveEntitySecret  *)pdVal).keyring).type_id).length), sizeof((((*(_WaveEntitySecret  *)pdVal).keyring).type_id).value[0]), (unsigned int)((char *)&(((*(_WaveEntitySecret  *)src).keyring).type_id).value - (char *)&(((*(_WaveEntitySecret  *)src).keyring).type_id)));
		}
		{
		    int         _pduNum = (((*(_WaveEntitySecret  *)src).keyring).value).pduNum;
		    _oss_cpy_new_open_type(_g, &_pduNum, &(((*(_WaveEntitySecret  *)src).keyring).value).encoded, &(((*(_WaveEntitySecret  *)pdVal).keyring).value).encoded, *(void **)&(((*(_WaveEntitySecret  *)src).keyring).value).decoded, (void **)&(((*(_WaveEntitySecret  *)pdVal).keyring).value).decoded);
		    (((*(_WaveEntitySecret  *)pdVal).keyring).value).pduNum = _pduNum;
		}
	    }
	} break;
	case 6: {
	    pdVal = (_EntityKeyring  *)_oss_dec_const_alloc(_g, sizeof(_EntityKeyring ));
	    memcpy((_EntityKeyring  *)pdVal, (_EntityKeyring  *)src, sizeof(*(_EntityKeyring  *)pdVal));
	    {
		(*(_EntityKeyring  *)pdVal).keys = NULL;
		if ((*(_EntityKeyring  *)src).keys) {
		    _seqof5 *  s_oss_tmp_2 = (*(_EntityKeyring  *)src).keys;
		    _seqof5 *  d_oss_tmp_2;

		    (*(_EntityKeyring  *)pdVal).keys = d_oss_tmp_2 = (_seqof5 *)_oss_dec_getmem_internal(_g, sizeof(_seqof5));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_seqof5));
			{
			    _cpEntityKeyringEntry(_g, &(s_oss_tmp_2->value), &(d_oss_tmp_2->value));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof5 *)_oss_dec_getmem_internal(_g, sizeof(_seqof5));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 7: {
	    pdVal = _cpEntityKeyringEntry(_g, (_EntityKeyringEntry  *)src, (_EntityKeyringEntry  *)pdVal);
	} break;
	case 8: {
	    pdVal = (_WaveExplicitProof  *)_oss_dec_const_alloc(_g, sizeof(_WaveExplicitProof ));
	    memcpy((_WaveExplicitProof  *)pdVal, (_WaveExplicitProof  *)src, sizeof(*(_WaveExplicitProof  *)pdVal));
	    {
		(*(_WaveExplicitProof  *)pdVal).attestations = NULL;
		if ((*(_WaveExplicitProof  *)src).attestations) {
		    _seqof11 *  s_oss_tmp_2 = (*(_WaveExplicitProof  *)src).attestations;
		    _seqof11 *  d_oss_tmp_2;

		    (*(_WaveExplicitProof  *)pdVal).attestations = d_oss_tmp_2 = (_seqof11 *)_oss_dec_getmem_internal(_g, sizeof(_seqof11));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_seqof11));
			{
			    {
				_cpHash(_g, &((s_oss_tmp_2->value).hash), &((d_oss_tmp_2->value).hash));
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x80000000) {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).content), &((d_oss_tmp_2->value).content), sizeof(((d_oss_tmp_2->value).content).length), sizeof(((d_oss_tmp_2->value).content).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).content).value - (char *)&((s_oss_tmp_2->value).content)));
			    }
			    {
				_seqof6 * * src_3 = &((s_oss_tmp_2->value).location);
				_seqof6 * * dst_3 = &((d_oss_tmp_2->value).location);

				*dst_3 = NULL;
				if (*src_3) {
				    _seqof6 *  s_oss_tmp_4 = *src_3;
				    _seqof6 *  d_oss_tmp_4;

				    *dst_3 = d_oss_tmp_4 = (_seqof6 *)_oss_dec_getmem_internal(_g, sizeof(_seqof6));
				    do {
					memcpy(d_oss_tmp_4, s_oss_tmp_4, sizeof(_seqof6));
					{
					    _cpLocation(_g, &(s_oss_tmp_4->value), &(d_oss_tmp_4->value));
					}
					if (s_oss_tmp_4->next)
					    d_oss_tmp_4->next = (_seqof6 *)_oss_dec_getmem_internal(_g, sizeof(_seqof6));
					s_oss_tmp_4 = s_oss_tmp_4->next;
					d_oss_tmp_4 = d_oss_tmp_4->next;
				    } while (s_oss_tmp_4);
				}
			    }
			    {
				_seqof7 * * src_3 = &((s_oss_tmp_2->value).keys);
				_seqof7 * * dst_3 = &((d_oss_tmp_2->value).keys);

				*dst_3 = NULL;
				if (*src_3) {
				    _seqof7 *  s_oss_tmp_4 = *src_3;
				    _seqof7 *  d_oss_tmp_4;

				    *dst_3 = d_oss_tmp_4 = (_seqof7 *)_oss_dec_getmem_internal(_g, sizeof(_seqof7));
				    do {
					memcpy(d_oss_tmp_4, s_oss_tmp_4, sizeof(_seqof7));
					{
					    {
						_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_4->value).type_id), &((d_oss_tmp_4->value).type_id), sizeof(((d_oss_tmp_4->value).type_id).length), sizeof(((d_oss_tmp_4->value).type_id).value[0]), (unsigned int)((char *)&((s_oss_tmp_4->value).type_id).value - (char *)&((s_oss_tmp_4->value).type_id)));
					    }
					    {
						int         _pduNum = ((s_oss_tmp_4->value).value).pduNum;
						_oss_cpy_new_open_type(_g, &_pduNum, &((s_oss_tmp_4->value).value).encoded, &((d_oss_tmp_4->value).value).encoded, *(void **)&((s_oss_tmp_4->value).value).decoded, (void **)&((d_oss_tmp_4->value).value).decoded);
						((d_oss_tmp_4->value).value).pduNum = _pduNum;
					    }
					}
					if (s_oss_tmp_4->next)
					    d_oss_tmp_4->next = (_seqof7 *)_oss_dec_getmem_internal(_g, sizeof(_seqof7));
					s_oss_tmp_4 = s_oss_tmp_4->next;
					d_oss_tmp_4 = d_oss_tmp_4->next;
				    } while (s_oss_tmp_4);
				}
			    }
			    {
				_seqof8 * * src_3 = &((s_oss_tmp_2->value).revocationChecks);
				_seqof8 * * dst_3 = &((d_oss_tmp_2->value).revocationChecks);

				*dst_3 = NULL;
				if (*src_3) {
				    _seqof8 *  s_oss_tmp_4 = *src_3;
				    _seqof8 *  d_oss_tmp_4;

				    *dst_3 = d_oss_tmp_4 = (_seqof8 *)_oss_dec_getmem_internal(_g, sizeof(_seqof8));
				    do {
					memcpy(d_oss_tmp_4, s_oss_tmp_4, sizeof(_seqof8));
					{
					    {
						_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_4->value).type_id), &((d_oss_tmp_4->value).type_id), sizeof(((d_oss_tmp_4->value).type_id).length), sizeof(((d_oss_tmp_4->value).type_id).value[0]), (unsigned int)((char *)&((s_oss_tmp_4->value).type_id).value - (char *)&((s_oss_tmp_4->value).type_id)));
					    }
					    {
						int         _pduNum = ((s_oss_tmp_4->value).value).pduNum;
						_oss_cpy_new_open_type(_g, &_pduNum, &((s_oss_tmp_4->value).value).encoded, &((d_oss_tmp_4->value).value).encoded, *(void **)&((s_oss_tmp_4->value).value).decoded, (void **)&((d_oss_tmp_4->value).value).decoded);
						((d_oss_tmp_4->value).value).pduNum = _pduNum;
					    }
					}
					if (s_oss_tmp_4->next)
					    d_oss_tmp_4->next = (_seqof8 *)_oss_dec_getmem_internal(_g, sizeof(_seqof8));
					s_oss_tmp_4 = s_oss_tmp_4->next;
					d_oss_tmp_4 = d_oss_tmp_4->next;
				    } while (s_oss_tmp_4);
				}
			    }
			    {
				_seqof2 * * src_3 = &((s_oss_tmp_2->value).extensions);
				_seqof2 * * dst_3 = &((d_oss_tmp_2->value).extensions);

				*dst_3 = NULL;
				if (*src_3) {
				    _seqof2 *  s_oss_tmp_4 = *src_3;
				    _seqof2 *  d_oss_tmp_4;

				    *dst_3 = d_oss_tmp_4 = (_seqof2 *)_oss_dec_getmem_internal(_g, sizeof(_seqof2));
				    do {
					memcpy(d_oss_tmp_4, s_oss_tmp_4, sizeof(_seqof2));
					{
					    _cpExtension(_g, &(s_oss_tmp_4->value), &(d_oss_tmp_4->value));
					}
					if (s_oss_tmp_4->next)
					    d_oss_tmp_4->next = (_seqof2 *)_oss_dec_getmem_internal(_g, sizeof(_seqof2));
					s_oss_tmp_4 = s_oss_tmp_4->next;
					d_oss_tmp_4 = d_oss_tmp_4->next;
				    } while (s_oss_tmp_4);
				}
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof11 *)_oss_dec_getmem_internal(_g, sizeof(_seqof11));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    {
		(*(_WaveExplicitProof  *)pdVal).paths = NULL;
		if ((*(_WaveExplicitProof  *)src).paths) {
		    _seqof12 *  s_oss_tmp_2 = (*(_WaveExplicitProof  *)src).paths;
		    _seqof12 *  d_oss_tmp_2;

		    (*(_WaveExplicitProof  *)pdVal).paths = d_oss_tmp_2 = (_seqof12 *)_oss_dec_getmem_internal(_g, sizeof(_seqof12));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_seqof12));
			{
			    _oss_cpy_link_obj(_g, (void**)(&(s_oss_tmp_2->value)), (void**)(&(d_oss_tmp_2->value)), sizeof(_setof1));
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof12 *)_oss_dec_getmem_internal(_g, sizeof(_seqof12));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	    {
		_cp_seqof13(_g, &((*(_WaveExplicitProof  *)src).entities), &((*(_WaveExplicitProof  *)pdVal).entities));
	    }
	    {
		_cp_seqof2(_g, &((*(_WaveExplicitProof  *)src).extensions), &((*(_WaveExplicitProof  *)pdVal).extensions));
	    }
	} break;
	case 9: {
	    pdVal = (_RTreePolicy  *)_oss_dec_const_alloc(_g, sizeof(_RTreePolicy ));
	    memcpy((_RTreePolicy  *)pdVal, (_RTreePolicy  *)src, sizeof(*(_RTreePolicy  *)pdVal));
	    {
		_cpHash(_g, &((*(_RTreePolicy  *)src).RTreePolicy_namespace), &((*(_RTreePolicy  *)pdVal).RTreePolicy_namespace));
	    }
	    {
		(*(_RTreePolicy  *)pdVal).statements = NULL;
		if ((*(_RTreePolicy  *)src).statements) {
		    _seqof15 *  s_oss_tmp_2 = (*(_RTreePolicy  *)src).statements;
		    _seqof15 *  d_oss_tmp_2;

		    (*(_RTreePolicy  *)pdVal).statements = d_oss_tmp_2 = (_seqof15 *)_oss_dec_getmem_internal(_g, sizeof(_seqof15));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_seqof15));
			{
			    {
				_cpHash(_g, &((s_oss_tmp_2->value).permissionSet), &((d_oss_tmp_2->value).permissionSet));
			    }
			    {
				_seqof14 * * src_3 = &((s_oss_tmp_2->value).permissions);
				_seqof14 * * dst_3 = &((d_oss_tmp_2->value).permissions);

				*dst_3 = NULL;
				if (*src_3) {
				    _seqof14 *  s_oss_tmp_4 = *src_3;
				    _seqof14 *  d_oss_tmp_4;

				    *dst_3 = d_oss_tmp_4 = (_seqof14 *)_oss_dec_getmem_internal(_g, sizeof(_seqof14));
				    do {
					memcpy(d_oss_tmp_4, s_oss_tmp_4, sizeof(_seqof14));
					{
					    _oss_cpy_unbnd_octet_ia(_g, &(s_oss_tmp_4->value), &(d_oss_tmp_4->value), sizeof((d_oss_tmp_4->value).length), sizeof((d_oss_tmp_4->value).value[0]), (unsigned int)((char *)&(s_oss_tmp_4->value).value - (char *)&(s_oss_tmp_4->value)));
					}
					if (s_oss_tmp_4->next)
					    d_oss_tmp_4->next = (_seqof14 *)_oss_dec_getmem_internal(_g, sizeof(_seqof14));
					s_oss_tmp_4 = s_oss_tmp_4->next;
					d_oss_tmp_4 = d_oss_tmp_4->next;
				    } while (s_oss_tmp_4);
				}
			    }
			    {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).resource), &((d_oss_tmp_2->value).resource), sizeof(((d_oss_tmp_2->value).resource).length), sizeof(((d_oss_tmp_2->value).resource).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).resource).value - (char *)&((s_oss_tmp_2->value).resource)));
			    }
			    if ((s_oss_tmp_2->value).bit_mask & 0x80000000) {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).comment), &((d_oss_tmp_2->value).comment), sizeof(((d_oss_tmp_2->value).comment).length), sizeof(((d_oss_tmp_2->value).comment).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).comment).value - (char *)&((s_oss_tmp_2->value).comment)));
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof15 *)_oss_dec_getmem_internal(_g, sizeof(_seqof15));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	case 10: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 11: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 12: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 13: {
	    pdVal = (_LocationURL  *)_oss_dec_const_alloc(_g, sizeof(_LocationURL ));
	    memcpy((_LocationURL  *)pdVal, (_LocationURL  *)src, sizeof(*(_LocationURL  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_LocationURL  *)src).value), &((*(_LocationURL  *)pdVal).value), sizeof(((*(_LocationURL  *)pdVal).value).length), sizeof(((*(_LocationURL  *)pdVal).value).value[0]), (unsigned int)((char *)&((*(_LocationURL  *)src).value).value - (char *)&((*(_LocationURL  *)src).value)));
	    }
	} break;
	case 14: {
	    pdVal = (_LocationEthereum  *)_oss_dec_const_alloc(_g, sizeof(_LocationEthereum ));
	    memcpy((_LocationEthereum  *)pdVal, (_LocationEthereum  *)src, sizeof(*(_LocationEthereum  *)pdVal));
	} break;
	case 15: {
	    pdVal = (_PSKBodyCiphertext  *)_oss_dec_const_alloc(_g, sizeof(_PSKBodyCiphertext ));
	    memcpy((_PSKBodyCiphertext  *)pdVal, (_PSKBodyCiphertext  *)src, sizeof(*(_PSKBodyCiphertext  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_PSKBodyCiphertext  *)src).attestationBodyCiphertext), &((*(_PSKBodyCiphertext  *)pdVal).attestationBodyCiphertext), sizeof(((*(_PSKBodyCiphertext  *)pdVal).attestationBodyCiphertext).length), sizeof(((*(_PSKBodyCiphertext  *)pdVal).attestationBodyCiphertext).value[0]), (unsigned int)((char *)&((*(_PSKBodyCiphertext  *)src).attestationBodyCiphertext).value - (char *)&((*(_PSKBodyCiphertext  *)src).attestationBodyCiphertext)));
	    }
	    {
		_cpEntityPublicKey(_g, &((*(_PSKBodyCiphertext  *)src).encryptedUnder), &((*(_PSKBodyCiphertext  *)pdVal).encryptedUnder));
	    }
	} break;
	case 16: {
	    pdVal = (_WR1BodyCiphertext  *)_oss_dec_const_alloc(_g, sizeof(_WR1BodyCiphertext ));
	    memcpy((_WR1BodyCiphertext  *)pdVal, (_WR1BodyCiphertext  *)src, sizeof(*(_WR1BodyCiphertext  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_WR1BodyCiphertext  *)src).verifierBodyCiphertext), &((*(_WR1BodyCiphertext  *)pdVal).verifierBodyCiphertext), sizeof(((*(_WR1BodyCiphertext  *)pdVal).verifierBodyCiphertext).length), sizeof(((*(_WR1BodyCiphertext  *)pdVal).verifierBodyCiphertext).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)src).verifierBodyCiphertext).value - (char *)&((*(_WR1BodyCiphertext  *)src).verifierBodyCiphertext)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_WR1BodyCiphertext  *)src).proverBodyCiphertext), &((*(_WR1BodyCiphertext  *)pdVal).proverBodyCiphertext), sizeof(((*(_WR1BodyCiphertext  *)pdVal).proverBodyCiphertext).length), sizeof(((*(_WR1BodyCiphertext  *)pdVal).proverBodyCiphertext).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)src).proverBodyCiphertext).value - (char *)&((*(_WR1BodyCiphertext  *)src).proverBodyCiphertext)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_WR1BodyCiphertext  *)src).envelopeCiphertext), &((*(_WR1BodyCiphertext  *)pdVal).envelopeCiphertext), sizeof(((*(_WR1BodyCiphertext  *)pdVal).envelopeCiphertext).length), sizeof(((*(_WR1BodyCiphertext  *)pdVal).envelopeCiphertext).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)src).envelopeCiphertext).value - (char *)&((*(_WR1BodyCiphertext  *)src).envelopeCiphertext)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_WR1BodyCiphertext  *)src).envelopeKey_ibe_bn256), &((*(_WR1BodyCiphertext  *)pdVal).envelopeKey_ibe_bn256), sizeof(((*(_WR1BodyCiphertext  *)pdVal).envelopeKey_ibe_bn256).length), sizeof(((*(_WR1BodyCiphertext  *)pdVal).envelopeKey_ibe_bn256).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)src).envelopeKey_ibe_bn256).value - (char *)&((*(_WR1BodyCiphertext  *)src).envelopeKey_ibe_bn256)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_WR1BodyCiphertext  *)src).envelopeKey_curve25519), &((*(_WR1BodyCiphertext  *)pdVal).envelopeKey_curve25519), sizeof(((*(_WR1BodyCiphertext  *)pdVal).envelopeKey_curve25519).length), sizeof(((*(_WR1BodyCiphertext  *)pdVal).envelopeKey_curve25519).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)src).envelopeKey_curve25519).value - (char *)&((*(_WR1BodyCiphertext  *)src).envelopeKey_curve25519)));
	    }
	} break;
	case 17: {
	    pdVal = (_WR1Envelope  *)_oss_dec_const_alloc(_g, sizeof(_WR1Envelope ));
	    memcpy((_WR1Envelope  *)pdVal, (_WR1Envelope  *)src, sizeof(*(_WR1Envelope  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_WR1Envelope  *)src).bodyKeys_oaque), &((*(_WR1Envelope  *)pdVal).bodyKeys_oaque), sizeof(((*(_WR1Envelope  *)pdVal).bodyKeys_oaque).length), sizeof(((*(_WR1Envelope  *)pdVal).bodyKeys_oaque).value[0]), (unsigned int)((char *)&((*(_WR1Envelope  *)src).bodyKeys_oaque).value - (char *)&((*(_WR1Envelope  *)src).bodyKeys_oaque)));
	    }
	    {
		_cp_seqof13(_g, &((*(_WR1Envelope  *)src).partition), &((*(_WR1Envelope  *)pdVal).partition));
	    }
	} break;
	case 18: {
	    pdVal = (_WR1ProverBody  *)_oss_dec_const_alloc(_g, sizeof(_WR1ProverBody ));
	    memcpy((_WR1ProverBody  *)pdVal, (_WR1ProverBody  *)src, sizeof(*(_WR1ProverBody  *)pdVal));
	    {
		_cp_seqof3(_g, &((*(_WR1ProverBody  *)src).addendums), &((*(_WR1ProverBody  *)pdVal).addendums));
	    }
	    {
		_cp_seqof2(_g, &((*(_WR1ProverBody  *)src).extensions), &((*(_WR1ProverBody  *)pdVal).extensions));
	    }
	} break;
	case 19: {
	    pdVal = (_WR1VerifierBody  *)_oss_dec_const_alloc(_g, sizeof(_WR1VerifierBody ));
	    memcpy((_WR1VerifierBody  *)pdVal, (_WR1VerifierBody  *)src, sizeof(*(_WR1VerifierBody  *)pdVal));
	    {
		_cpAttestationVerifierBody(_g, &((*(_WR1VerifierBody  *)src).attestationVerifierBody), &((*(_WR1VerifierBody  *)pdVal).attestationVerifierBody));
	    }
	} break;
	case 20: {
	    pdVal = (_Ed25519OuterSignature  *)_oss_dec_const_alloc(_g, sizeof(_Ed25519OuterSignature ));
	    memcpy((_Ed25519OuterSignature  *)pdVal, (_Ed25519OuterSignature  *)src, sizeof(*(_Ed25519OuterSignature  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Ed25519OuterSignature  *)src).verifyingKey), &((*(_Ed25519OuterSignature  *)pdVal).verifyingKey), sizeof(((*(_Ed25519OuterSignature  *)pdVal).verifyingKey).length), sizeof(((*(_Ed25519OuterSignature  *)pdVal).verifyingKey).value[0]), (unsigned int)((char *)&((*(_Ed25519OuterSignature  *)src).verifyingKey).value - (char *)&((*(_Ed25519OuterSignature  *)src).verifyingKey)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Ed25519OuterSignature  *)src).signature), &((*(_Ed25519OuterSignature  *)pdVal).signature), sizeof(((*(_Ed25519OuterSignature  *)pdVal).signature).length), sizeof(((*(_Ed25519OuterSignature  *)pdVal).signature).value[0]), (unsigned int)((char *)&((*(_Ed25519OuterSignature  *)src).signature).value - (char *)&((*(_Ed25519OuterSignature  *)src).signature)));
	    }
	} break;
	case 21: {
	    pdVal = (_SignedOuterKey  *)_oss_dec_const_alloc(_g, sizeof(_SignedOuterKey ));
	    memcpy((_SignedOuterKey  *)pdVal, (_SignedOuterKey  *)src, sizeof(*(_SignedOuterKey  *)pdVal));
	    {
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_SignedOuterKey  *)src).tbs).outerSignatureScheme), &(((*(_SignedOuterKey  *)pdVal).tbs).outerSignatureScheme), sizeof((((*(_SignedOuterKey  *)pdVal).tbs).outerSignatureScheme).length), sizeof((((*(_SignedOuterKey  *)pdVal).tbs).outerSignatureScheme).value[0]), (unsigned int)((char *)&(((*(_SignedOuterKey  *)src).tbs).outerSignatureScheme).value - (char *)&(((*(_SignedOuterKey  *)src).tbs).outerSignatureScheme)));
		}
		{
		    _oss_cpy_unbnd_octet_ia(_g, &(((*(_SignedOuterKey  *)src).tbs).verifyingKey), &(((*(_SignedOuterKey  *)pdVal).tbs).verifyingKey), sizeof((((*(_SignedOuterKey  *)pdVal).tbs).verifyingKey).length), sizeof((((*(_SignedOuterKey  *)pdVal).tbs).verifyingKey).value[0]), (unsigned int)((char *)&(((*(_SignedOuterKey  *)src).tbs).verifyingKey).value - (char *)&(((*(_SignedOuterKey  *)src).tbs).verifyingKey)));
		}
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_SignedOuterKey  *)src).signature), &((*(_SignedOuterKey  *)pdVal).signature), sizeof(((*(_SignedOuterKey  *)pdVal).signature).length), sizeof(((*(_SignedOuterKey  *)pdVal).signature).value[0]), (unsigned int)((char *)&((*(_SignedOuterKey  *)src).signature).value - (char *)&((*(_SignedOuterKey  *)src).signature)));
	    }
	} break;
	case 22: {
	    pdVal = (_TrustLevel  *)_oss_dec_const_alloc(_g, sizeof(_TrustLevel ));
	    memcpy((_TrustLevel  *)pdVal, (_TrustLevel  *)src, sizeof(*(_TrustLevel  *)pdVal));
	} break;
	case 23: {
	    pdVal = (_CommitmentRevocationOption  *)_oss_dec_const_alloc(_g, sizeof(_CommitmentRevocationOption ));
	    memcpy((_CommitmentRevocationOption  *)pdVal, (_CommitmentRevocationOption  *)src, sizeof(*(_CommitmentRevocationOption  *)pdVal));
	    {
		_cpHash(_g, &((*(_CommitmentRevocationOption  *)src).hash), &((*(_CommitmentRevocationOption  *)pdVal).hash));
	    }
	    {
		_cpLocation(_g, &((*(_CommitmentRevocationOption  *)src).location), &((*(_CommitmentRevocationOption  *)pdVal).location));
	    }
	} break;
	case 24: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 25: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 26: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 27: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 28: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 29: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 30: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 31: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 32: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 33: {
	    pdVal = (_Public_OAQUE  *)_oss_dec_const_alloc(_g, sizeof(_Public_OAQUE ));
	    memcpy((_Public_OAQUE  *)pdVal, (_Public_OAQUE  *)src, sizeof(*(_Public_OAQUE  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Public_OAQUE  *)src).params), &((*(_Public_OAQUE  *)pdVal).params), sizeof(((*(_Public_OAQUE  *)pdVal).params).length), sizeof(((*(_Public_OAQUE  *)pdVal).params).value[0]), (unsigned int)((char *)&((*(_Public_OAQUE  *)src).params).value - (char *)&((*(_Public_OAQUE  *)src).params)));
	    }
	    {
		_cp_seqof13(_g, &((*(_Public_OAQUE  *)src).attributeset), &((*(_Public_OAQUE  *)pdVal).attributeset));
	    }
	} break;
	case 34: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 35: {
	    pdVal = (OSSC::COssString  *)_oss_cpy_unbnd_octet_ia(_g, (OSSC::COssString  *)src, (OSSC::COssString  *)pdVal, sizeof((*(OSSC::COssString  *)pdVal).length), sizeof((*(OSSC::COssString  *)pdVal).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)src).value - (char *)(OSSC::COssString  *)src));
	} break;
	case 36: {
	    pdVal = (_Public_BN256_IBE  *)_oss_dec_const_alloc(_g, sizeof(_Public_BN256_IBE ));
	    memcpy((_Public_BN256_IBE  *)pdVal, (_Public_BN256_IBE  *)src, sizeof(*(_Public_BN256_IBE  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Public_BN256_IBE  *)src).params), &((*(_Public_BN256_IBE  *)pdVal).params), sizeof(((*(_Public_BN256_IBE  *)pdVal).params).length), sizeof(((*(_Public_BN256_IBE  *)pdVal).params).value[0]), (unsigned int)((char *)&((*(_Public_BN256_IBE  *)src).params).value - (char *)&((*(_Public_BN256_IBE  *)src).params)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_Public_BN256_IBE  *)src).id), &((*(_Public_BN256_IBE  *)pdVal).id), sizeof(((*(_Public_BN256_IBE  *)pdVal).id).length), sizeof(((*(_Public_BN256_IBE  *)pdVal).id).value[0]), (unsigned int)((char *)&((*(_Public_BN256_IBE  *)src).id).value - (char *)&((*(_Public_BN256_IBE  *)src).id)));
	    }
	} break;
	case 37: {
	    pdVal = (_KeyringAESCiphertext  *)_oss_dec_const_alloc(_g, sizeof(_KeyringAESCiphertext ));
	    memcpy((_KeyringAESCiphertext  *)pdVal, (_KeyringAESCiphertext  *)src, sizeof(*(_KeyringAESCiphertext  *)pdVal));
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KeyringAESCiphertext  *)src).ciphertext), &((*(_KeyringAESCiphertext  *)pdVal).ciphertext), sizeof(((*(_KeyringAESCiphertext  *)pdVal).ciphertext).length), sizeof(((*(_KeyringAESCiphertext  *)pdVal).ciphertext).value[0]), (unsigned int)((char *)&((*(_KeyringAESCiphertext  *)src).ciphertext).value - (char *)&((*(_KeyringAESCiphertext  *)src).ciphertext)));
	    }
	    {
		_oss_cpy_unbnd_octet_ia(_g, &((*(_KeyringAESCiphertext  *)src).salt), &((*(_KeyringAESCiphertext  *)pdVal).salt), sizeof(((*(_KeyringAESCiphertext  *)pdVal).salt).length), sizeof(((*(_KeyringAESCiphertext  *)pdVal).salt).value[0]), (unsigned int)((char *)&((*(_KeyringAESCiphertext  *)src).salt).value - (char *)&((*(_KeyringAESCiphertext  *)src).salt)));
	    }
	} break;
	default:
	    res = PDU_RANGE;
    }
    *pdst = pdVal;
    return res;
}
#undef _oss_c

void _oss_cpy_new_open_type (OssGlobal *_g, int *_pduNum,
		OssBuf *_obuf, OssBuf *_cbuf, void *_odecoded, void **_cdecoded)
{
    unsigned long   apiFlags = _g->decodingFlags | _g->encodingFlags;

    if (_obuf->length && _obuf->value) {
	if (apiFlags & DONT_DO_ENCODED) {
	    _cbuf->length = 0L;
	    _cbuf->value = NULL;
	} else {
	    _cbuf->value = (unsigned char *)_oss_dec_getmem_internal(_g, _obuf->length);
	    memcpy(_cbuf->value, _obuf->value, _obuf->length);
	    _cbuf->length = _obuf->length;
	}
    } else {
	_cbuf->length = 0L;
	_cbuf->value = NULL;
    }
    if (*_pduNum && _odecoded && !(apiFlags & DONT_DO_DECODED)) {
	_CPWAVE_Schema(_g, *_pduNum, _odecoded, _cdecoded);
    } else {
	*_pduNum = 0;
	*_cdecoded = NULL;
    }
}
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
static int _cmWaveEntity(OssGlobal * _g, _WaveEntity  * _odata, _WaveEntity  * _cdata)
{
    int _res = 0;

    _res = _cmEntityPublicKey(_g, &(((*_odata).tbs).verifyingKey), &(((*_cdata).tbs).verifyingKey));
    if (_res)
	return _res;
    {
	_seqof4 *  _s_oss_tmp_3 = ((*_odata).tbs).keys;
	_seqof4 *  _d_oss_tmp_3 = ((*_cdata).tbs).keys;

	while (_s_oss_tmp_3 && _d_oss_tmp_3) {
	    _res = _cmEntityPublicKey(_g, &(_s_oss_tmp_3->value), &(_d_oss_tmp_3->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_3 = _s_oss_tmp_3->next;
	    _d_oss_tmp_3 = _d_oss_tmp_3->next;
	}
	if (_s_oss_tmp_3 || _d_oss_tmp_3)
	    return 1;
    }
    _res = _cm_seq5(_g, &(((*_odata).tbs).validity), &(((*_cdata).tbs).validity));
    if (_res)
	return _res;
    _res = _cm_seqof1(_g, &(((*_odata).tbs).revocations), &(((*_cdata).tbs).revocations));
    if (_res)
	return _res;
    _res = _cm_seqof2(_g, &(((*_odata).tbs).extensions), &(((*_cdata).tbs).extensions));
    if (_res)
	return _res;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).signature), &((*_cdata).signature), sizeof(((*_cdata).signature).length), sizeof(((*_cdata).signature).value[0]), (unsigned int)((char *)&((*_odata).signature).value - (char *)&((*_odata).signature))))
	return 1;
    (void)_g;

    return _res;
}


static int _cmEntityKeyringEntry(OssGlobal * _g, _EntityKeyringEntry  * _odata, _EntityKeyringEntry  * _cdata)
{
    int _res = 0;

    _res = _cmEntityPublicKey(_g, &((*_odata).EntityKeyringEntry_public), &((*_cdata).EntityKeyringEntry_public));
    if (_res)
	return _res;
    if (!(((*_cdata).secret).type_id).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&(((*_odata).secret).type_id), &(((*_cdata).secret).type_id), sizeof((((*_cdata).secret).type_id).length), sizeof((((*_cdata).secret).type_id).value[0]), (unsigned int)((char *)&(((*_odata).secret).type_id).value - (char *)&(((*_odata).secret).type_id))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, (((*_odata).secret).value).pduNum, (((*_cdata).secret).value).pduNum, &((((*_odata).secret).value).encoded), &((((*_cdata).secret).value).encoded), *(void **)&((((*_odata).secret).value).decoded), *(void **)&((((*_cdata).secret).value).decoded));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cmHash(OssGlobal * _g, _Hash  * _odata, _Hash  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).type_id).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).type_id), &((*_cdata).type_id), sizeof(((*_cdata).type_id).length), sizeof(((*_cdata).type_id).value[0]), (unsigned int)((char *)&((*_odata).type_id).value - (char *)&((*_odata).type_id))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, ((*_odata).value).pduNum, ((*_cdata).value).pduNum, &(((*_odata).value).encoded), &(((*_cdata).value).encoded), *(void **)&(((*_odata).value).decoded), *(void **)&(((*_cdata).value).decoded));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cmLocation(OssGlobal * _g, _Location  * _odata, _Location  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).type_id).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).type_id), &((*_cdata).type_id), sizeof(((*_cdata).type_id).length), sizeof(((*_cdata).type_id).value[0]), (unsigned int)((char *)&((*_odata).type_id).value - (char *)&((*_odata).type_id))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, ((*_odata).value).pduNum, ((*_cdata).value).pduNum, &(((*_odata).value).encoded), &(((*_cdata).value).encoded), *(void **)&(((*_odata).value).decoded), *(void **)&(((*_cdata).value).decoded));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cmExtension(OssGlobal * _g, _Extension  * _odata, _Extension  * _cdata)
{
    int _res = 0;

    if (!((*_cdata).extnID).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).extnID), &((*_cdata).extnID), sizeof(((*_cdata).extnID).length), sizeof(((*_cdata).extnID).value[0]), (unsigned int)((char *)&((*_odata).extnID).value - (char *)&((*_odata).extnID))))
	return 1;
    if (((*_cdata).critical ^ (*_odata).critical) & 0x01)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&((*_odata).value), &((*_cdata).value), sizeof(((*_cdata).value).length), sizeof(((*_cdata).value).value[0]), (unsigned int)((char *)&((*_odata).value).value - (char *)&((*_odata).value))))
	return 1;
    (void)_g;

    return _res;
}


static int _cm_seqof1(OssGlobal * _g, _seqof1 * * _odata, _seqof1 * * _cdata)
{
    int _res = 0;

    {
	_seqof1 *  _s_oss_tmp_1 = *_odata;
	_seqof1 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    if (((_d_oss_tmp_1->value).critical ^ (_s_oss_tmp_1->value).critical) & 0x01)
		return 1;
	    if (!(((_d_oss_tmp_1->value).scheme).type_id).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(((_s_oss_tmp_1->value).scheme).type_id), &(((_d_oss_tmp_1->value).scheme).type_id), sizeof((((_d_oss_tmp_1->value).scheme).type_id).length), sizeof((((_d_oss_tmp_1->value).scheme).type_id).value[0]), (unsigned int)((char *)&(((_s_oss_tmp_1->value).scheme).type_id).value - (char *)&(((_s_oss_tmp_1->value).scheme).type_id))))
		return 1;
	    _res = _oss_cmp_new_open_type(_g, (((_s_oss_tmp_1->value).scheme).value).pduNum, (((_d_oss_tmp_1->value).scheme).value).pduNum, &((((_s_oss_tmp_1->value).scheme).value).encoded), &((((_d_oss_tmp_1->value).scheme).value).encoded), *(void **)&((((_s_oss_tmp_1->value).scheme).value).decoded), *(void **)&((((_d_oss_tmp_1->value).scheme).value).decoded));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cm_seqof2(OssGlobal * _g, _seqof2 * * _odata, _seqof2 * * _cdata)
{
    int _res = 0;

    {
	_seqof2 *  _s_oss_tmp_1 = *_odata;
	_seqof2 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    _res = _cmExtension(_g, &(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cm_seq5(OssGlobal * _g, _seq5  * _odata, _seq5  * _cdata)
{
    int _res = 0;

    if (strcmp((*_cdata).notBefore, (*_odata).notBefore))
#ifdef BAD_OID_IRI
	if (_oss_cmp_str2time((*_cdata).notBefore, (*_odata).notBefore, 1))
#endif
	    return 1;
    if (strcmp((*_cdata).notAfter, (*_odata).notAfter))
#ifdef BAD_OID_IRI
	if (_oss_cmp_str2time((*_cdata).notAfter, (*_odata).notAfter, 1))
#endif
	    return 1;
    (void)_g;

    return _res;
}


static int _cmAttestationVerifierBody(OssGlobal * _g, _AttestationVerifierBody  * _odata, _AttestationVerifierBody  * _cdata)
{
    int _res = 0;

    _res = _cmHash(_g, &((*_odata).attester), &((*_cdata).attester));
    if (_res)
	return _res;
    _res = _cmLocation(_g, &((*_odata).attesterLocation), &((*_cdata).attesterLocation));
    if (_res)
	return _res;
    _res = _cm_seq5(_g, &((*_odata).validity), &((*_cdata).validity));
    if (_res)
	return _res;
    if (!(((*_cdata).policy).type_id).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&(((*_odata).policy).type_id), &(((*_cdata).policy).type_id), sizeof((((*_cdata).policy).type_id).length), sizeof((((*_cdata).policy).type_id).value[0]), (unsigned int)((char *)&(((*_odata).policy).type_id).value - (char *)&(((*_odata).policy).type_id))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, (((*_odata).policy).value).pduNum, (((*_cdata).policy).value).pduNum, &((((*_odata).policy).value).encoded), &((((*_cdata).policy).value).encoded), *(void **)&((((*_odata).policy).value).decoded), *(void **)&((((*_cdata).policy).value).decoded));
    if (_res)
	return _res;
    _res = _cm_seqof2(_g, &((*_odata).extensions), &((*_cdata).extensions));
    if (_res)
	return _res;
    if (!(((*_cdata).outerSignatureBinding).type_id).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&(((*_odata).outerSignatureBinding).type_id), &(((*_cdata).outerSignatureBinding).type_id), sizeof((((*_cdata).outerSignatureBinding).type_id).length), sizeof((((*_cdata).outerSignatureBinding).type_id).value[0]), (unsigned int)((char *)&(((*_odata).outerSignatureBinding).type_id).value - (char *)&(((*_odata).outerSignatureBinding).type_id))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, (((*_odata).outerSignatureBinding).value).pduNum, (((*_cdata).outerSignatureBinding).value).pduNum, &((((*_odata).outerSignatureBinding).value).encoded), &((((*_cdata).outerSignatureBinding).value).encoded), *(void **)&((((*_odata).outerSignatureBinding).value).decoded), *(void **)&((((*_cdata).outerSignatureBinding).value).decoded));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cm_seqof3(OssGlobal * _g, _seqof3 * * _odata, _seqof3 * * _cdata)
{
    int _res = 0;

    {
	_seqof3 *  _s_oss_tmp_1 = *_odata;
	_seqof3 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    if (!((_d_oss_tmp_1->value).type_id).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_1->value).type_id), &((_d_oss_tmp_1->value).type_id), sizeof(((_d_oss_tmp_1->value).type_id).length), sizeof(((_d_oss_tmp_1->value).type_id).value[0]), (unsigned int)((char *)&((_s_oss_tmp_1->value).type_id).value - (char *)&((_s_oss_tmp_1->value).type_id))))
		return 1;
	    _res = _oss_cmp_new_open_type(_g, ((_s_oss_tmp_1->value).value).pduNum, ((_d_oss_tmp_1->value).value).pduNum, &(((_s_oss_tmp_1->value).value).encoded), &(((_d_oss_tmp_1->value).value).encoded), *(void **)&(((_s_oss_tmp_1->value).value).decoded), *(void **)&(((_d_oss_tmp_1->value).value).decoded));
	    if (_res)
		return _res;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _cmEntityPublicKey(OssGlobal * _g, _EntityPublicKey  * _odata, _EntityPublicKey  * _cdata)
{
    int _res = 0;

    {
	_setof1 *  _s_2 = (*_odata).capabilityFlags;
	_setof1 *  _d_2 = (*_cdata).capabilityFlags;
	long        *_a, _i, _i_next, _c = 0L;

	while (_s_2 && _d_2) {
	    ++ _c;
	    _s_2 = _s_2->next;
	    _d_2 = _d_2->next;
	}
	if (_s_2 || _d_2)
	    return 1;
	if (_c) {
	    _a = (long *)_oss_dec_gettempmem(_g, (_c+1)*sizeof(long));
	    for (_i = 0; _i < _c; _i ++)
		_a[_i] = _i;
	    _a[_c] = -1L;
	    for (_s_2 = (*_odata).capabilityFlags; _s_2; _s_2 = _s_2->next) {
		_i_next = _a[0]; _res = 1;
		for (_d_2 = (*_cdata).capabilityFlags, _i = 0L; _d_2 && _i_next >= 0L && _a[_i_next] >= 0L; _d_2 = _d_2->next,
			_i_next = (_i++ < _i_next) ? _i_next : _a[_i_next+1]) {
		    if (_i < _i_next)
			continue;
		    if (_d_2->value != _s_2->value)
			continue;
		    _res = 0; _a[_i] = _a[_i+1];
		    break;
		}
		if (_res)
		    break;
	    }
	    _oss_dec_freetempmem(_g, _a);
	    if (_res)
		return _res;
	}
    }
    if (!(((*_cdata).key).type_id).length)
	return 1;
    if (_oss_cmp_unbnd_octet_ia(&(((*_odata).key).type_id), &(((*_cdata).key).type_id), sizeof((((*_cdata).key).type_id).length), sizeof((((*_cdata).key).type_id).value[0]), (unsigned int)((char *)&(((*_odata).key).type_id).value - (char *)&(((*_odata).key).type_id))))
	return 1;
    _res = _oss_cmp_new_open_type(_g, (((*_odata).key).value).pduNum, (((*_cdata).key).value).pduNum, &((((*_odata).key).value).encoded), &((((*_cdata).key).value).encoded), *(void **)&((((*_odata).key).value).decoded), *(void **)&((((*_cdata).key).value).decoded));
    if (_res)
	return _res;
    (void)_g;

    return _res;
}


static int _cm_seqof13(OssGlobal * _g, _seqof14 * * _odata, _seqof14 * * _cdata)
{
    int _res = 0;

    {
	_seqof14 *  _s_oss_tmp_1 = *_odata;
	_seqof14 *  _d_oss_tmp_1 = *_cdata;

	while (_s_oss_tmp_1 && _d_oss_tmp_1) {
	    if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_1->value), &(_d_oss_tmp_1->value), sizeof((_d_oss_tmp_1->value).length), sizeof((_d_oss_tmp_1->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_1->value).value - (char *)&(_s_oss_tmp_1->value))))
		return 1;
	    _s_oss_tmp_1 = _s_oss_tmp_1->next;
	    _d_oss_tmp_1 = _d_oss_tmp_1->next;
	}
	if (_s_oss_tmp_1 || _d_oss_tmp_1)
	    return 1;
    }
    (void)_g;

    return _res;
}


static int _CMWAVE_Schema(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata)
{
    int _res = 0;

    if (_pduNum <= 0 || _pduNum > 38)
	return PDU_RANGE;
    switch (_pduNum) {
	case 1: {
	    if (!((*(_WaveWireObject  *)_cdata).type_id).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_WaveWireObject  *)_odata).type_id), &((*(_WaveWireObject  *)_cdata).type_id), sizeof(((*(_WaveWireObject  *)_cdata).type_id).length), sizeof(((*(_WaveWireObject  *)_cdata).type_id).value[0]), (unsigned int)((char *)&((*(_WaveWireObject  *)_odata).type_id).value - (char *)&((*(_WaveWireObject  *)_odata).type_id))))
		return 1;
	    _res = _oss_cmp_new_open_type(_g, ((*(_WaveWireObject  *)_odata).value).pduNum, ((*(_WaveWireObject  *)_cdata).value).pduNum, &(((*(_WaveWireObject  *)_odata).value).encoded), &(((*(_WaveWireObject  *)_cdata).value).encoded), *(void **)&(((*(_WaveWireObject  *)_odata).value).decoded), *(void **)&(((*(_WaveWireObject  *)_cdata).value).decoded));
	    if (_res)
		return _res;
	} break;
	case 2: {
	    _res = _cmHash(_g, &(((*(_WaveAttestation  *)_odata).tbs).subject), &(((*(_WaveAttestation  *)_cdata).tbs).subject));
	    if (_res)
		return _res;
	    _res = _cmLocation(_g, &(((*(_WaveAttestation  *)_odata).tbs).subjectLocation), &(((*(_WaveAttestation  *)_cdata).tbs).subjectLocation));
	    if (_res)
		return _res;
	    _res = _cm_seqof1(_g, &(((*(_WaveAttestation  *)_odata).tbs).revocations), &(((*(_WaveAttestation  *)_cdata).tbs).revocations));
	    if (_res)
		return _res;
	    _res = _cm_seqof2(_g, &(((*(_WaveAttestation  *)_odata).tbs).publicExtensions), &(((*(_WaveAttestation  *)_cdata).tbs).publicExtensions));
	    if (_res)
		return _res;
	    if (!((((*(_WaveAttestation  *)_cdata).tbs).body).type_id).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((((*(_WaveAttestation  *)_odata).tbs).body).type_id), &((((*(_WaveAttestation  *)_cdata).tbs).body).type_id), sizeof(((((*(_WaveAttestation  *)_cdata).tbs).body).type_id).length), sizeof(((((*(_WaveAttestation  *)_cdata).tbs).body).type_id).value[0]), (unsigned int)((char *)&((((*(_WaveAttestation  *)_odata).tbs).body).type_id).value - (char *)&((((*(_WaveAttestation  *)_odata).tbs).body).type_id))))
		return 1;
	    _res = _oss_cmp_new_open_type(_g, ((((*(_WaveAttestation  *)_odata).tbs).body).value).pduNum, ((((*(_WaveAttestation  *)_cdata).tbs).body).value).pduNum, &(((((*(_WaveAttestation  *)_odata).tbs).body).value).encoded), &(((((*(_WaveAttestation  *)_cdata).tbs).body).value).encoded), *(void **)&(((((*(_WaveAttestation  *)_odata).tbs).body).value).decoded), *(void **)&(((((*(_WaveAttestation  *)_cdata).tbs).body).value).decoded));
	    if (_res)
		return _res;
	    if (!(((*(_WaveAttestation  *)_cdata).outerSignature).type_id).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(((*(_WaveAttestation  *)_odata).outerSignature).type_id), &(((*(_WaveAttestation  *)_cdata).outerSignature).type_id), sizeof((((*(_WaveAttestation  *)_cdata).outerSignature).type_id).length), sizeof((((*(_WaveAttestation  *)_cdata).outerSignature).type_id).value[0]), (unsigned int)((char *)&(((*(_WaveAttestation  *)_odata).outerSignature).type_id).value - (char *)&(((*(_WaveAttestation  *)_odata).outerSignature).type_id))))
		return 1;
	    _res = _oss_cmp_new_open_type(_g, (((*(_WaveAttestation  *)_odata).outerSignature).value).pduNum, (((*(_WaveAttestation  *)_cdata).outerSignature).value).pduNum, &((((*(_WaveAttestation  *)_odata).outerSignature).value).encoded), &((((*(_WaveAttestation  *)_cdata).outerSignature).value).encoded), *(void **)&((((*(_WaveAttestation  *)_odata).outerSignature).value).decoded), *(void **)&((((*(_WaveAttestation  *)_cdata).outerSignature).value).decoded));
	    if (_res)
		return _res;
	} break;
	case 3: {
	    _res = _cmAttestationVerifierBody(_g, &((*(_AttestationBody  *)_odata).verifierBody), &((*(_AttestationBody  *)_cdata).verifierBody));
	    if (_res)
		return _res;
	    _res = _cm_seqof3(_g, &((*(_AttestationBody  *)_odata).proverPolicyAddendums), &((*(_AttestationBody  *)_cdata).proverPolicyAddendums));
	    if (_res)
		return _res;
	    _res = _cm_seqof2(_g, &((*(_AttestationBody  *)_odata).proverExtensions), &((*(_AttestationBody  *)_cdata).proverExtensions));
	    if (_res)
		return _res;
	} break;
	case 4: {
	    _res = _cmWaveEntity(_g, (_WaveEntity  *)_odata, (_WaveEntity  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 5: {
	    _res = _cmWaveEntity(_g, &((*(_WaveEntitySecret  *)_odata).entity), &((*(_WaveEntitySecret  *)_cdata).entity));
	    if (_res)
		return _res;
	    if (!(((*(_WaveEntitySecret  *)_cdata).keyring).type_id).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(((*(_WaveEntitySecret  *)_odata).keyring).type_id), &(((*(_WaveEntitySecret  *)_cdata).keyring).type_id), sizeof((((*(_WaveEntitySecret  *)_cdata).keyring).type_id).length), sizeof((((*(_WaveEntitySecret  *)_cdata).keyring).type_id).value[0]), (unsigned int)((char *)&(((*(_WaveEntitySecret  *)_odata).keyring).type_id).value - (char *)&(((*(_WaveEntitySecret  *)_odata).keyring).type_id))))
		return 1;
	    _res = _oss_cmp_new_open_type(_g, (((*(_WaveEntitySecret  *)_odata).keyring).value).pduNum, (((*(_WaveEntitySecret  *)_cdata).keyring).value).pduNum, &((((*(_WaveEntitySecret  *)_odata).keyring).value).encoded), &((((*(_WaveEntitySecret  *)_cdata).keyring).value).encoded), *(void **)&((((*(_WaveEntitySecret  *)_odata).keyring).value).decoded), *(void **)&((((*(_WaveEntitySecret  *)_cdata).keyring).value).decoded));
	    if (_res)
		return _res;
	} break;
	case 6: {
	    {
		_seqof5 *  _s_oss_tmp_2 = (*(_EntityKeyring  *)_odata).keys;
		_seqof5 *  _d_oss_tmp_2 = (*(_EntityKeyring  *)_cdata).keys;

		while (_s_oss_tmp_2 && _d_oss_tmp_2) {
		    _res = _cmEntityKeyringEntry(_g, &(_s_oss_tmp_2->value), &(_d_oss_tmp_2->value));
		    if (_res)
			return _res;
		    _s_oss_tmp_2 = _s_oss_tmp_2->next;
		    _d_oss_tmp_2 = _d_oss_tmp_2->next;
		}
		if (_s_oss_tmp_2 || _d_oss_tmp_2)
		    return 1;
	    }
	} break;
	case 7: {
	    _res = _cmEntityKeyringEntry(_g, (_EntityKeyringEntry  *)_odata, (_EntityKeyringEntry  *)_cdata);
	    if (_res)
		return _res;
	} break;
	case 8: {
	    {
		_seqof11 *  _s_oss_tmp_2 = (*(_WaveExplicitProof  *)_odata).attestations;
		_seqof11 *  _d_oss_tmp_2 = (*(_WaveExplicitProof  *)_cdata).attestations;

		while (_s_oss_tmp_2 && _d_oss_tmp_2) {
		    _res = _cmHash(_g, &((_s_oss_tmp_2->value).hash), &((_d_oss_tmp_2->value).hash));
		    if (_res)
			return _res;
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x80000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).content), &((_d_oss_tmp_2->value).content), sizeof(((_d_oss_tmp_2->value).content).length), sizeof(((_d_oss_tmp_2->value).content).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).content).value - (char *)&((_s_oss_tmp_2->value).content))))
			    return 1;
		    }
		    {
			_seqof6 * * _odata_3 = &((_s_oss_tmp_2->value).location);
			_seqof6 * * _cdata_3 = &((_d_oss_tmp_2->value).location);

			{
			    _seqof6 *  _s_oss_tmp_4 = *_odata_3;
			    _seqof6 *  _d_oss_tmp_4 = *_cdata_3;

			    while (_s_oss_tmp_4 && _d_oss_tmp_4) {
				_res = _cmLocation(_g, &(_s_oss_tmp_4->value), &(_d_oss_tmp_4->value));
				if (_res)
				    return _res;
				_s_oss_tmp_4 = _s_oss_tmp_4->next;
				_d_oss_tmp_4 = _d_oss_tmp_4->next;
			    }
			    if (_s_oss_tmp_4 || _d_oss_tmp_4)
				return 1;
			}
		    }
		    {
			_seqof7 * * _odata_3 = &((_s_oss_tmp_2->value).keys);
			_seqof7 * * _cdata_3 = &((_d_oss_tmp_2->value).keys);

			{
			    _seqof7 *  _s_oss_tmp_4 = *_odata_3;
			    _seqof7 *  _d_oss_tmp_4 = *_cdata_3;

			    while (_s_oss_tmp_4 && _d_oss_tmp_4) {
				if (!((_d_oss_tmp_4->value).type_id).length)
				    return 1;
				if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_4->value).type_id), &((_d_oss_tmp_4->value).type_id), sizeof(((_d_oss_tmp_4->value).type_id).length), sizeof(((_d_oss_tmp_4->value).type_id).value[0]), (unsigned int)((char *)&((_s_oss_tmp_4->value).type_id).value - (char *)&((_s_oss_tmp_4->value).type_id))))
				    return 1;
				_res = _oss_cmp_new_open_type(_g, ((_s_oss_tmp_4->value).value).pduNum, ((_d_oss_tmp_4->value).value).pduNum, &(((_s_oss_tmp_4->value).value).encoded), &(((_d_oss_tmp_4->value).value).encoded), *(void **)&(((_s_oss_tmp_4->value).value).decoded), *(void **)&(((_d_oss_tmp_4->value).value).decoded));
				if (_res)
				    return _res;
				_s_oss_tmp_4 = _s_oss_tmp_4->next;
				_d_oss_tmp_4 = _d_oss_tmp_4->next;
			    }
			    if (_s_oss_tmp_4 || _d_oss_tmp_4)
				return 1;
			}
		    }
		    {
			_seqof8 * * _odata_3 = &((_s_oss_tmp_2->value).revocationChecks);
			_seqof8 * * _cdata_3 = &((_d_oss_tmp_2->value).revocationChecks);

			{
			    _seqof8 *  _s_oss_tmp_4 = *_odata_3;
			    _seqof8 *  _d_oss_tmp_4 = *_cdata_3;

			    while (_s_oss_tmp_4 && _d_oss_tmp_4) {
				if (!((_d_oss_tmp_4->value).type_id).length)
				    return 1;
				if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_4->value).type_id), &((_d_oss_tmp_4->value).type_id), sizeof(((_d_oss_tmp_4->value).type_id).length), sizeof(((_d_oss_tmp_4->value).type_id).value[0]), (unsigned int)((char *)&((_s_oss_tmp_4->value).type_id).value - (char *)&((_s_oss_tmp_4->value).type_id))))
				    return 1;
				_res = _oss_cmp_new_open_type(_g, ((_s_oss_tmp_4->value).value).pduNum, ((_d_oss_tmp_4->value).value).pduNum, &(((_s_oss_tmp_4->value).value).encoded), &(((_d_oss_tmp_4->value).value).encoded), *(void **)&(((_s_oss_tmp_4->value).value).decoded), *(void **)&(((_d_oss_tmp_4->value).value).decoded));
				if (_res)
				    return _res;
				_s_oss_tmp_4 = _s_oss_tmp_4->next;
				_d_oss_tmp_4 = _d_oss_tmp_4->next;
			    }
			    if (_s_oss_tmp_4 || _d_oss_tmp_4)
				return 1;
			}
		    }
		    {
			_seqof2 * * _odata_3 = &((_s_oss_tmp_2->value).extensions);
			_seqof2 * * _cdata_3 = &((_d_oss_tmp_2->value).extensions);

			{
			    _seqof2 *  _s_oss_tmp_4 = *_odata_3;
			    _seqof2 *  _d_oss_tmp_4 = *_cdata_3;

			    while (_s_oss_tmp_4 && _d_oss_tmp_4) {
				_res = _cmExtension(_g, &(_s_oss_tmp_4->value), &(_d_oss_tmp_4->value));
				if (_res)
				    return _res;
				_s_oss_tmp_4 = _s_oss_tmp_4->next;
				_d_oss_tmp_4 = _d_oss_tmp_4->next;
			    }
			    if (_s_oss_tmp_4 || _d_oss_tmp_4)
				return 1;
			}
		    }
		    _s_oss_tmp_2 = _s_oss_tmp_2->next;
		    _d_oss_tmp_2 = _d_oss_tmp_2->next;
		}
		if (_s_oss_tmp_2 || _d_oss_tmp_2)
		    return 1;
	    }
	    {
		_seqof12 *  _s_oss_tmp_2 = (*(_WaveExplicitProof  *)_odata).paths;
		_seqof12 *  _d_oss_tmp_2 = (*(_WaveExplicitProof  *)_cdata).paths;

		while (_s_oss_tmp_2 && _d_oss_tmp_2) {
		    {
			_setof1 *  _s_oss_tmp_3 = _s_oss_tmp_2->value;
			_setof1 *  _d_oss_tmp_3 = _d_oss_tmp_2->value;

			while (_s_oss_tmp_3 && _d_oss_tmp_3) {
			    if (_d_oss_tmp_3->value != _s_oss_tmp_3->value)
				return 1;
			    _s_oss_tmp_3 = _s_oss_tmp_3->next;
			    _d_oss_tmp_3 = _d_oss_tmp_3->next;
			}
			if (_s_oss_tmp_3 || _d_oss_tmp_3)
			    return 1;
		    }
		    _s_oss_tmp_2 = _s_oss_tmp_2->next;
		    _d_oss_tmp_2 = _d_oss_tmp_2->next;
		}
		if (_s_oss_tmp_2 || _d_oss_tmp_2)
		    return 1;
	    }
	    _res = _cm_seqof13(_g, &((*(_WaveExplicitProof  *)_odata).entities), &((*(_WaveExplicitProof  *)_cdata).entities));
	    if (_res)
		return _res;
	    _res = _cm_seqof2(_g, &((*(_WaveExplicitProof  *)_odata).extensions), &((*(_WaveExplicitProof  *)_cdata).extensions));
	    if (_res)
		return _res;
	} break;
	case 9: {
	    _res = _cmHash(_g, &((*(_RTreePolicy  *)_odata).RTreePolicy_namespace), &((*(_RTreePolicy  *)_cdata).RTreePolicy_namespace));
	    if (_res)
		return _res;
	    if ((*(_RTreePolicy  *)_cdata).indirections != (*(_RTreePolicy  *)_odata).indirections)
		return 1;
	    {
		_seqof15 *  _s_oss_tmp_2 = (*(_RTreePolicy  *)_odata).statements;
		_seqof15 *  _d_oss_tmp_2 = (*(_RTreePolicy  *)_cdata).statements;

		while (_s_oss_tmp_2 && _d_oss_tmp_2) {
		    _res = _cmHash(_g, &((_s_oss_tmp_2->value).permissionSet), &((_d_oss_tmp_2->value).permissionSet));
		    if (_res)
			return _res;
		    {
			_seqof14 * * _odata_3 = &((_s_oss_tmp_2->value).permissions);
			_seqof14 * * _cdata_3 = &((_d_oss_tmp_2->value).permissions);

			{
			    _seqof14 *  _s_oss_tmp_4 = *_odata_3;
			    _seqof14 *  _d_oss_tmp_4 = *_cdata_3;

			    while (_s_oss_tmp_4 && _d_oss_tmp_4) {
				if (_oss_cmp_unbnd_octet_ia(&(_s_oss_tmp_4->value), &(_d_oss_tmp_4->value), sizeof((_d_oss_tmp_4->value).length), sizeof((_d_oss_tmp_4->value).value[0]), (unsigned int)((char *)&(_s_oss_tmp_4->value).value - (char *)&(_s_oss_tmp_4->value))))
				    return 1;
				_s_oss_tmp_4 = _s_oss_tmp_4->next;
				_d_oss_tmp_4 = _d_oss_tmp_4->next;
			    }
			    if (_s_oss_tmp_4 || _d_oss_tmp_4)
				return 1;
			}
		    }
		    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).resource), &((_d_oss_tmp_2->value).resource), sizeof(((_d_oss_tmp_2->value).resource).length), sizeof(((_d_oss_tmp_2->value).resource).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).resource).value - (char *)&((_s_oss_tmp_2->value).resource))))
			return 1;
		    if (((_s_oss_tmp_2->value).bit_mask ^ (_d_oss_tmp_2->value).bit_mask) & 0x80000000)
			return 1;
		    if ((_s_oss_tmp_2->value).bit_mask & 0x80000000) {
			if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).comment), &((_d_oss_tmp_2->value).comment), sizeof(((_d_oss_tmp_2->value).comment).length), sizeof(((_d_oss_tmp_2->value).comment).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).comment).value - (char *)&((_s_oss_tmp_2->value).comment))))
			    return 1;
		    }
		    _s_oss_tmp_2 = _s_oss_tmp_2->next;
		    _d_oss_tmp_2 = _d_oss_tmp_2->next;
		}
		if (_s_oss_tmp_2 || _d_oss_tmp_2)
		    return 1;
	    }
	} break;
	case 10: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 11: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 12: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 13: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_LocationURL  *)_odata).value), &((*(_LocationURL  *)_cdata).value), sizeof(((*(_LocationURL  *)_cdata).value).length), sizeof(((*(_LocationURL  *)_cdata).value).value[0]), (unsigned int)((char *)&((*(_LocationURL  *)_odata).value).value - (char *)&((*(_LocationURL  *)_odata).value))))
		return 1;
	    if ((*(_LocationURL  *)_cdata).apiVersion != (*(_LocationURL  *)_odata).apiVersion)
		return 1;
	} break;
	case 14: {
	    if ((*(_LocationEthereum  *)_cdata).chainID != (*(_LocationEthereum  *)_odata).chainID)
		return 1;
	    if ((*(_LocationEthereum  *)_cdata).contractAddress != (*(_LocationEthereum  *)_odata).contractAddress)
		return 1;
	} break;
	case 15: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_PSKBodyCiphertext  *)_odata).attestationBodyCiphertext), &((*(_PSKBodyCiphertext  *)_cdata).attestationBodyCiphertext), sizeof(((*(_PSKBodyCiphertext  *)_cdata).attestationBodyCiphertext).length), sizeof(((*(_PSKBodyCiphertext  *)_cdata).attestationBodyCiphertext).value[0]), (unsigned int)((char *)&((*(_PSKBodyCiphertext  *)_odata).attestationBodyCiphertext).value - (char *)&((*(_PSKBodyCiphertext  *)_odata).attestationBodyCiphertext))))
		return 1;
	    _res = _cmEntityPublicKey(_g, &((*(_PSKBodyCiphertext  *)_odata).encryptedUnder), &((*(_PSKBodyCiphertext  *)_cdata).encryptedUnder));
	    if (_res)
		return _res;
	} break;
	case 16: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_WR1BodyCiphertext  *)_odata).verifierBodyCiphertext), &((*(_WR1BodyCiphertext  *)_cdata).verifierBodyCiphertext), sizeof(((*(_WR1BodyCiphertext  *)_cdata).verifierBodyCiphertext).length), sizeof(((*(_WR1BodyCiphertext  *)_cdata).verifierBodyCiphertext).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)_odata).verifierBodyCiphertext).value - (char *)&((*(_WR1BodyCiphertext  *)_odata).verifierBodyCiphertext))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_WR1BodyCiphertext  *)_odata).proverBodyCiphertext), &((*(_WR1BodyCiphertext  *)_cdata).proverBodyCiphertext), sizeof(((*(_WR1BodyCiphertext  *)_cdata).proverBodyCiphertext).length), sizeof(((*(_WR1BodyCiphertext  *)_cdata).proverBodyCiphertext).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)_odata).proverBodyCiphertext).value - (char *)&((*(_WR1BodyCiphertext  *)_odata).proverBodyCiphertext))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_WR1BodyCiphertext  *)_odata).envelopeCiphertext), &((*(_WR1BodyCiphertext  *)_cdata).envelopeCiphertext), sizeof(((*(_WR1BodyCiphertext  *)_cdata).envelopeCiphertext).length), sizeof(((*(_WR1BodyCiphertext  *)_cdata).envelopeCiphertext).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)_odata).envelopeCiphertext).value - (char *)&((*(_WR1BodyCiphertext  *)_odata).envelopeCiphertext))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_WR1BodyCiphertext  *)_odata).envelopeKey_ibe_bn256), &((*(_WR1BodyCiphertext  *)_cdata).envelopeKey_ibe_bn256), sizeof(((*(_WR1BodyCiphertext  *)_cdata).envelopeKey_ibe_bn256).length), sizeof(((*(_WR1BodyCiphertext  *)_cdata).envelopeKey_ibe_bn256).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)_odata).envelopeKey_ibe_bn256).value - (char *)&((*(_WR1BodyCiphertext  *)_odata).envelopeKey_ibe_bn256))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_WR1BodyCiphertext  *)_odata).envelopeKey_curve25519), &((*(_WR1BodyCiphertext  *)_cdata).envelopeKey_curve25519), sizeof(((*(_WR1BodyCiphertext  *)_cdata).envelopeKey_curve25519).length), sizeof(((*(_WR1BodyCiphertext  *)_cdata).envelopeKey_curve25519).value[0]), (unsigned int)((char *)&((*(_WR1BodyCiphertext  *)_odata).envelopeKey_curve25519).value - (char *)&((*(_WR1BodyCiphertext  *)_odata).envelopeKey_curve25519))))
		return 1;
	} break;
	case 17: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_WR1Envelope  *)_odata).bodyKeys_oaque), &((*(_WR1Envelope  *)_cdata).bodyKeys_oaque), sizeof(((*(_WR1Envelope  *)_cdata).bodyKeys_oaque).length), sizeof(((*(_WR1Envelope  *)_cdata).bodyKeys_oaque).value[0]), (unsigned int)((char *)&((*(_WR1Envelope  *)_odata).bodyKeys_oaque).value - (char *)&((*(_WR1Envelope  *)_odata).bodyKeys_oaque))))
		return 1;
	    _res = _cm_seqof13(_g, &((*(_WR1Envelope  *)_odata).partition), &((*(_WR1Envelope  *)_cdata).partition));
	    if (_res)
		return _res;
	} break;
	case 18: {
	    _res = _cm_seqof3(_g, &((*(_WR1ProverBody  *)_odata).addendums), &((*(_WR1ProverBody  *)_cdata).addendums));
	    if (_res)
		return _res;
	    _res = _cm_seqof2(_g, &((*(_WR1ProverBody  *)_odata).extensions), &((*(_WR1ProverBody  *)_cdata).extensions));
	    if (_res)
		return _res;
	} break;
	case 19: {
	    _res = _cmAttestationVerifierBody(_g, &((*(_WR1VerifierBody  *)_odata).attestationVerifierBody), &((*(_WR1VerifierBody  *)_cdata).attestationVerifierBody));
	    if (_res)
		return _res;
	} break;
	case 20: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_Ed25519OuterSignature  *)_odata).verifyingKey), &((*(_Ed25519OuterSignature  *)_cdata).verifyingKey), sizeof(((*(_Ed25519OuterSignature  *)_cdata).verifyingKey).length), sizeof(((*(_Ed25519OuterSignature  *)_cdata).verifyingKey).value[0]), (unsigned int)((char *)&((*(_Ed25519OuterSignature  *)_odata).verifyingKey).value - (char *)&((*(_Ed25519OuterSignature  *)_odata).verifyingKey))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_Ed25519OuterSignature  *)_odata).signature), &((*(_Ed25519OuterSignature  *)_cdata).signature), sizeof(((*(_Ed25519OuterSignature  *)_cdata).signature).length), sizeof(((*(_Ed25519OuterSignature  *)_cdata).signature).value[0]), (unsigned int)((char *)&((*(_Ed25519OuterSignature  *)_odata).signature).value - (char *)&((*(_Ed25519OuterSignature  *)_odata).signature))))
		return 1;
	} break;
	case 21: {
	    if (!(((*(_SignedOuterKey  *)_cdata).tbs).outerSignatureScheme).length)
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(((*(_SignedOuterKey  *)_odata).tbs).outerSignatureScheme), &(((*(_SignedOuterKey  *)_cdata).tbs).outerSignatureScheme), sizeof((((*(_SignedOuterKey  *)_cdata).tbs).outerSignatureScheme).length), sizeof((((*(_SignedOuterKey  *)_cdata).tbs).outerSignatureScheme).value[0]), (unsigned int)((char *)&(((*(_SignedOuterKey  *)_odata).tbs).outerSignatureScheme).value - (char *)&(((*(_SignedOuterKey  *)_odata).tbs).outerSignatureScheme))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&(((*(_SignedOuterKey  *)_odata).tbs).verifyingKey), &(((*(_SignedOuterKey  *)_cdata).tbs).verifyingKey), sizeof((((*(_SignedOuterKey  *)_cdata).tbs).verifyingKey).length), sizeof((((*(_SignedOuterKey  *)_cdata).tbs).verifyingKey).value[0]), (unsigned int)((char *)&(((*(_SignedOuterKey  *)_odata).tbs).verifyingKey).value - (char *)&(((*(_SignedOuterKey  *)_odata).tbs).verifyingKey))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_SignedOuterKey  *)_odata).signature), &((*(_SignedOuterKey  *)_cdata).signature), sizeof(((*(_SignedOuterKey  *)_cdata).signature).length), sizeof(((*(_SignedOuterKey  *)_cdata).signature).value[0]), (unsigned int)((char *)&((*(_SignedOuterKey  *)_odata).signature).value - (char *)&((*(_SignedOuterKey  *)_odata).signature))))
		return 1;
	} break;
	case 22: {
	    if ((*(_TrustLevel  *)_cdata).trust != (*(_TrustLevel  *)_odata).trust)
		return 1;
	} break;
	case 23: {
	    _res = _cmHash(_g, &((*(_CommitmentRevocationOption  *)_odata).hash), &((*(_CommitmentRevocationOption  *)_cdata).hash));
	    if (_res)
		return _res;
	    _res = _cmLocation(_g, &((*(_CommitmentRevocationOption  *)_odata).location), &((*(_CommitmentRevocationOption  *)_cdata).location));
	    if (_res)
		return _res;
	} break;
	case 24: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 25: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 26: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 27: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 28: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 29: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 30: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 31: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 32: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 33: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_Public_OAQUE  *)_odata).params), &((*(_Public_OAQUE  *)_cdata).params), sizeof(((*(_Public_OAQUE  *)_cdata).params).length), sizeof(((*(_Public_OAQUE  *)_cdata).params).value[0]), (unsigned int)((char *)&((*(_Public_OAQUE  *)_odata).params).value - (char *)&((*(_Public_OAQUE  *)_odata).params))))
		return 1;
	    _res = _cm_seqof13(_g, &((*(_Public_OAQUE  *)_odata).attributeset), &((*(_Public_OAQUE  *)_cdata).attributeset));
	    if (_res)
		return _res;
	} break;
	case 34: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 35: {
	    if (_oss_cmp_unbnd_octet_ia((OSSC::COssString  *)_odata, (OSSC::COssString  *)_cdata, sizeof((*(OSSC::COssString  *)_cdata).length), sizeof((*(OSSC::COssString  *)_cdata).value[0]), (unsigned int)((char *)&(*(OSSC::COssString  *)_odata).value - (char *)(OSSC::COssString  *)_odata)))
		return 1;
	} break;
	case 36: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_Public_BN256_IBE  *)_odata).params), &((*(_Public_BN256_IBE  *)_cdata).params), sizeof(((*(_Public_BN256_IBE  *)_cdata).params).length), sizeof(((*(_Public_BN256_IBE  *)_cdata).params).value[0]), (unsigned int)((char *)&((*(_Public_BN256_IBE  *)_odata).params).value - (char *)&((*(_Public_BN256_IBE  *)_odata).params))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_Public_BN256_IBE  *)_odata).id), &((*(_Public_BN256_IBE  *)_cdata).id), sizeof(((*(_Public_BN256_IBE  *)_cdata).id).length), sizeof(((*(_Public_BN256_IBE  *)_cdata).id).value[0]), (unsigned int)((char *)&((*(_Public_BN256_IBE  *)_odata).id).value - (char *)&((*(_Public_BN256_IBE  *)_odata).id))))
		return 1;
	} break;
	case 37: {
	    if (_oss_cmp_unbnd_octet_ia(&((*(_KeyringAESCiphertext  *)_odata).ciphertext), &((*(_KeyringAESCiphertext  *)_cdata).ciphertext), sizeof(((*(_KeyringAESCiphertext  *)_cdata).ciphertext).length), sizeof(((*(_KeyringAESCiphertext  *)_cdata).ciphertext).value[0]), (unsigned int)((char *)&((*(_KeyringAESCiphertext  *)_odata).ciphertext).value - (char *)&((*(_KeyringAESCiphertext  *)_odata).ciphertext))))
		return 1;
	    if (_oss_cmp_unbnd_octet_ia(&((*(_KeyringAESCiphertext  *)_odata).salt), &((*(_KeyringAESCiphertext  *)_cdata).salt), sizeof(((*(_KeyringAESCiphertext  *)_cdata).salt).length), sizeof(((*(_KeyringAESCiphertext  *)_cdata).salt).value[0]), (unsigned int)((char *)&((*(_KeyringAESCiphertext  *)_odata).salt).value - (char *)&((*(_KeyringAESCiphertext  *)_odata).salt))))
		return 1;
	    if ((*(_KeyringAESCiphertext  *)_cdata).iterations != (*(_KeyringAESCiphertext  *)_odata).iterations)
		return 1;
	} break;
	default:
	    return PDU_RANGE;
    }
    (void)_g;

    return _res;
}
#endif /* OSS_COMPARE_VALUE */

#ifdef OSS_COMPARE_VALUE
int _oss_cmp_new_open_type (OssGlobal *_g, int _pduNum1, int _pduNum2,
		OssBuf *_obuf1, OssBuf *_obuf2, void *_decoded1, void *_decoded2)
{
    unsigned long   apiFlags = _g->decodingFlags | _g->encodingFlags;

    if (!(apiFlags & DONT_DO_DECODED) && (_decoded1 || _decoded2)) {
	if (!_decoded1 || !_decoded2 || _pduNum1 != _pduNum2 || _pduNum1 == 0 ||
		_CMWAVE_Schema(_g, _pduNum1, _decoded1, _decoded2))
	    return VALUES_NOT_EQUAL;
    } else if (!(apiFlags & DONT_DO_ENCODED) && (_obuf1->value || _obuf2->value)) {
	if (!_obuf1->value || !_obuf2->value || _obuf1->length != _obuf2->length ||
		memcmp(_obuf1->value, _obuf2->value, _obuf1->length))
	    return VALUES_NOT_EQUAL;
    }

    return VALUES_EQUAL;
}
#endif /* OSS_COMPARE_VALUE */

/* Entry points */
static const _entry_point_struct _entry_points = {_ossinit_objects, _emWAVE_Schema, _dmWAVE_Schema, 
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
_fmWAVE_Schema,
#else
NULL, 
#endif
117,
 NULL, NULL, 0, 0, NULL,
#ifdef OSSPRINT
_pmWAVE_Schema
#else
NULL
#endif
};
static void _oss_post_init(struct ossGlobal *world) {
    static const unsigned char _oss_typeinfo[] = {
        0x00, 0x51, 0x34, 0xf0, 0x9f, 0x08, 0xcc, 0x6d, 0x7d, 0x4e,
        0xe4, 0x36, 0x7d, 0xc4, 0xe4, 0x2d, 0x60, 0xda, 0x98, 0xd1,
        0x38, 0x5e, 0xf9, 0x7c, 0x8d, 0xc2, 0x93, 0x26, 0x5d, 0xf5,
        0x35, 0x3b, 0x52, 0x3d, 0xb3, 0xa4, 0x5b, 0xd3, 0xbe, 0xfa,
        0xa6, 0x67, 0x66, 0x57, 0x05, 0xb4, 0xea, 0x5a, 0xd2, 0xd2,
        0x11, 0x2a, 0xf0, 0x87, 0x30, 0x59, 0xb4, 0x56, 0x2d, 0x09,
        0x6f, 0xc1, 0x4d, 0xbe, 0xf0, 0xa3, 0x16, 0x6a, 0x6c, 0xa8,
        0xd9, 0xcb, 0x7b, 0x9b, 0xff, 0x5b, 0x4a, 0x34, 0xfa, 0x6a,
        0xe9, 0x31, 0x35
    };
    ossInitRootContext1(world, (unsigned char *)_oss_typeinfo);
#if (OSS_TOED_API_LEVEL > 35)
#if (OSSDEBUG == 0)
    ossLinkZeroMsgs(world);
#elif defined(OSS_REDUCED_ERROR_MSGS)
    ossLinkIdMsgs(world);
#else
    ossLinkFullMsgs(world);
#endif
#endif
}

} /* extern "C" */

void *objects_TableType::internal = (void *)&_entry_points;
