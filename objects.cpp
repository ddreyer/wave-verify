/*************************************************************/
/* Copyright (C) 2018 OSS Nokalva, Inc.  All rights reserved.*/
/*************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OSS NOKALVA, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OSS NOKALVA, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED.
 * THIS COPYRIGHT STATEMENT MAY NOT BE REMOVED. */

/* This file was generated by a TRIAL version of the OSS ASN.1 Tools.
 * Applications built using this file can be executed only on the machine
 * on which you run the OSS ASN.1 compiler. */

/* Generated for: UC Berkeley (Trial), License 76702Z 76702Z. */
/* Abstract syntax: objects */
/* Created: Thu Apr 26 19:47:31 2018 */
/* ASN.1/C++ compiler version: 6.6 */
/* Code generated for runtime version 6.6 or later */
/* Compiler operating system: Linux with 64-bit support */
/* Compiler machine type: Intel 64 or AMD64 */
/* Target operating system: Linux with 64-bit support */
/* Target machine type: Intel 64 or AMD64 */
/* C++ compiler options required: -m64 */
/* ASN.1 compiler options and file names specified:
 * -soed -der -allow universaltags objects.asn
 */

#define OSS_COMPILER_API_LEVEL 37
#define _OSS_CONTROL_FILE
#include "objects.h"
#include "string.h"

/* Control table object */

class objects_TableType : public OssControlTable {
public:
    static void *internal;
    objects_TableType();
    int destroy(void *data, OssTypeIndex typeindex);
    int copy(void *src, void **dst, OssTypeIndex typeindex);
    int equal(void *data1, void *data2, OssTypeIndex typeindex);
};

objects_TableType::objects_TableType() : OssControlTable(internal) {
}

int objects_TableType::destroy(void *data, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    delete (WaveWireObject *)data;
	    break;
	case 2:
	    delete (WaveAttestation *)data;
	    break;
	case 3:
	    delete (AttestationBody *)data;
	    break;
	case 4:
	    delete (WaveEntity *)data;
	    break;
	case 5:
	    delete (WaveEntitySecret *)data;
	    break;
	case 6:
	    delete (EntityKeyring *)data;
	    break;
	case 7:
	    delete (EntityKeyringEntry *)data;
	    break;
	case 8:
	    delete (WaveExplicitProof *)data;
	    break;
	case 9:
	    delete (RTreePolicy *)data;
	    break;
	case 10:
	    delete (HashSha3_256 *)data;
	    break;
	case 11:
	    delete (HashSha_256 *)data;
	    break;
	case 12:
	    delete (HashKeccak_256 *)data;
	    break;
	case 13:
	    delete (LocationURL *)data;
	    break;
	case 14:
	    delete (LocationEthereum *)data;
	    break;
	case 15:
	    delete (PSKBodyCiphertext *)data;
	    break;
	case 16:
	    delete (WR1BodyCiphertext *)data;
	    break;
	case 17:
	    delete (WR1Envelope *)data;
	    break;
	case 18:
	    delete (WR1ProverBody *)data;
	    break;
	case 19:
	    delete (WR1VerifierBody *)data;
	    break;
	case 20:
	    delete (Ed25519OuterSignature *)data;
	    break;
	case 21:
	    delete (SignedOuterKey *)data;
	    break;
	case 22:
	    delete (TrustLevel *)data;
	    break;
	case 23:
	    delete (CommitmentRevocationOption *)data;
	    break;
	case 24:
	    delete (AVKeyAES128_GCM *)data;
	    break;
	case 25:
	    delete (Private_Ed25519 *)data;
	    break;
	case 26:
	    delete (Private_Curve25519 *)data;
	    break;
	case 27:
	    delete (Private_BN256_OAQUE *)data;
	    break;
	case 28:
	    delete (Private_BN256_IBE *)data;
	    break;
	case 29:
	    delete (Master_BN256_OAQUE *)data;
	    break;
	case 30:
	    delete (Master_BN256_IBE *)data;
	    break;
	case 31:
	    delete (Public_Ed25519 *)data;
	    break;
	case 32:
	    delete (Public_Curve25519 *)data;
	    break;
	case 33:
	    delete (Public_OAQUE *)data;
	    break;
	case 34:
	    delete (Params_BN256_OAQUE *)data;
	    break;
	case 35:
	    delete (Params_BN256_IBE *)data;
	    break;
	case 36:
	    delete (Public_BN256_IBE *)data;
	    break;
	case 37:
	    delete (KeyringAESCiphertext *)data;
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    return 0;
}

int objects_TableType::copy(void *src, void **dst, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    *dst = new WaveWireObject(*(WaveWireObject *)src);
	    break;
	case 2:
	    *dst = new WaveAttestation(*(WaveAttestation *)src);
	    break;
	case 3:
	    *dst = new AttestationBody(*(AttestationBody *)src);
	    break;
	case 4:
	    *dst = new WaveEntity(*(WaveEntity *)src);
	    break;
	case 5:
	    *dst = new WaveEntitySecret(*(WaveEntitySecret *)src);
	    break;
	case 6:
	    *dst = new EntityKeyring(*(EntityKeyring *)src);
	    break;
	case 7:
	    *dst = new EntityKeyringEntry(*(EntityKeyringEntry *)src);
	    break;
	case 8:
	    *dst = new WaveExplicitProof(*(WaveExplicitProof *)src);
	    break;
	case 9:
	    *dst = new RTreePolicy(*(RTreePolicy *)src);
	    break;
	case 10:
	    *dst = new HashSha3_256(*(HashSha3_256 *)src);
	    break;
	case 11:
	    *dst = new HashSha_256(*(HashSha_256 *)src);
	    break;
	case 12:
	    *dst = new HashKeccak_256(*(HashKeccak_256 *)src);
	    break;
	case 13:
	    *dst = new LocationURL(*(LocationURL *)src);
	    break;
	case 14:
	    *dst = new LocationEthereum(*(LocationEthereum *)src);
	    break;
	case 15:
	    *dst = new PSKBodyCiphertext(*(PSKBodyCiphertext *)src);
	    break;
	case 16:
	    *dst = new WR1BodyCiphertext(*(WR1BodyCiphertext *)src);
	    break;
	case 17:
	    *dst = new WR1Envelope(*(WR1Envelope *)src);
	    break;
	case 18:
	    *dst = new WR1ProverBody(*(WR1ProverBody *)src);
	    break;
	case 19:
	    *dst = new WR1VerifierBody(*(WR1VerifierBody *)src);
	    break;
	case 20:
	    *dst = new Ed25519OuterSignature(*(Ed25519OuterSignature *)src);
	    break;
	case 21:
	    *dst = new SignedOuterKey(*(SignedOuterKey *)src);
	    break;
	case 22:
	    *dst = new TrustLevel(*(TrustLevel *)src);
	    break;
	case 23:
	    *dst = new CommitmentRevocationOption(*(CommitmentRevocationOption *)src);
	    break;
	case 24:
	    *dst = new AVKeyAES128_GCM(*(AVKeyAES128_GCM *)src);
	    break;
	case 25:
	    *dst = new Private_Ed25519(*(Private_Ed25519 *)src);
	    break;
	case 26:
	    *dst = new Private_Curve25519(*(Private_Curve25519 *)src);
	    break;
	case 27:
	    *dst = new Private_BN256_OAQUE(*(Private_BN256_OAQUE *)src);
	    break;
	case 28:
	    *dst = new Private_BN256_IBE(*(Private_BN256_IBE *)src);
	    break;
	case 29:
	    *dst = new Master_BN256_OAQUE(*(Master_BN256_OAQUE *)src);
	    break;
	case 30:
	    *dst = new Master_BN256_IBE(*(Master_BN256_IBE *)src);
	    break;
	case 31:
	    *dst = new Public_Ed25519(*(Public_Ed25519 *)src);
	    break;
	case 32:
	    *dst = new Public_Curve25519(*(Public_Curve25519 *)src);
	    break;
	case 33:
	    *dst = new Public_OAQUE(*(Public_OAQUE *)src);
	    break;
	case 34:
	    *dst = new Params_BN256_OAQUE(*(Params_BN256_OAQUE *)src);
	    break;
	case 35:
	    *dst = new Params_BN256_IBE(*(Params_BN256_IBE *)src);
	    break;
	case 36:
	    *dst = new Public_BN256_IBE(*(Public_BN256_IBE *)src);
	    break;
	case 37:
	    *dst = new KeyringAESCiphertext(*(KeyringAESCiphertext *)src);
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    if (*dst == 0)
	return OSS_NO_MEMORY;
    return 0;
}

int objects_TableType::equal(void *data1, void *data2, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    return *(WaveWireObject *)data1 == *(WaveWireObject *)data2;
	case 2:
	    return *(WaveAttestation *)data1 == *(WaveAttestation *)data2;
	case 3:
	    return *(AttestationBody *)data1 == *(AttestationBody *)data2;
	case 4:
	    return *(WaveEntity *)data1 == *(WaveEntity *)data2;
	case 5:
	    return *(WaveEntitySecret *)data1 == *(WaveEntitySecret *)data2;
	case 6:
	    return *(EntityKeyring *)data1 == *(EntityKeyring *)data2;
	case 7:
	    return *(EntityKeyringEntry *)data1 == *(EntityKeyringEntry *)data2;
	case 8:
	    return *(WaveExplicitProof *)data1 == *(WaveExplicitProof *)data2;
	case 9:
	    return *(RTreePolicy *)data1 == *(RTreePolicy *)data2;
	case 10:
	    return *(HashSha3_256 *)data1 == *(HashSha3_256 *)data2;
	case 11:
	    return *(HashSha_256 *)data1 == *(HashSha_256 *)data2;
	case 12:
	    return *(HashKeccak_256 *)data1 == *(HashKeccak_256 *)data2;
	case 13:
	    return *(LocationURL *)data1 == *(LocationURL *)data2;
	case 14:
	    return *(LocationEthereum *)data1 == *(LocationEthereum *)data2;
	case 15:
	    return *(PSKBodyCiphertext *)data1 == *(PSKBodyCiphertext *)data2;
	case 16:
	    return *(WR1BodyCiphertext *)data1 == *(WR1BodyCiphertext *)data2;
	case 17:
	    return *(WR1Envelope *)data1 == *(WR1Envelope *)data2;
	case 18:
	    return *(WR1ProverBody *)data1 == *(WR1ProverBody *)data2;
	case 19:
	    return *(WR1VerifierBody *)data1 == *(WR1VerifierBody *)data2;
	case 20:
	    return *(Ed25519OuterSignature *)data1 == *(Ed25519OuterSignature *)data2;
	case 21:
	    return *(SignedOuterKey *)data1 == *(SignedOuterKey *)data2;
	case 22:
	    return *(TrustLevel *)data1 == *(TrustLevel *)data2;
	case 23:
	    return *(CommitmentRevocationOption *)data1 == *(CommitmentRevocationOption *)data2;
	case 24:
	    return *(AVKeyAES128_GCM *)data1 == *(AVKeyAES128_GCM *)data2;
	case 25:
	    return *(Private_Ed25519 *)data1 == *(Private_Ed25519 *)data2;
	case 26:
	    return *(Private_Curve25519 *)data1 == *(Private_Curve25519 *)data2;
	case 27:
	    return *(Private_BN256_OAQUE *)data1 == *(Private_BN256_OAQUE *)data2;
	case 28:
	    return *(Private_BN256_IBE *)data1 == *(Private_BN256_IBE *)data2;
	case 29:
	    return *(Master_BN256_OAQUE *)data1 == *(Master_BN256_OAQUE *)data2;
	case 30:
	    return *(Master_BN256_IBE *)data1 == *(Master_BN256_IBE *)data2;
	case 31:
	    return *(Public_Ed25519 *)data1 == *(Public_Ed25519 *)data2;
	case 32:
	    return *(Public_Curve25519 *)data1 == *(Public_Curve25519 *)data2;
	case 33:
	    return *(Public_OAQUE *)data1 == *(Public_OAQUE *)data2;
	case 34:
	    return *(Params_BN256_OAQUE *)data1 == *(Params_BN256_OAQUE *)data2;
	case 35:
	    return *(Params_BN256_IBE *)data1 == *(Params_BN256_IBE *)data2;
	case 36:
	    return *(Public_BN256_IBE *)data1 == *(Public_BN256_IBE *)data2;
	case 37:
	    return *(KeyringAESCiphertext *)data1 == *(KeyringAESCiphertext *)data2;
    }
    return 0;
}

static objects_TableType objects_Table;

/* Representation types */

HashSchemes_Type::HashSchemes_Type()
{
}

HashSchemes_Type::HashSchemes_Type(const HashSchemes_Type & that)
{
    operator =(that);
}

HashSchemes_Type::~HashSchemes_Type()
{
    cleanup_decoded();
}

HashSchemes_Type & HashSchemes_Type::operator = (const HashSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int HashSchemes_Type::operator == (const HashSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int HashSchemes_Type::operator != (const HashSchemes_Type & that) const
{
    return !(operator ==(that));
}

int HashSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int HashSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int HashSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int HashSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int HashSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

HashSha3_256 *HashSchemes_Type::get_HashSha3_256()
{
    if (pdunum == 10)
	return (HashSha3_256 *)decoded;
    else
	return NULL;
}

const HashSha3_256 *HashSchemes_Type::get_HashSha3_256() const
{
    if (pdunum == 10)
	return (const HashSha3_256 *)decoded;
    else
	return NULL;
}

void HashSchemes_Type::set_HashSha3_256(const HashSha3_256 & data)
{
    void *copy;

    copy = new HashSha3_256(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 10;
	decoded = copy;
    }
}

HashSha3_256 *HashSchemes_Type::release_HashSha3_256()
{
    pdunum = 0;
    decoded = NULL;
    return get_HashSha3_256();
}

void HashSchemes_Type::set_HashSha3_256(HashSha3_256 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 10;
    decoded = data;
}

HashKeccak_256 *HashSchemes_Type::get_HashKeccak_256()
{
    if (pdunum == 12)
	return (HashKeccak_256 *)decoded;
    else
	return NULL;
}

const HashKeccak_256 *HashSchemes_Type::get_HashKeccak_256() const
{
    if (pdunum == 12)
	return (const HashKeccak_256 *)decoded;
    else
	return NULL;
}

void HashSchemes_Type::set_HashKeccak_256(const HashKeccak_256 & data)
{
    void *copy;

    copy = new HashKeccak_256(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 12;
	decoded = copy;
    }
}

HashKeccak_256 *HashSchemes_Type::release_HashKeccak_256()
{
    pdunum = 0;
    decoded = NULL;
    return get_HashKeccak_256();
}

void HashSchemes_Type::set_HashKeccak_256(HashKeccak_256 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 12;
    decoded = data;
}

HashSha_256 *HashSchemes_Type::get_HashSha_256()
{
    if (pdunum == 11)
	return (HashSha_256 *)decoded;
    else
	return NULL;
}

const HashSha_256 *HashSchemes_Type::get_HashSha_256() const
{
    if (pdunum == 11)
	return (const HashSha_256 *)decoded;
    else
	return NULL;
}

void HashSchemes_Type::set_HashSha_256(const HashSha_256 & data)
{
    void *copy;

    copy = new HashSha_256(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 11;
	decoded = copy;
    }
}

HashSha_256 *HashSchemes_Type::release_HashSha_256()
{
    pdunum = 0;
    decoded = NULL;
    return get_HashSha_256();
}

void HashSchemes_Type::set_HashSha_256(HashSha_256 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 11;
    decoded = data;
}

void HashSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__shared1::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared1::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared1::__shared1() {
    memset(this, 0, sizeof(__shared1));
}

__shared1::__shared1(const __shared1 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__shared1)
}

__shared1::__shared1(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__shared1)
}

__shared1 & __shared1::operator = (const __shared1 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __shared1::operator == (const __shared1 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __shared1::operator != (const __shared1 & that) const {
    return !(operator ==(that));
}

__shared1::type_id & __shared1::get_type_id() {
    return type_id_field;
}

const __shared1::type_id & __shared1::get_type_id() const {
    return type_id_field;
}

void __shared1::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__shared1::value & __shared1::get_value() {
    return value_field;
}

const __shared1::value & __shared1::get_value() const {
    return value_field;
}

void __shared1::set_value(const value & value_val) {
    value_field = value_val;
}

void *LocationURL::operator new(size_t size) {
    return ossNewFunc(size);
}

void LocationURL::operator delete(void *ptr) {
    asn1Free(ptr);
}

LocationURL::LocationURL() {
    memset(this, 0, sizeof(LocationURL));
}

LocationURL::LocationURL(const LocationURL & that) {
    OSSTRY {
	value_field = that.value_field;
	apiVersion_field = that.apiVersion_field;
    } OSSCLEAN(LocationURL)
}

LocationURL::LocationURL(const value & value_val, apiVersion apiVersion_val) {
    OSSTRY {
	value_field = value_val;
	apiVersion_field = apiVersion_val;
    } OSSCLEAN(LocationURL)
}

LocationURL & LocationURL::operator = (const LocationURL & that) {
    if (this == &that)
	return *this;
    value_field = that.value_field;
    apiVersion_field = that.apiVersion_field;
    return *this;
}

int LocationURL::operator == (const LocationURL & that) const {
    if (value_field != that.value_field)
	return 0;
    if (apiVersion_field != that.apiVersion_field)
	return 0;
    return 1;
}

int LocationURL::operator != (const LocationURL & that) const {
    return !(operator ==(that));
}

LocationURL::value & LocationURL::get_value() {
    return value_field;
}

const LocationURL::value & LocationURL::get_value() const {
    return value_field;
}

void LocationURL::set_value(const value & value_val) {
    value_field = value_val;
}

LocationURL::apiVersion & LocationURL::get_apiVersion() {
    return apiVersion_field;
}

LocationURL::apiVersion LocationURL::get_apiVersion() const {
    return apiVersion_field;
}

void LocationURL::set_apiVersion(apiVersion apiVersion_val) {
    apiVersion_field = apiVersion_val;
}

void *LocationEthereum::operator new(size_t size) {
    return ossNewFunc(size);
}

void LocationEthereum::operator delete(void *ptr) {
    asn1Free(ptr);
}

LocationEthereum::LocationEthereum() {
    memset(this, 0, sizeof(LocationEthereum));
}

LocationEthereum::LocationEthereum(const LocationEthereum & that) {
    OSSTRY {
	chainID_field = that.chainID_field;
	contractAddress_field = that.contractAddress_field;
    } OSSCLEAN(LocationEthereum)
}

LocationEthereum::LocationEthereum(chainID chainID_val, contractAddress contractAddress_val) {
    OSSTRY {
	chainID_field = chainID_val;
	contractAddress_field = contractAddress_val;
    } OSSCLEAN(LocationEthereum)
}

LocationEthereum & LocationEthereum::operator = (const LocationEthereum & that) {
    if (this == &that)
	return *this;
    chainID_field = that.chainID_field;
    contractAddress_field = that.contractAddress_field;
    return *this;
}

int LocationEthereum::operator == (const LocationEthereum & that) const {
    if (chainID_field != that.chainID_field)
	return 0;
    if (contractAddress_field != that.contractAddress_field)
	return 0;
    return 1;
}

int LocationEthereum::operator != (const LocationEthereum & that) const {
    return !(operator ==(that));
}

LocationEthereum::chainID & LocationEthereum::get_chainID() {
    return chainID_field;
}

LocationEthereum::chainID LocationEthereum::get_chainID() const {
    return chainID_field;
}

void LocationEthereum::set_chainID(chainID chainID_val) {
    chainID_field = chainID_val;
}

LocationEthereum::contractAddress & LocationEthereum::get_contractAddress() {
    return contractAddress_field;
}

LocationEthereum::contractAddress LocationEthereum::get_contractAddress() const {
    return contractAddress_field;
}

void LocationEthereum::set_contractAddress(contractAddress contractAddress_val) {
    contractAddress_field = contractAddress_val;
}

LocationSchemes_Type::LocationSchemes_Type()
{
}

LocationSchemes_Type::LocationSchemes_Type(const LocationSchemes_Type & that)
{
    operator =(that);
}

LocationSchemes_Type::~LocationSchemes_Type()
{
    cleanup_decoded();
}

LocationSchemes_Type & LocationSchemes_Type::operator = (const LocationSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int LocationSchemes_Type::operator == (const LocationSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int LocationSchemes_Type::operator != (const LocationSchemes_Type & that) const
{
    return !(operator ==(that));
}

int LocationSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int LocationSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int LocationSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int LocationSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int LocationSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

LocationURL *LocationSchemes_Type::get_LocationURL()
{
    if (pdunum == 13)
	return (LocationURL *)decoded;
    else
	return NULL;
}

const LocationURL *LocationSchemes_Type::get_LocationURL() const
{
    if (pdunum == 13)
	return (const LocationURL *)decoded;
    else
	return NULL;
}

void LocationSchemes_Type::set_LocationURL(const LocationURL & data)
{
    void *copy;

    copy = new LocationURL(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 13;
	decoded = copy;
    }
}

LocationURL *LocationSchemes_Type::release_LocationURL()
{
    pdunum = 0;
    decoded = NULL;
    return get_LocationURL();
}

void LocationSchemes_Type::set_LocationURL(LocationURL *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 13;
    decoded = data;
}

LocationEthereum *LocationSchemes_Type::get_LocationEthereum()
{
    if (pdunum == 14)
	return (LocationEthereum *)decoded;
    else
	return NULL;
}

const LocationEthereum *LocationSchemes_Type::get_LocationEthereum() const
{
    if (pdunum == 14)
	return (const LocationEthereum *)decoded;
    else
	return NULL;
}

void LocationSchemes_Type::set_LocationEthereum(const LocationEthereum & data)
{
    void *copy;

    copy = new LocationEthereum(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 14;
	decoded = copy;
    }
}

LocationEthereum *LocationSchemes_Type::release_LocationEthereum()
{
    pdunum = 0;
    decoded = NULL;
    return get_LocationEthereum();
}

void LocationSchemes_Type::set_LocationEthereum(LocationEthereum *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 14;
    decoded = data;
}

void LocationSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *Location::operator new(size_t size) {
    return ossNewFunc(size);
}

void Location::operator delete(void *ptr) {
    asn1Free(ptr);
}

Location::Location() {
    memset(this, 0, sizeof(Location));
}

Location::Location(const Location & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(Location)
}

Location::Location(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(Location)
}

Location & Location::operator = (const Location & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int Location::operator == (const Location & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int Location::operator != (const Location & that) const {
    return !(operator ==(that));
}

Location::type_id & Location::get_type_id() {
    return type_id_field;
}

const Location::type_id & Location::get_type_id() const {
    return type_id_field;
}

void Location::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

Location::value & Location::get_value() {
    return value_field;
}

const Location::value & Location::get_value() const {
    return value_field;
}

void Location::set_value(const value & value_val) {
    value_field = value_val;
}

/* Auxiliary data structures and functions for class __seqof1 */

class __seqof1_member {
public:
    __seqof1_member *next;
    __seqof1::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof1_member();
    __seqof1_member(const __seqof1::component & val);
};

void *__seqof1_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof1_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof1_member::__seqof1_member() {
}

__seqof1_member::__seqof1_member(const __seqof1::component & val) {
    value = val;
}

static void *__seqof1_copy(void *that) {
    return new __seqof1_member(((__seqof1_member *)that)->value);
}

static void __seqof1_destroy(void *that) {
    delete (__seqof1_member *)that;
}

static int __seqof1_compare(void *val1, void *val2) {
    return (((__seqof1_member *)val1)->value == ((__seqof1_member *)val2)->value);
}

/* Constructors */

__seqof1::__seqof1() {
}

__seqof1::__seqof1(const __seqof1 & that) {
    OSSTRY {
	do_copy(that, &__seqof1_copy);
    } OSSCLEAN(__seqof1)
}

/* Destructor */

__seqof1::~__seqof1() {
    do_destroy(&__seqof1_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof1 & __seqof1::operator = (const __seqof1 & that) {
    do_destroy(&__seqof1_destroy);
    do_copy(that, &__seqof1_copy);
    return *this;
}

int __seqof1::operator == (const __seqof1 & that) const {
    return do_compare(that, &__seqof1_compare);
}

int __seqof1::operator != (const __seqof1 & that) const {
    return !do_compare(that, &__seqof1_compare);
}

/* Locate ("At" etc) methods */

__seqof1::component *__seqof1::at(OssIndex pos) {
    return &((__seqof1_member *)pos)->value;
}

const __seqof1::component *__seqof1::at(OssIndex pos) const {
    return &((__seqof1_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof1::prepend(const component & val) {
    __seqof1_member *newrec = new __seqof1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof1::prepend(__seqof1 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof1::insert_after(OssIndex pos, const component & val) {
    __seqof1_member *newrec = new __seqof1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof1::insert_after(OssIndex pos, __seqof1 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof1::remove_front() {
    __seqof1_member *extr = (__seqof1_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof1_destroy(extr);
    return 0;
}

int __seqof1::remove_after(OssIndex pos) {
    __seqof1_member *extr = (__seqof1_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof1_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof1 *__seqof1::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof1 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __shared2 */

class __shared2_member {
public:
    __shared2_member *next;
    __shared2::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared2_member();
    __shared2_member(const __shared2::component & val);
};

void *__shared2_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared2_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared2_member::__shared2_member() {
}

__shared2_member::__shared2_member(const __shared2::component & val) {
    value = val;
}

static void *__shared2_copy(void *that) {
    return new __shared2_member(((__shared2_member *)that)->value);
}

static void __shared2_destroy(void *that) {
    delete (__shared2_member *)that;
}

static int __shared2_compare(void *val1, void *val2) {
    return (((__shared2_member *)val1)->value == ((__shared2_member *)val2)->value);
}

/* Constructors */

__shared2::__shared2() {
}

__shared2::__shared2(const __shared2 & that) {
    OSSTRY {
	do_copy(that, &__shared2_copy);
    } OSSCLEAN(__shared2)
}

/* Destructor */

__shared2::~__shared2() {
    do_destroy(&__shared2_destroy);
}

/* Operators: assignment, equality, inequality */

__shared2 & __shared2::operator = (const __shared2 & that) {
    do_destroy(&__shared2_destroy);
    do_copy(that, &__shared2_copy);
    return *this;
}

int __shared2::operator == (const __shared2 & that) const {
    return do_compare(that, &__shared2_compare);
}

int __shared2::operator != (const __shared2 & that) const {
    return !do_compare(that, &__shared2_compare);
}

/* Locate ("At" etc) methods */

__shared2::component *__shared2::at(OssIndex pos) {
    return &((__shared2_member *)pos)->value;
}

const __shared2::component *__shared2::at(OssIndex pos) const {
    return &((__shared2_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared2::prepend(const component & val) {
    __shared2_member *newrec = new __shared2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared2::prepend(__shared2 *seq) {
    return do_prepend(seq);
}

OssIndex __shared2::insert_after(OssIndex pos, const component & val) {
    __shared2_member *newrec = new __shared2_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared2::insert_after(OssIndex pos, __shared2 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared2::remove_front() {
    __shared2_member *extr = (__shared2_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared2_destroy(extr);
    return 0;
}

int __shared2::remove_after(OssIndex pos) {
    __shared2_member *extr = (__shared2_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared2_destroy(extr);
    return 0;
}

/* Extract methods */

__shared2 *__shared2::extract_after(OssIndex begin, OssIndex end) {
    return (__shared2 *)do_extract_after(begin, end);
}

void *__seq5::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq5::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq5::__seq5() {
    memset(this, 0, sizeof(__seq5));
}

__seq5::__seq5(const __seq5 & that) {
    OSSTRY {
	notBefore_field = that.notBefore_field;
	notAfter_field = that.notAfter_field;
    } OSSCLEAN(__seq5)
}

__seq5::__seq5(const notBefore & notBefore_val, const notAfter & notAfter_val) {
    OSSTRY {
	notBefore_field = notBefore_val;
	notAfter_field = notAfter_val;
    } OSSCLEAN(__seq5)
}

__seq5 & __seq5::operator = (const __seq5 & that) {
    if (this == &that)
	return *this;
    notBefore_field = that.notBefore_field;
    notAfter_field = that.notAfter_field;
    return *this;
}

int __seq5::operator == (const __seq5 & that) const {
    if (notBefore_field != that.notBefore_field)
	return 0;
    if (notAfter_field != that.notAfter_field)
	return 0;
    return 1;
}

int __seq5::operator != (const __seq5 & that) const {
    return !(operator ==(that));
}

__seq5::notBefore & __seq5::get_notBefore() {
    return notBefore_field;
}

const __seq5::notBefore & __seq5::get_notBefore() const {
    return notBefore_field;
}

void __seq5::set_notBefore(const notBefore & notBefore_val) {
    notBefore_field = notBefore_val;
}

__seq5::notAfter & __seq5::get_notAfter() {
    return notAfter_field;
}

const __seq5::notAfter & __seq5::get_notAfter() const {
    return notAfter_field;
}

void __seq5::set_notAfter(const notAfter & notAfter_val) {
    notAfter_field = notAfter_val;
}

void *TrustLevel::operator new(size_t size) {
    return ossNewFunc(size);
}

void TrustLevel::operator delete(void *ptr) {
    asn1Free(ptr);
}

TrustLevel::TrustLevel() {
    memset(this, 0, sizeof(TrustLevel));
}

TrustLevel::TrustLevel(const TrustLevel & that) {
    OSSTRY {
	trust_field = that.trust_field;
    } OSSCLEAN(TrustLevel)
}

TrustLevel::TrustLevel(trust trust_val) {
    OSSTRY {
	trust_field = trust_val;
    } OSSCLEAN(TrustLevel)
}

TrustLevel & TrustLevel::operator = (const TrustLevel & that) {
    if (this == &that)
	return *this;
    trust_field = that.trust_field;
    return *this;
}

int TrustLevel::operator == (const TrustLevel & that) const {
    if (trust_field != that.trust_field)
	return 0;
    return 1;
}

int TrustLevel::operator != (const TrustLevel & that) const {
    return !(operator ==(that));
}

TrustLevel::trust & TrustLevel::get_trust() {
    return trust_field;
}

TrustLevel::trust TrustLevel::get_trust() const {
    return trust_field;
}

void TrustLevel::set_trust(trust trust_val) {
    trust_field = trust_val;
}

/* Auxiliary data structures and functions for class __seqof15 */

class __seqof15_member {
public:
    __seqof15_member *next;
    __seqof15::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof15_member();
    __seqof15_member(const __seqof15::component & val);
};

void *__seqof15_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof15_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof15_member::__seqof15_member() {
}

__seqof15_member::__seqof15_member(const __seqof15::component & val) {
    value = val;
}

static void *__seqof15_copy(void *that) {
    return new __seqof15_member(((__seqof15_member *)that)->value);
}

static void __seqof15_destroy(void *that) {
    delete (__seqof15_member *)that;
}

static int __seqof15_compare(void *val1, void *val2) {
    return (((__seqof15_member *)val1)->value == ((__seqof15_member *)val2)->value);
}

/* Constructors */

__seqof15::__seqof15() {
}

__seqof15::__seqof15(const __seqof15 & that) {
    OSSTRY {
	do_copy(that, &__seqof15_copy);
    } OSSCLEAN(__seqof15)
}

/* Destructor */

__seqof15::~__seqof15() {
    do_destroy(&__seqof15_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof15 & __seqof15::operator = (const __seqof15 & that) {
    do_destroy(&__seqof15_destroy);
    do_copy(that, &__seqof15_copy);
    return *this;
}

int __seqof15::operator == (const __seqof15 & that) const {
    return do_compare(that, &__seqof15_compare);
}

int __seqof15::operator != (const __seqof15 & that) const {
    return !do_compare(that, &__seqof15_compare);
}

/* Locate ("At" etc) methods */

__seqof15::component *__seqof15::at(OssIndex pos) {
    return &((__seqof15_member *)pos)->value;
}

const __seqof15::component *__seqof15::at(OssIndex pos) const {
    return &((__seqof15_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof15::prepend(const component & val) {
    __seqof15_member *newrec = new __seqof15_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof15::prepend(__seqof15 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof15::insert_after(OssIndex pos, const component & val) {
    __seqof15_member *newrec = new __seqof15_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof15::insert_after(OssIndex pos, __seqof15 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof15::remove_front() {
    __seqof15_member *extr = (__seqof15_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof15_destroy(extr);
    return 0;
}

int __seqof15::remove_after(OssIndex pos) {
    __seqof15_member *extr = (__seqof15_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof15_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof15 *__seqof15::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof15 *)do_extract_after(begin, end);
}

void *RTreePolicy::operator new(size_t size) {
    return ossNewFunc(size);
}

void RTreePolicy::operator delete(void *ptr) {
    asn1Free(ptr);
}

RTreePolicy::RTreePolicy() {
    memset(this, 0, sizeof(RTreePolicy));
}

RTreePolicy::RTreePolicy(const RTreePolicy & that) {
    OSSTRY {
	RTreePolicy_namespace_field = that.RTreePolicy_namespace_field;
	indirections_field = that.indirections_field;
	statements_field = that.statements_field;
    } OSSCLEAN(RTreePolicy)
}

RTreePolicy::RTreePolicy(const RTreePolicy_namespace & RTreePolicy_namespace_val, 
    indirections indirections_val, const statements & statements_val) {
    OSSTRY {
	RTreePolicy_namespace_field = RTreePolicy_namespace_val;
	indirections_field = indirections_val;
	statements_field = statements_val;
    } OSSCLEAN(RTreePolicy)
}

RTreePolicy & RTreePolicy::operator = (const RTreePolicy & that) {
    if (this == &that)
	return *this;
    RTreePolicy_namespace_field = that.RTreePolicy_namespace_field;
    indirections_field = that.indirections_field;
    statements_field = that.statements_field;
    return *this;
}

int RTreePolicy::operator == (const RTreePolicy & that) const {
    if (RTreePolicy_namespace_field != that.RTreePolicy_namespace_field)
	return 0;
    if (indirections_field != that.indirections_field)
	return 0;
    if (statements_field != that.statements_field)
	return 0;
    return 1;
}

int RTreePolicy::operator != (const RTreePolicy & that) const {
    return !(operator ==(that));
}

RTreePolicy::RTreePolicy_namespace & RTreePolicy::get_RTreePolicy_namespace() {
    return RTreePolicy_namespace_field;
}

const RTreePolicy::RTreePolicy_namespace & RTreePolicy::get_RTreePolicy_namespace() const {
    return RTreePolicy_namespace_field;
}

void RTreePolicy::set_RTreePolicy_namespace(const RTreePolicy_namespace & RTreePolicy_namespace_val) {
    RTreePolicy_namespace_field = RTreePolicy_namespace_val;
}

RTreePolicy::indirections & RTreePolicy::get_indirections() {
    return indirections_field;
}

RTreePolicy::indirections RTreePolicy::get_indirections() const {
    return indirections_field;
}

void RTreePolicy::set_indirections(indirections indirections_val) {
    indirections_field = indirections_val;
}

RTreePolicy::statements & RTreePolicy::get_statements() {
    return statements_field;
}

const RTreePolicy::statements & RTreePolicy::get_statements() const {
    return statements_field;
}

void RTreePolicy::set_statements(const statements & statements_val) {
    statements_field = statements_val;
}

PolicySchemes_Type::PolicySchemes_Type()
{
}

PolicySchemes_Type::PolicySchemes_Type(const PolicySchemes_Type & that)
{
    operator =(that);
}

PolicySchemes_Type::~PolicySchemes_Type()
{
    cleanup_decoded();
}

PolicySchemes_Type & PolicySchemes_Type::operator = (const PolicySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int PolicySchemes_Type::operator == (const PolicySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int PolicySchemes_Type::operator != (const PolicySchemes_Type & that) const
{
    return !(operator ==(that));
}

int PolicySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int PolicySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int PolicySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int PolicySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int PolicySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

TrustLevel *PolicySchemes_Type::get_TrustLevel()
{
    if (pdunum == 22)
	return (TrustLevel *)decoded;
    else
	return NULL;
}

const TrustLevel *PolicySchemes_Type::get_TrustLevel() const
{
    if (pdunum == 22)
	return (const TrustLevel *)decoded;
    else
	return NULL;
}

void PolicySchemes_Type::set_TrustLevel(const TrustLevel & data)
{
    void *copy;

    copy = new TrustLevel(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 22;
	decoded = copy;
    }
}

TrustLevel *PolicySchemes_Type::release_TrustLevel()
{
    pdunum = 0;
    decoded = NULL;
    return get_TrustLevel();
}

void PolicySchemes_Type::set_TrustLevel(TrustLevel *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 22;
    decoded = data;
}

RTreePolicy *PolicySchemes_Type::get_RTreePolicy()
{
    if (pdunum == 9)
	return (RTreePolicy *)decoded;
    else
	return NULL;
}

const RTreePolicy *PolicySchemes_Type::get_RTreePolicy() const
{
    if (pdunum == 9)
	return (const RTreePolicy *)decoded;
    else
	return NULL;
}

void PolicySchemes_Type::set_RTreePolicy(const RTreePolicy & data)
{
    void *copy;

    copy = new RTreePolicy(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 9;
	decoded = copy;
    }
}

RTreePolicy *PolicySchemes_Type::release_RTreePolicy()
{
    pdunum = 0;
    decoded = NULL;
    return get_RTreePolicy();
}

void PolicySchemes_Type::set_RTreePolicy(RTreePolicy *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 9;
    decoded = data;
}

void PolicySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq6::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq6::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq6::__seq6() {
    memset(this, 0, sizeof(__seq6));
}

__seq6::__seq6(const __seq6 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq6)
}

__seq6::__seq6(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq6)
}

__seq6 & __seq6::operator = (const __seq6 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq6::operator == (const __seq6 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq6::operator != (const __seq6 & that) const {
    return !(operator ==(that));
}

__seq6::type_id & __seq6::get_type_id() {
    return type_id_field;
}

const __seq6::type_id & __seq6::get_type_id() const {
    return type_id_field;
}

void __seq6::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq6::value & __seq6::get_value() {
    return value_field;
}

const __seq6::value & __seq6::get_value() const {
    return value_field;
}

void __seq6::set_value(const value & value_val) {
    value_field = value_val;
}

void *__seq11::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq11::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq11::__seq11() {
    memset(this, 0, sizeof(__seq11));
}

__seq11::__seq11(const __seq11 & that) {
    OSSTRY {
	outerSignatureScheme_field = that.outerSignatureScheme_field;
	verifyingKey_field = that.verifyingKey_field;
    } OSSCLEAN(__seq11)
}

__seq11::__seq11(const outerSignatureScheme & outerSignatureScheme_val, const verifyingKey & verifyingKey_val) {
    OSSTRY {
	outerSignatureScheme_field = outerSignatureScheme_val;
	verifyingKey_field = verifyingKey_val;
    } OSSCLEAN(__seq11)
}

__seq11 & __seq11::operator = (const __seq11 & that) {
    if (this == &that)
	return *this;
    outerSignatureScheme_field = that.outerSignatureScheme_field;
    verifyingKey_field = that.verifyingKey_field;
    return *this;
}

int __seq11::operator == (const __seq11 & that) const {
    if (outerSignatureScheme_field != that.outerSignatureScheme_field)
	return 0;
    if (verifyingKey_field != that.verifyingKey_field)
	return 0;
    return 1;
}

int __seq11::operator != (const __seq11 & that) const {
    return !(operator ==(that));
}

__seq11::outerSignatureScheme & __seq11::get_outerSignatureScheme() {
    return outerSignatureScheme_field;
}

const __seq11::outerSignatureScheme & __seq11::get_outerSignatureScheme() const {
    return outerSignatureScheme_field;
}

void __seq11::set_outerSignatureScheme(const outerSignatureScheme & outerSignatureScheme_val) {
    outerSignatureScheme_field = outerSignatureScheme_val;
}

__seq11::verifyingKey & __seq11::get_verifyingKey() {
    return verifyingKey_field;
}

const __seq11::verifyingKey & __seq11::get_verifyingKey() const {
    return verifyingKey_field;
}

void __seq11::set_verifyingKey(const verifyingKey & verifyingKey_val) {
    verifyingKey_field = verifyingKey_val;
}

void *SignedOuterKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void SignedOuterKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

SignedOuterKey::SignedOuterKey() {
    memset(this, 0, sizeof(SignedOuterKey));
}

SignedOuterKey::SignedOuterKey(const SignedOuterKey & that) {
    OSSTRY {
	tbs_field = that.tbs_field;
	signature_field = that.signature_field;
    } OSSCLEAN(SignedOuterKey)
}

SignedOuterKey::SignedOuterKey(const tbs & tbs_val, const signature & signature_val) {
    OSSTRY {
	tbs_field = tbs_val;
	signature_field = signature_val;
    } OSSCLEAN(SignedOuterKey)
}

SignedOuterKey & SignedOuterKey::operator = (const SignedOuterKey & that) {
    if (this == &that)
	return *this;
    tbs_field = that.tbs_field;
    signature_field = that.signature_field;
    return *this;
}

int SignedOuterKey::operator == (const SignedOuterKey & that) const {
    if (tbs_field != that.tbs_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    return 1;
}

int SignedOuterKey::operator != (const SignedOuterKey & that) const {
    return !(operator ==(that));
}

SignedOuterKey::tbs & SignedOuterKey::get_tbs() {
    return tbs_field;
}

const SignedOuterKey::tbs & SignedOuterKey::get_tbs() const {
    return tbs_field;
}

void SignedOuterKey::set_tbs(const tbs & tbs_val) {
    tbs_field = tbs_val;
}

SignedOuterKey::signature & SignedOuterKey::get_signature() {
    return signature_field;
}

const SignedOuterKey::signature & SignedOuterKey::get_signature() const {
    return signature_field;
}

void SignedOuterKey::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

OuterSignatureBindingSchemes_Type::OuterSignatureBindingSchemes_Type()
{
}

OuterSignatureBindingSchemes_Type::OuterSignatureBindingSchemes_Type(const OuterSignatureBindingSchemes_Type & that)
{
    operator =(that);
}

OuterSignatureBindingSchemes_Type::~OuterSignatureBindingSchemes_Type()
{
    cleanup_decoded();
}

OuterSignatureBindingSchemes_Type & OuterSignatureBindingSchemes_Type::operator = (const OuterSignatureBindingSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int OuterSignatureBindingSchemes_Type::operator == (const OuterSignatureBindingSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int OuterSignatureBindingSchemes_Type::operator != (const OuterSignatureBindingSchemes_Type & that) const
{
    return !(operator ==(that));
}

int OuterSignatureBindingSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int OuterSignatureBindingSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int OuterSignatureBindingSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int OuterSignatureBindingSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int OuterSignatureBindingSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

SignedOuterKey *OuterSignatureBindingSchemes_Type::get_SignedOuterKey()
{
    if (pdunum == 21)
	return (SignedOuterKey *)decoded;
    else
	return NULL;
}

const SignedOuterKey *OuterSignatureBindingSchemes_Type::get_SignedOuterKey() const
{
    if (pdunum == 21)
	return (const SignedOuterKey *)decoded;
    else
	return NULL;
}

void OuterSignatureBindingSchemes_Type::set_SignedOuterKey(const SignedOuterKey & data)
{
    void *copy;

    copy = new SignedOuterKey(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 21;
	decoded = copy;
    }
}

SignedOuterKey *OuterSignatureBindingSchemes_Type::release_SignedOuterKey()
{
    pdunum = 0;
    decoded = NULL;
    return get_SignedOuterKey();
}

void OuterSignatureBindingSchemes_Type::set_SignedOuterKey(SignedOuterKey *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 21;
    decoded = data;
}

void OuterSignatureBindingSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq7::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq7::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq7::__seq7() {
    memset(this, 0, sizeof(__seq7));
}

__seq7::__seq7(const __seq7 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq7)
}

__seq7::__seq7(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq7)
}

__seq7 & __seq7::operator = (const __seq7 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq7::operator == (const __seq7 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq7::operator != (const __seq7 & that) const {
    return !(operator ==(that));
}

__seq7::type_id & __seq7::get_type_id() {
    return type_id_field;
}

const __seq7::type_id & __seq7::get_type_id() const {
    return type_id_field;
}

void __seq7::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq7::value & __seq7::get_value() {
    return value_field;
}

const __seq7::value & __seq7::get_value() const {
    return value_field;
}

void __seq7::set_value(const value & value_val) {
    value_field = value_val;
}

void *AttestationVerifierBody::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttestationVerifierBody::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttestationVerifierBody::AttestationVerifierBody() {
    memset(this, 0, sizeof(AttestationVerifierBody));
}

AttestationVerifierBody::AttestationVerifierBody(const AttestationVerifierBody & that) {
    OSSTRY {
	attester_field = that.attester_field;
	attesterLocation_field = that.attesterLocation_field;
	validity_field = that.validity_field;
	policy_field = that.policy_field;
	extensions_field = that.extensions_field;
	outerSignatureBinding_field = that.outerSignatureBinding_field;
    } OSSCLEAN(AttestationVerifierBody)
}

AttestationVerifierBody::AttestationVerifierBody(const attester & attester_val, const attesterLocation & attesterLocation_val, 
    const validity & validity_val, const policy & policy_val, const extensions & extensions_val, 
    const outerSignatureBinding & outerSignatureBinding_val) {
    OSSTRY {
	attester_field = attester_val;
	attesterLocation_field = attesterLocation_val;
	validity_field = validity_val;
	policy_field = policy_val;
	extensions_field = extensions_val;
	outerSignatureBinding_field = outerSignatureBinding_val;
    } OSSCLEAN(AttestationVerifierBody)
}

AttestationVerifierBody & AttestationVerifierBody::operator = (const AttestationVerifierBody & that) {
    if (this == &that)
	return *this;
    attester_field = that.attester_field;
    attesterLocation_field = that.attesterLocation_field;
    validity_field = that.validity_field;
    policy_field = that.policy_field;
    extensions_field = that.extensions_field;
    outerSignatureBinding_field = that.outerSignatureBinding_field;
    return *this;
}

int AttestationVerifierBody::operator == (const AttestationVerifierBody & that) const {
    if (attester_field != that.attester_field)
	return 0;
    if (attesterLocation_field != that.attesterLocation_field)
	return 0;
    if (validity_field != that.validity_field)
	return 0;
    if (policy_field != that.policy_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    if (outerSignatureBinding_field != that.outerSignatureBinding_field)
	return 0;
    return 1;
}

int AttestationVerifierBody::operator != (const AttestationVerifierBody & that) const {
    return !(operator ==(that));
}

AttestationVerifierBody::attester & AttestationVerifierBody::get_attester() {
    return attester_field;
}

const AttestationVerifierBody::attester & AttestationVerifierBody::get_attester() const {
    return attester_field;
}

void AttestationVerifierBody::set_attester(const attester & attester_val) {
    attester_field = attester_val;
}

AttestationVerifierBody::attesterLocation & AttestationVerifierBody::get_attesterLocation() {
    return attesterLocation_field;
}

const AttestationVerifierBody::attesterLocation & AttestationVerifierBody::get_attesterLocation() const {
    return attesterLocation_field;
}

void AttestationVerifierBody::set_attesterLocation(const attesterLocation & attesterLocation_val) {
    attesterLocation_field = attesterLocation_val;
}

AttestationVerifierBody::validity & AttestationVerifierBody::get_validity() {
    return validity_field;
}

const AttestationVerifierBody::validity & AttestationVerifierBody::get_validity() const {
    return validity_field;
}

void AttestationVerifierBody::set_validity(const validity & validity_val) {
    validity_field = validity_val;
}

AttestationVerifierBody::policy & AttestationVerifierBody::get_policy() {
    return policy_field;
}

const AttestationVerifierBody::policy & AttestationVerifierBody::get_policy() const {
    return policy_field;
}

void AttestationVerifierBody::set_policy(const policy & policy_val) {
    policy_field = policy_val;
}

AttestationVerifierBody::extensions & AttestationVerifierBody::get_extensions() {
    return extensions_field;
}

const AttestationVerifierBody::extensions & AttestationVerifierBody::get_extensions() const {
    return extensions_field;
}

void AttestationVerifierBody::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

AttestationVerifierBody::outerSignatureBinding & AttestationVerifierBody::get_outerSignatureBinding() {
    return outerSignatureBinding_field;
}

const AttestationVerifierBody::outerSignatureBinding & AttestationVerifierBody::get_outerSignatureBinding() const {
    return outerSignatureBinding_field;
}

void AttestationVerifierBody::set_outerSignatureBinding(const outerSignatureBinding & outerSignatureBinding_val) {
    outerSignatureBinding_field = outerSignatureBinding_val;
}

/* Auxiliary data structures and functions for class __seqof3 */

class __seqof3_member {
public:
    __seqof3_member *next;
    __seqof3::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof3_member();
    __seqof3_member(const __seqof3::component & val);
};

void *__seqof3_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof3_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof3_member::__seqof3_member() {
}

__seqof3_member::__seqof3_member(const __seqof3::component & val) {
    value = val;
}

static void *__seqof3_copy(void *that) {
    return new __seqof3_member(((__seqof3_member *)that)->value);
}

static void __seqof3_destroy(void *that) {
    delete (__seqof3_member *)that;
}

static int __seqof3_compare(void *val1, void *val2) {
    return (((__seqof3_member *)val1)->value == ((__seqof3_member *)val2)->value);
}

/* Constructors */

__seqof3::__seqof3() {
}

__seqof3::__seqof3(const __seqof3 & that) {
    OSSTRY {
	do_copy(that, &__seqof3_copy);
    } OSSCLEAN(__seqof3)
}

/* Destructor */

__seqof3::~__seqof3() {
    do_destroy(&__seqof3_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof3 & __seqof3::operator = (const __seqof3 & that) {
    do_destroy(&__seqof3_destroy);
    do_copy(that, &__seqof3_copy);
    return *this;
}

int __seqof3::operator == (const __seqof3 & that) const {
    return do_compare(that, &__seqof3_compare);
}

int __seqof3::operator != (const __seqof3 & that) const {
    return !do_compare(that, &__seqof3_compare);
}

/* Locate ("At" etc) methods */

__seqof3::component *__seqof3::at(OssIndex pos) {
    return &((__seqof3_member *)pos)->value;
}

const __seqof3::component *__seqof3::at(OssIndex pos) const {
    return &((__seqof3_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof3::prepend(const component & val) {
    __seqof3_member *newrec = new __seqof3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof3::prepend(__seqof3 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof3::insert_after(OssIndex pos, const component & val) {
    __seqof3_member *newrec = new __seqof3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof3::insert_after(OssIndex pos, __seqof3 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof3::remove_front() {
    __seqof3_member *extr = (__seqof3_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof3_destroy(extr);
    return 0;
}

int __seqof3::remove_after(OssIndex pos) {
    __seqof3_member *extr = (__seqof3_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof3_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof3 *__seqof3::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof3 *)do_extract_after(begin, end);
}

void *AttestationBody::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttestationBody::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttestationBody::AttestationBody() {
    memset(this, 0, sizeof(AttestationBody));
}

AttestationBody::AttestationBody(const AttestationBody & that) {
    OSSTRY {
	verifierBody_field = that.verifierBody_field;
	proverPolicyAddendums_field = that.proverPolicyAddendums_field;
	proverExtensions_field = that.proverExtensions_field;
    } OSSCLEAN(AttestationBody)
}

AttestationBody::AttestationBody(const verifierBody & verifierBody_val, const proverPolicyAddendums & proverPolicyAddendums_val, 
    const proverExtensions & proverExtensions_val) {
    OSSTRY {
	verifierBody_field = verifierBody_val;
	proverPolicyAddendums_field = proverPolicyAddendums_val;
	proverExtensions_field = proverExtensions_val;
    } OSSCLEAN(AttestationBody)
}

AttestationBody & AttestationBody::operator = (const AttestationBody & that) {
    if (this == &that)
	return *this;
    verifierBody_field = that.verifierBody_field;
    proverPolicyAddendums_field = that.proverPolicyAddendums_field;
    proverExtensions_field = that.proverExtensions_field;
    return *this;
}

int AttestationBody::operator == (const AttestationBody & that) const {
    if (verifierBody_field != that.verifierBody_field)
	return 0;
    if (proverPolicyAddendums_field != that.proverPolicyAddendums_field)
	return 0;
    if (proverExtensions_field != that.proverExtensions_field)
	return 0;
    return 1;
}

int AttestationBody::operator != (const AttestationBody & that) const {
    return !(operator ==(that));
}

AttestationBody::verifierBody & AttestationBody::get_verifierBody() {
    return verifierBody_field;
}

const AttestationBody::verifierBody & AttestationBody::get_verifierBody() const {
    return verifierBody_field;
}

void AttestationBody::set_verifierBody(const verifierBody & verifierBody_val) {
    verifierBody_field = verifierBody_val;
}

AttestationBody::proverPolicyAddendums & AttestationBody::get_proverPolicyAddendums() {
    return proverPolicyAddendums_field;
}

const AttestationBody::proverPolicyAddendums & AttestationBody::get_proverPolicyAddendums() const {
    return proverPolicyAddendums_field;
}

void AttestationBody::set_proverPolicyAddendums(const proverPolicyAddendums & proverPolicyAddendums_val) {
    proverPolicyAddendums_field = proverPolicyAddendums_val;
}

AttestationBody::proverExtensions & AttestationBody::get_proverExtensions() {
    return proverExtensions_field;
}

const AttestationBody::proverExtensions & AttestationBody::get_proverExtensions() const {
    return proverExtensions_field;
}

void AttestationBody::set_proverExtensions(const proverExtensions & proverExtensions_val) {
    proverExtensions_field = proverExtensions_val;
}

void *WR1BodyCiphertext::operator new(size_t size) {
    return ossNewFunc(size);
}

void WR1BodyCiphertext::operator delete(void *ptr) {
    asn1Free(ptr);
}

WR1BodyCiphertext::WR1BodyCiphertext() {
    memset(this, 0, sizeof(WR1BodyCiphertext));
}

WR1BodyCiphertext::WR1BodyCiphertext(const WR1BodyCiphertext & that) {
    OSSTRY {
	verifierBodyCiphertext_field = that.verifierBodyCiphertext_field;
	proverBodyCiphertext_field = that.proverBodyCiphertext_field;
	envelopeCiphertext_field = that.envelopeCiphertext_field;
	envelopeKey_ibe_bn256_field = that.envelopeKey_ibe_bn256_field;
	envelopeKey_curve25519_field = that.envelopeKey_curve25519_field;
    } OSSCLEAN(WR1BodyCiphertext)
}

WR1BodyCiphertext::WR1BodyCiphertext(const verifierBodyCiphertext & verifierBodyCiphertext_val, 
    const proverBodyCiphertext & proverBodyCiphertext_val, const envelopeCiphertext & envelopeCiphertext_val, 
    const envelopeKey_ibe_bn256 & envelopeKey_ibe_bn256_val, const envelopeKey_curve25519 & envelopeKey_curve25519_val) {
    OSSTRY {
	verifierBodyCiphertext_field = verifierBodyCiphertext_val;
	proverBodyCiphertext_field = proverBodyCiphertext_val;
	envelopeCiphertext_field = envelopeCiphertext_val;
	envelopeKey_ibe_bn256_field = envelopeKey_ibe_bn256_val;
	envelopeKey_curve25519_field = envelopeKey_curve25519_val;
    } OSSCLEAN(WR1BodyCiphertext)
}

WR1BodyCiphertext & WR1BodyCiphertext::operator = (const WR1BodyCiphertext & that) {
    if (this == &that)
	return *this;
    verifierBodyCiphertext_field = that.verifierBodyCiphertext_field;
    proverBodyCiphertext_field = that.proverBodyCiphertext_field;
    envelopeCiphertext_field = that.envelopeCiphertext_field;
    envelopeKey_ibe_bn256_field = that.envelopeKey_ibe_bn256_field;
    envelopeKey_curve25519_field = that.envelopeKey_curve25519_field;
    return *this;
}

int WR1BodyCiphertext::operator == (const WR1BodyCiphertext & that) const {
    if (verifierBodyCiphertext_field != that.verifierBodyCiphertext_field)
	return 0;
    if (proverBodyCiphertext_field != that.proverBodyCiphertext_field)
	return 0;
    if (envelopeCiphertext_field != that.envelopeCiphertext_field)
	return 0;
    if (envelopeKey_ibe_bn256_field != that.envelopeKey_ibe_bn256_field)
	return 0;
    if (envelopeKey_curve25519_field != that.envelopeKey_curve25519_field)
	return 0;
    return 1;
}

int WR1BodyCiphertext::operator != (const WR1BodyCiphertext & that) const {
    return !(operator ==(that));
}

WR1BodyCiphertext::verifierBodyCiphertext & WR1BodyCiphertext::get_verifierBodyCiphertext() {
    return verifierBodyCiphertext_field;
}

const WR1BodyCiphertext::verifierBodyCiphertext & WR1BodyCiphertext::get_verifierBodyCiphertext() const {
    return verifierBodyCiphertext_field;
}

void WR1BodyCiphertext::set_verifierBodyCiphertext(const verifierBodyCiphertext & verifierBodyCiphertext_val) {
    verifierBodyCiphertext_field = verifierBodyCiphertext_val;
}

WR1BodyCiphertext::proverBodyCiphertext & WR1BodyCiphertext::get_proverBodyCiphertext() {
    return proverBodyCiphertext_field;
}

const WR1BodyCiphertext::proverBodyCiphertext & WR1BodyCiphertext::get_proverBodyCiphertext() const {
    return proverBodyCiphertext_field;
}

void WR1BodyCiphertext::set_proverBodyCiphertext(const proverBodyCiphertext & proverBodyCiphertext_val) {
    proverBodyCiphertext_field = proverBodyCiphertext_val;
}

WR1BodyCiphertext::envelopeCiphertext & WR1BodyCiphertext::get_envelopeCiphertext() {
    return envelopeCiphertext_field;
}

const WR1BodyCiphertext::envelopeCiphertext & WR1BodyCiphertext::get_envelopeCiphertext() const {
    return envelopeCiphertext_field;
}

void WR1BodyCiphertext::set_envelopeCiphertext(const envelopeCiphertext & envelopeCiphertext_val) {
    envelopeCiphertext_field = envelopeCiphertext_val;
}

WR1BodyCiphertext::envelopeKey_ibe_bn256 & WR1BodyCiphertext::get_envelopeKey_ibe_bn256() {
    return envelopeKey_ibe_bn256_field;
}

const WR1BodyCiphertext::envelopeKey_ibe_bn256 & WR1BodyCiphertext::get_envelopeKey_ibe_bn256() const {
    return envelopeKey_ibe_bn256_field;
}

void WR1BodyCiphertext::set_envelopeKey_ibe_bn256(const envelopeKey_ibe_bn256 & envelopeKey_ibe_bn256_val) {
    envelopeKey_ibe_bn256_field = envelopeKey_ibe_bn256_val;
}

WR1BodyCiphertext::envelopeKey_curve25519 & WR1BodyCiphertext::get_envelopeKey_curve25519() {
    return envelopeKey_curve25519_field;
}

const WR1BodyCiphertext::envelopeKey_curve25519 & WR1BodyCiphertext::get_envelopeKey_curve25519() const {
    return envelopeKey_curve25519_field;
}

void WR1BodyCiphertext::set_envelopeKey_curve25519(const envelopeKey_curve25519 & envelopeKey_curve25519_val) {
    envelopeKey_curve25519_field = envelopeKey_curve25519_val;
}

/* Auxiliary data structures and functions for class __shared4 */

class __shared4_member {
public:
    __shared4_member *next;
    __shared4::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
};

void *__shared4_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared4_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

static void *__shared4_copy(void *that) {
    __shared4_member *result = new __shared4_member;
    if (result)
	result->value = ((__shared4_member *)that)->value;
    return result;
}

static void __shared4_destroy(void *that) {
    delete (__shared4_member *)that;
}

static int __shared4_compare(void *val1, void *val2) {
    return (((__shared4_member *)val1)->value == ((__shared4_member *)val2)->value);
}

/* Constructors */

__shared4::__shared4() {
}

__shared4::__shared4(const __shared4 & that) {
    OSSTRY {
	do_copy(that, &__shared4_copy);
    } OSSCLEAN(__shared4)
}

/* Destructor */

__shared4::~__shared4() {
    do_destroy(&__shared4_destroy);
}

/* Operators: assignment, equality, inequality */

__shared4 & __shared4::operator = (const __shared4 & that) {
    do_destroy(&__shared4_destroy);
    do_copy(that, &__shared4_copy);
    return *this;
}

int __shared4::operator == (const __shared4 & that) const {
    return do_compare(that, &__shared4_compare);
}

int __shared4::operator != (const __shared4 & that) const {
    return !do_compare(that, &__shared4_compare);
}

/* Locate ("At" etc) methods */

__shared4::component *__shared4::at(OssIndex pos) {
    return &((__shared4_member *)pos)->value;
}

const __shared4::component *__shared4::at(OssIndex pos) const {
    return &((__shared4_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared4::prepend(component val) {
    __shared4_member *newrec = new __shared4_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_prepend(newrec);
}

OssIndex __shared4::prepend(__shared4 *seq) {
    return do_prepend(seq);
}

OssIndex __shared4::insert_after(OssIndex pos, component val) {
    __shared4_member *newrec = new __shared4_member();
    if (!newrec)
	return OSS_NOINDEX;
    newrec->value = val;
    return do_insert_after(pos, newrec);
}

OssIndex __shared4::insert_after(OssIndex pos, __shared4 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared4::remove_front() {
    __shared4_member *extr = (__shared4_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared4_destroy(extr);
    return 0;
}

int __shared4::remove_after(OssIndex pos) {
    __shared4_member *extr = (__shared4_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared4_destroy(extr);
    return 0;
}

/* Extract methods */

__shared4 *__shared4::extract_after(OssIndex begin, OssIndex end) {
    return (__shared4 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __shared3 */

class __shared3_member {
public:
    __shared3_member *next;
    __shared3::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __shared3_member();
    __shared3_member(const __shared3::component & val);
};

void *__shared3_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __shared3_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__shared3_member::__shared3_member() {
}

__shared3_member::__shared3_member(const __shared3::component & val) {
    value = val;
}

static void *__shared3_copy(void *that) {
    return new __shared3_member(((__shared3_member *)that)->value);
}

static void __shared3_destroy(void *that) {
    delete (__shared3_member *)that;
}

static int __shared3_compare(void *val1, void *val2) {
    return (((__shared3_member *)val1)->value == ((__shared3_member *)val2)->value);
}

/* Constructors */

__shared3::__shared3() {
}

__shared3::__shared3(const __shared3 & that) {
    OSSTRY {
	do_copy(that, &__shared3_copy);
    } OSSCLEAN(__shared3)
}

/* Destructor */

__shared3::~__shared3() {
    do_destroy(&__shared3_destroy);
}

/* Operators: assignment, equality, inequality */

__shared3 & __shared3::operator = (const __shared3 & that) {
    do_destroy(&__shared3_destroy);
    do_copy(that, &__shared3_copy);
    return *this;
}

int __shared3::operator == (const __shared3 & that) const {
    return do_compare(that, &__shared3_compare);
}

int __shared3::operator != (const __shared3 & that) const {
    return !do_compare(that, &__shared3_compare);
}

/* Locate ("At" etc) methods */

__shared3::component *__shared3::at(OssIndex pos) {
    return &((__shared3_member *)pos)->value;
}

const __shared3::component *__shared3::at(OssIndex pos) const {
    return &((__shared3_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __shared3::prepend(const component & val) {
    __shared3_member *newrec = new __shared3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __shared3::prepend(__shared3 *seq) {
    return do_prepend(seq);
}

OssIndex __shared3::insert_after(OssIndex pos, const component & val) {
    __shared3_member *newrec = new __shared3_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __shared3::insert_after(OssIndex pos, __shared3 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __shared3::remove_front() {
    __shared3_member *extr = (__shared3_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared3_destroy(extr);
    return 0;
}

int __shared3::remove_after(OssIndex pos) {
    __shared3_member *extr = (__shared3_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __shared3_destroy(extr);
    return 0;
}

/* Extract methods */

__shared3 *__shared3::extract_after(OssIndex begin, OssIndex end) {
    return (__shared3 *)do_extract_after(begin, end);
}

void *Public_OAQUE::operator new(size_t size) {
    return ossNewFunc(size);
}

void Public_OAQUE::operator delete(void *ptr) {
    asn1Free(ptr);
}

Public_OAQUE::Public_OAQUE() {
    memset(this, 0, sizeof(Public_OAQUE));
}

Public_OAQUE::Public_OAQUE(const Public_OAQUE & that) {
    OSSTRY {
	params_field = that.params_field;
	attributeset_field = that.attributeset_field;
    } OSSCLEAN(Public_OAQUE)
}

Public_OAQUE::Public_OAQUE(const params & params_val, const attributeset & attributeset_val) {
    OSSTRY {
	params_field = params_val;
	attributeset_field = attributeset_val;
    } OSSCLEAN(Public_OAQUE)
}

Public_OAQUE & Public_OAQUE::operator = (const Public_OAQUE & that) {
    if (this == &that)
	return *this;
    params_field = that.params_field;
    attributeset_field = that.attributeset_field;
    return *this;
}

int Public_OAQUE::operator == (const Public_OAQUE & that) const {
    if (params_field != that.params_field)
	return 0;
    if (attributeset_field != that.attributeset_field)
	return 0;
    return 1;
}

int Public_OAQUE::operator != (const Public_OAQUE & that) const {
    return !(operator ==(that));
}

Public_OAQUE::params & Public_OAQUE::get_params() {
    return params_field;
}

const Public_OAQUE::params & Public_OAQUE::get_params() const {
    return params_field;
}

void Public_OAQUE::set_params(const params & params_val) {
    params_field = params_val;
}

Public_OAQUE::attributeset & Public_OAQUE::get_attributeset() {
    return attributeset_field;
}

const Public_OAQUE::attributeset & Public_OAQUE::get_attributeset() const {
    return attributeset_field;
}

void Public_OAQUE::set_attributeset(const attributeset & attributeset_val) {
    attributeset_field = attributeset_val;
}

void *Public_BN256_IBE::operator new(size_t size) {
    return ossNewFunc(size);
}

void Public_BN256_IBE::operator delete(void *ptr) {
    asn1Free(ptr);
}

Public_BN256_IBE::Public_BN256_IBE() {
    memset(this, 0, sizeof(Public_BN256_IBE));
}

Public_BN256_IBE::Public_BN256_IBE(const Public_BN256_IBE & that) {
    OSSTRY {
	params_field = that.params_field;
	id_field = that.id_field;
    } OSSCLEAN(Public_BN256_IBE)
}

Public_BN256_IBE::Public_BN256_IBE(const params & params_val, const id & id_val) {
    OSSTRY {
	params_field = params_val;
	id_field = id_val;
    } OSSCLEAN(Public_BN256_IBE)
}

Public_BN256_IBE & Public_BN256_IBE::operator = (const Public_BN256_IBE & that) {
    if (this == &that)
	return *this;
    params_field = that.params_field;
    id_field = that.id_field;
    return *this;
}

int Public_BN256_IBE::operator == (const Public_BN256_IBE & that) const {
    if (params_field != that.params_field)
	return 0;
    if (id_field != that.id_field)
	return 0;
    return 1;
}

int Public_BN256_IBE::operator != (const Public_BN256_IBE & that) const {
    return !(operator ==(that));
}

Public_BN256_IBE::params & Public_BN256_IBE::get_params() {
    return params_field;
}

const Public_BN256_IBE::params & Public_BN256_IBE::get_params() const {
    return params_field;
}

void Public_BN256_IBE::set_params(const params & params_val) {
    params_field = params_val;
}

Public_BN256_IBE::id & Public_BN256_IBE::get_id() {
    return id_field;
}

const Public_BN256_IBE::id & Public_BN256_IBE::get_id() const {
    return id_field;
}

void Public_BN256_IBE::set_id(const id & id_val) {
    id_field = id_val;
}

EntityKeySchemes_Type::EntityKeySchemes_Type()
{
}

EntityKeySchemes_Type::EntityKeySchemes_Type(const EntityKeySchemes_Type & that)
{
    operator =(that);
}

EntityKeySchemes_Type::~EntityKeySchemes_Type()
{
    cleanup_decoded();
}

EntityKeySchemes_Type & EntityKeySchemes_Type::operator = (const EntityKeySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int EntityKeySchemes_Type::operator == (const EntityKeySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int EntityKeySchemes_Type::operator != (const EntityKeySchemes_Type & that) const
{
    return !(operator ==(that));
}

int EntityKeySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int EntityKeySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int EntityKeySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int EntityKeySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int EntityKeySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

Public_Ed25519 *EntityKeySchemes_Type::get_Public_Ed25519()
{
    if (pdunum == 31)
	return (Public_Ed25519 *)decoded;
    else
	return NULL;
}

const Public_Ed25519 *EntityKeySchemes_Type::get_Public_Ed25519() const
{
    if (pdunum == 31)
	return (const Public_Ed25519 *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Public_Ed25519(const Public_Ed25519 & data)
{
    void *copy;

    copy = new Public_Ed25519(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 31;
	decoded = copy;
    }
}

Public_Ed25519 *EntityKeySchemes_Type::release_Public_Ed25519()
{
    pdunum = 0;
    decoded = NULL;
    return get_Public_Ed25519();
}

void EntityKeySchemes_Type::set_Public_Ed25519(Public_Ed25519 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 31;
    decoded = data;
}

Public_Curve25519 *EntityKeySchemes_Type::get_Public_Curve25519()
{
    if (pdunum == 32)
	return (Public_Curve25519 *)decoded;
    else
	return NULL;
}

const Public_Curve25519 *EntityKeySchemes_Type::get_Public_Curve25519() const
{
    if (pdunum == 32)
	return (const Public_Curve25519 *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Public_Curve25519(const Public_Curve25519 & data)
{
    void *copy;

    copy = new Public_Curve25519(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 32;
	decoded = copy;
    }
}

Public_Curve25519 *EntityKeySchemes_Type::release_Public_Curve25519()
{
    pdunum = 0;
    decoded = NULL;
    return get_Public_Curve25519();
}

void EntityKeySchemes_Type::set_Public_Curve25519(Public_Curve25519 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 32;
    decoded = data;
}

Public_OAQUE *EntityKeySchemes_Type::get_Public_OAQUE()
{
    if (pdunum == 33)
	return (Public_OAQUE *)decoded;
    else
	return NULL;
}

const Public_OAQUE *EntityKeySchemes_Type::get_Public_OAQUE() const
{
    if (pdunum == 33)
	return (const Public_OAQUE *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Public_OAQUE(const Public_OAQUE & data)
{
    void *copy;

    copy = new Public_OAQUE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 33;
	decoded = copy;
    }
}

Public_OAQUE *EntityKeySchemes_Type::release_Public_OAQUE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Public_OAQUE();
}

void EntityKeySchemes_Type::set_Public_OAQUE(Public_OAQUE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 33;
    decoded = data;
}

Params_BN256_OAQUE *EntityKeySchemes_Type::get_Params_BN256_OAQUE()
{
    if (pdunum == 34)
	return (Params_BN256_OAQUE *)decoded;
    else
	return NULL;
}

const Params_BN256_OAQUE *EntityKeySchemes_Type::get_Params_BN256_OAQUE() const
{
    if (pdunum == 34)
	return (const Params_BN256_OAQUE *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Params_BN256_OAQUE(const Params_BN256_OAQUE & data)
{
    void *copy;

    copy = new Params_BN256_OAQUE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 34;
	decoded = copy;
    }
}

Params_BN256_OAQUE *EntityKeySchemes_Type::release_Params_BN256_OAQUE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Params_BN256_OAQUE();
}

void EntityKeySchemes_Type::set_Params_BN256_OAQUE(Params_BN256_OAQUE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 34;
    decoded = data;
}

Params_BN256_IBE *EntityKeySchemes_Type::get_Params_BN256_IBE()
{
    if (pdunum == 35)
	return (Params_BN256_IBE *)decoded;
    else
	return NULL;
}

const Params_BN256_IBE *EntityKeySchemes_Type::get_Params_BN256_IBE() const
{
    if (pdunum == 35)
	return (const Params_BN256_IBE *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Params_BN256_IBE(const Params_BN256_IBE & data)
{
    void *copy;

    copy = new Params_BN256_IBE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 35;
	decoded = copy;
    }
}

Params_BN256_IBE *EntityKeySchemes_Type::release_Params_BN256_IBE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Params_BN256_IBE();
}

void EntityKeySchemes_Type::set_Params_BN256_IBE(Params_BN256_IBE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 35;
    decoded = data;
}

Public_BN256_IBE *EntityKeySchemes_Type::get_Public_BN256_IBE()
{
    if (pdunum == 36)
	return (Public_BN256_IBE *)decoded;
    else
	return NULL;
}

const Public_BN256_IBE *EntityKeySchemes_Type::get_Public_BN256_IBE() const
{
    if (pdunum == 36)
	return (const Public_BN256_IBE *)decoded;
    else
	return NULL;
}

void EntityKeySchemes_Type::set_Public_BN256_IBE(const Public_BN256_IBE & data)
{
    void *copy;

    copy = new Public_BN256_IBE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 36;
	decoded = copy;
    }
}

Public_BN256_IBE *EntityKeySchemes_Type::release_Public_BN256_IBE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Public_BN256_IBE();
}

void EntityKeySchemes_Type::set_Public_BN256_IBE(Public_BN256_IBE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 36;
    decoded = data;
}

void EntityKeySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq8::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq8::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq8::__seq8() {
    memset(this, 0, sizeof(__seq8));
}

__seq8::__seq8(const __seq8 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq8)
}

__seq8::__seq8(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq8)
}

__seq8 & __seq8::operator = (const __seq8 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq8::operator == (const __seq8 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq8::operator != (const __seq8 & that) const {
    return !(operator ==(that));
}

__seq8::type_id & __seq8::get_type_id() {
    return type_id_field;
}

const __seq8::type_id & __seq8::get_type_id() const {
    return type_id_field;
}

void __seq8::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq8::value & __seq8::get_value() {
    return value_field;
}

const __seq8::value & __seq8::get_value() const {
    return value_field;
}

void __seq8::set_value(const value & value_val) {
    value_field = value_val;
}

void *EntityPublicKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void EntityPublicKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

EntityPublicKey::EntityPublicKey() {
    memset(this, 0, sizeof(EntityPublicKey));
}

EntityPublicKey::EntityPublicKey(const EntityPublicKey & that) {
    OSSTRY {
	capabilityFlags_field = that.capabilityFlags_field;
	key_field = that.key_field;
    } OSSCLEAN(EntityPublicKey)
}

EntityPublicKey::EntityPublicKey(const capabilityFlags & capabilityFlags_val, const key & key_val) {
    OSSTRY {
	capabilityFlags_field = capabilityFlags_val;
	key_field = key_val;
    } OSSCLEAN(EntityPublicKey)
}

EntityPublicKey & EntityPublicKey::operator = (const EntityPublicKey & that) {
    if (this == &that)
	return *this;
    capabilityFlags_field = that.capabilityFlags_field;
    key_field = that.key_field;
    return *this;
}

int EntityPublicKey::operator == (const EntityPublicKey & that) const {
    if (capabilityFlags_field != that.capabilityFlags_field)
	return 0;
    if (key_field != that.key_field)
	return 0;
    return 1;
}

int EntityPublicKey::operator != (const EntityPublicKey & that) const {
    return !(operator ==(that));
}

EntityPublicKey::capabilityFlags & EntityPublicKey::get_capabilityFlags() {
    return capabilityFlags_field;
}

const EntityPublicKey::capabilityFlags & EntityPublicKey::get_capabilityFlags() const {
    return capabilityFlags_field;
}

void EntityPublicKey::set_capabilityFlags(const capabilityFlags & capabilityFlags_val) {
    capabilityFlags_field = capabilityFlags_val;
}

EntityPublicKey::key & EntityPublicKey::get_key() {
    return key_field;
}

const EntityPublicKey::key & EntityPublicKey::get_key() const {
    return key_field;
}

void EntityPublicKey::set_key(const key & key_val) {
    key_field = key_val;
}

void *PSKBodyCiphertext::operator new(size_t size) {
    return ossNewFunc(size);
}

void PSKBodyCiphertext::operator delete(void *ptr) {
    asn1Free(ptr);
}

PSKBodyCiphertext::PSKBodyCiphertext() {
    memset(this, 0, sizeof(PSKBodyCiphertext));
}

PSKBodyCiphertext::PSKBodyCiphertext(const PSKBodyCiphertext & that) {
    OSSTRY {
	attestationBodyCiphertext_field = that.attestationBodyCiphertext_field;
	encryptedUnder_field = that.encryptedUnder_field;
    } OSSCLEAN(PSKBodyCiphertext)
}

PSKBodyCiphertext::PSKBodyCiphertext(const attestationBodyCiphertext & attestationBodyCiphertext_val, 
    const encryptedUnder & encryptedUnder_val) {
    OSSTRY {
	attestationBodyCiphertext_field = attestationBodyCiphertext_val;
	encryptedUnder_field = encryptedUnder_val;
    } OSSCLEAN(PSKBodyCiphertext)
}

PSKBodyCiphertext & PSKBodyCiphertext::operator = (const PSKBodyCiphertext & that) {
    if (this == &that)
	return *this;
    attestationBodyCiphertext_field = that.attestationBodyCiphertext_field;
    encryptedUnder_field = that.encryptedUnder_field;
    return *this;
}

int PSKBodyCiphertext::operator == (const PSKBodyCiphertext & that) const {
    if (attestationBodyCiphertext_field != that.attestationBodyCiphertext_field)
	return 0;
    if (encryptedUnder_field != that.encryptedUnder_field)
	return 0;
    return 1;
}

int PSKBodyCiphertext::operator != (const PSKBodyCiphertext & that) const {
    return !(operator ==(that));
}

PSKBodyCiphertext::attestationBodyCiphertext & PSKBodyCiphertext::get_attestationBodyCiphertext() {
    return attestationBodyCiphertext_field;
}

const PSKBodyCiphertext::attestationBodyCiphertext & PSKBodyCiphertext::get_attestationBodyCiphertext() const {
    return attestationBodyCiphertext_field;
}

void PSKBodyCiphertext::set_attestationBodyCiphertext(const attestationBodyCiphertext & attestationBodyCiphertext_val) {
    attestationBodyCiphertext_field = attestationBodyCiphertext_val;
}

PSKBodyCiphertext::encryptedUnder & PSKBodyCiphertext::get_encryptedUnder() {
    return encryptedUnder_field;
}

const PSKBodyCiphertext::encryptedUnder & PSKBodyCiphertext::get_encryptedUnder() const {
    return encryptedUnder_field;
}

void PSKBodyCiphertext::set_encryptedUnder(const encryptedUnder & encryptedUnder_val) {
    encryptedUnder_field = encryptedUnder_val;
}

AttestationBodySchemes_Type::AttestationBodySchemes_Type()
{
}

AttestationBodySchemes_Type::AttestationBodySchemes_Type(const AttestationBodySchemes_Type & that)
{
    operator =(that);
}

AttestationBodySchemes_Type::~AttestationBodySchemes_Type()
{
    cleanup_decoded();
}

AttestationBodySchemes_Type & AttestationBodySchemes_Type::operator = (const AttestationBodySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int AttestationBodySchemes_Type::operator == (const AttestationBodySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int AttestationBodySchemes_Type::operator != (const AttestationBodySchemes_Type & that) const
{
    return !(operator ==(that));
}

int AttestationBodySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int AttestationBodySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int AttestationBodySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int AttestationBodySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int AttestationBodySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

AttestationBody *AttestationBodySchemes_Type::get_AttestationBody()
{
    if (pdunum == 3)
	return (AttestationBody *)decoded;
    else
	return NULL;
}

const AttestationBody *AttestationBodySchemes_Type::get_AttestationBody() const
{
    if (pdunum == 3)
	return (const AttestationBody *)decoded;
    else
	return NULL;
}

void AttestationBodySchemes_Type::set_AttestationBody(const AttestationBody & data)
{
    void *copy;

    copy = new AttestationBody(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 3;
	decoded = copy;
    }
}

AttestationBody *AttestationBodySchemes_Type::release_AttestationBody()
{
    pdunum = 0;
    decoded = NULL;
    return get_AttestationBody();
}

void AttestationBodySchemes_Type::set_AttestationBody(AttestationBody *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 3;
    decoded = data;
}

WR1BodyCiphertext *AttestationBodySchemes_Type::get_WR1BodyCiphertext()
{
    if (pdunum == 16)
	return (WR1BodyCiphertext *)decoded;
    else
	return NULL;
}

const WR1BodyCiphertext *AttestationBodySchemes_Type::get_WR1BodyCiphertext() const
{
    if (pdunum == 16)
	return (const WR1BodyCiphertext *)decoded;
    else
	return NULL;
}

void AttestationBodySchemes_Type::set_WR1BodyCiphertext(const WR1BodyCiphertext & data)
{
    void *copy;

    copy = new WR1BodyCiphertext(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 16;
	decoded = copy;
    }
}

WR1BodyCiphertext *AttestationBodySchemes_Type::release_WR1BodyCiphertext()
{
    pdunum = 0;
    decoded = NULL;
    return get_WR1BodyCiphertext();
}

void AttestationBodySchemes_Type::set_WR1BodyCiphertext(WR1BodyCiphertext *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 16;
    decoded = data;
}

PSKBodyCiphertext *AttestationBodySchemes_Type::get_PSKBodyCiphertext()
{
    if (pdunum == 15)
	return (PSKBodyCiphertext *)decoded;
    else
	return NULL;
}

const PSKBodyCiphertext *AttestationBodySchemes_Type::get_PSKBodyCiphertext() const
{
    if (pdunum == 15)
	return (const PSKBodyCiphertext *)decoded;
    else
	return NULL;
}

void AttestationBodySchemes_Type::set_PSKBodyCiphertext(const PSKBodyCiphertext & data)
{
    void *copy;

    copy = new PSKBodyCiphertext(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 15;
	decoded = copy;
    }
}

PSKBodyCiphertext *AttestationBodySchemes_Type::release_PSKBodyCiphertext()
{
    pdunum = 0;
    decoded = NULL;
    return get_PSKBodyCiphertext();
}

void AttestationBodySchemes_Type::set_PSKBodyCiphertext(PSKBodyCiphertext *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 15;
    decoded = data;
}

void AttestationBodySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq2::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq2::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq2::__seq2() {
    memset(this, 0, sizeof(__seq2));
}

__seq2::__seq2(const __seq2 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq2)
}

__seq2::__seq2(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq2)
}

__seq2 & __seq2::operator = (const __seq2 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq2::operator == (const __seq2 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq2::operator != (const __seq2 & that) const {
    return !(operator ==(that));
}

__seq2::type_id & __seq2::get_type_id() {
    return type_id_field;
}

const __seq2::type_id & __seq2::get_type_id() const {
    return type_id_field;
}

void __seq2::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq2::value & __seq2::get_value() {
    return value_field;
}

const __seq2::value & __seq2::get_value() const {
    return value_field;
}

void __seq2::set_value(const value & value_val) {
    value_field = value_val;
}

void *__seq3::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq3::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq3::__seq3() {
    memset(this, 0, sizeof(__seq3));
}

__seq3::__seq3(const __seq3 & that) {
    OSSTRY {
	subject_field = that.subject_field;
	subjectLocation_field = that.subjectLocation_field;
	revocations_field = that.revocations_field;
	publicExtensions_field = that.publicExtensions_field;
	body_field = that.body_field;
    } OSSCLEAN(__seq3)
}

__seq3::__seq3(const subject & subject_val, const subjectLocation & subjectLocation_val, 
    const revocations & revocations_val, const publicExtensions & publicExtensions_val, 
    const body & body_val) {
    OSSTRY {
	subject_field = subject_val;
	subjectLocation_field = subjectLocation_val;
	revocations_field = revocations_val;
	publicExtensions_field = publicExtensions_val;
	body_field = body_val;
    } OSSCLEAN(__seq3)
}

__seq3 & __seq3::operator = (const __seq3 & that) {
    if (this == &that)
	return *this;
    subject_field = that.subject_field;
    subjectLocation_field = that.subjectLocation_field;
    revocations_field = that.revocations_field;
    publicExtensions_field = that.publicExtensions_field;
    body_field = that.body_field;
    return *this;
}

int __seq3::operator == (const __seq3 & that) const {
    if (subject_field != that.subject_field)
	return 0;
    if (subjectLocation_field != that.subjectLocation_field)
	return 0;
    if (revocations_field != that.revocations_field)
	return 0;
    if (publicExtensions_field != that.publicExtensions_field)
	return 0;
    if (body_field != that.body_field)
	return 0;
    return 1;
}

int __seq3::operator != (const __seq3 & that) const {
    return !(operator ==(that));
}

__seq3::subject & __seq3::get_subject() {
    return subject_field;
}

const __seq3::subject & __seq3::get_subject() const {
    return subject_field;
}

void __seq3::set_subject(const subject & subject_val) {
    subject_field = subject_val;
}

__seq3::subjectLocation & __seq3::get_subjectLocation() {
    return subjectLocation_field;
}

const __seq3::subjectLocation & __seq3::get_subjectLocation() const {
    return subjectLocation_field;
}

void __seq3::set_subjectLocation(const subjectLocation & subjectLocation_val) {
    subjectLocation_field = subjectLocation_val;
}

__seq3::revocations & __seq3::get_revocations() {
    return revocations_field;
}

const __seq3::revocations & __seq3::get_revocations() const {
    return revocations_field;
}

void __seq3::set_revocations(const revocations & revocations_val) {
    revocations_field = revocations_val;
}

__seq3::publicExtensions & __seq3::get_publicExtensions() {
    return publicExtensions_field;
}

const __seq3::publicExtensions & __seq3::get_publicExtensions() const {
    return publicExtensions_field;
}

void __seq3::set_publicExtensions(const publicExtensions & publicExtensions_val) {
    publicExtensions_field = publicExtensions_val;
}

__seq3::body & __seq3::get_body() {
    return body_field;
}

const __seq3::body & __seq3::get_body() const {
    return body_field;
}

void __seq3::set_body(const body & body_val) {
    body_field = body_val;
}

void *Ed25519OuterSignature::operator new(size_t size) {
    return ossNewFunc(size);
}

void Ed25519OuterSignature::operator delete(void *ptr) {
    asn1Free(ptr);
}

Ed25519OuterSignature::Ed25519OuterSignature() {
    memset(this, 0, sizeof(Ed25519OuterSignature));
}

Ed25519OuterSignature::Ed25519OuterSignature(const Ed25519OuterSignature & that) {
    OSSTRY {
	verifyingKey_field = that.verifyingKey_field;
	signature_field = that.signature_field;
    } OSSCLEAN(Ed25519OuterSignature)
}

Ed25519OuterSignature::Ed25519OuterSignature(const verifyingKey & verifyingKey_val, 
    const signature & signature_val) {
    OSSTRY {
	verifyingKey_field = verifyingKey_val;
	signature_field = signature_val;
    } OSSCLEAN(Ed25519OuterSignature)
}

Ed25519OuterSignature & Ed25519OuterSignature::operator = (const Ed25519OuterSignature & that) {
    if (this == &that)
	return *this;
    verifyingKey_field = that.verifyingKey_field;
    signature_field = that.signature_field;
    return *this;
}

int Ed25519OuterSignature::operator == (const Ed25519OuterSignature & that) const {
    if (verifyingKey_field != that.verifyingKey_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    return 1;
}

int Ed25519OuterSignature::operator != (const Ed25519OuterSignature & that) const {
    return !(operator ==(that));
}

Ed25519OuterSignature::verifyingKey & Ed25519OuterSignature::get_verifyingKey() {
    return verifyingKey_field;
}

const Ed25519OuterSignature::verifyingKey & Ed25519OuterSignature::get_verifyingKey() const {
    return verifyingKey_field;
}

void Ed25519OuterSignature::set_verifyingKey(const verifyingKey & verifyingKey_val) {
    verifyingKey_field = verifyingKey_val;
}

Ed25519OuterSignature::signature & Ed25519OuterSignature::get_signature() {
    return signature_field;
}

const Ed25519OuterSignature::signature & Ed25519OuterSignature::get_signature() const {
    return signature_field;
}

void Ed25519OuterSignature::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

OuterSignatureSchemes_Type::OuterSignatureSchemes_Type()
{
}

OuterSignatureSchemes_Type::OuterSignatureSchemes_Type(const OuterSignatureSchemes_Type & that)
{
    operator =(that);
}

OuterSignatureSchemes_Type::~OuterSignatureSchemes_Type()
{
    cleanup_decoded();
}

OuterSignatureSchemes_Type & OuterSignatureSchemes_Type::operator = (const OuterSignatureSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int OuterSignatureSchemes_Type::operator == (const OuterSignatureSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int OuterSignatureSchemes_Type::operator != (const OuterSignatureSchemes_Type & that) const
{
    return !(operator ==(that));
}

int OuterSignatureSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int OuterSignatureSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int OuterSignatureSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int OuterSignatureSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int OuterSignatureSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

Ed25519OuterSignature *OuterSignatureSchemes_Type::get_Ed25519OuterSignature()
{
    if (pdunum == 20)
	return (Ed25519OuterSignature *)decoded;
    else
	return NULL;
}

const Ed25519OuterSignature *OuterSignatureSchemes_Type::get_Ed25519OuterSignature() const
{
    if (pdunum == 20)
	return (const Ed25519OuterSignature *)decoded;
    else
	return NULL;
}

void OuterSignatureSchemes_Type::set_Ed25519OuterSignature(const Ed25519OuterSignature & data)
{
    void *copy;

    copy = new Ed25519OuterSignature(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 20;
	decoded = copy;
    }
}

Ed25519OuterSignature *OuterSignatureSchemes_Type::release_Ed25519OuterSignature()
{
    pdunum = 0;
    decoded = NULL;
    return get_Ed25519OuterSignature();
}

void OuterSignatureSchemes_Type::set_Ed25519OuterSignature(Ed25519OuterSignature *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 20;
    decoded = data;
}

void OuterSignatureSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq4::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq4::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq4::__seq4() {
    memset(this, 0, sizeof(__seq4));
}

__seq4::__seq4(const __seq4 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq4)
}

__seq4::__seq4(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq4)
}

__seq4 & __seq4::operator = (const __seq4 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq4::operator == (const __seq4 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq4::operator != (const __seq4 & that) const {
    return !(operator ==(that));
}

__seq4::type_id & __seq4::get_type_id() {
    return type_id_field;
}

const __seq4::type_id & __seq4::get_type_id() const {
    return type_id_field;
}

void __seq4::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq4::value & __seq4::get_value() {
    return value_field;
}

const __seq4::value & __seq4::get_value() const {
    return value_field;
}

void __seq4::set_value(const value & value_val) {
    value_field = value_val;
}

void *WaveAttestation::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveAttestation::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveAttestation::WaveAttestation() {
    memset(this, 0, sizeof(WaveAttestation));
}

WaveAttestation::WaveAttestation(const WaveAttestation & that) {
    OSSTRY {
	tbs_field = that.tbs_field;
	outerSignature_field = that.outerSignature_field;
    } OSSCLEAN(WaveAttestation)
}

WaveAttestation::WaveAttestation(const tbs & tbs_val, const outerSignature & outerSignature_val) {
    OSSTRY {
	tbs_field = tbs_val;
	outerSignature_field = outerSignature_val;
    } OSSCLEAN(WaveAttestation)
}

WaveAttestation & WaveAttestation::operator = (const WaveAttestation & that) {
    if (this == &that)
	return *this;
    tbs_field = that.tbs_field;
    outerSignature_field = that.outerSignature_field;
    return *this;
}

int WaveAttestation::operator == (const WaveAttestation & that) const {
    if (tbs_field != that.tbs_field)
	return 0;
    if (outerSignature_field != that.outerSignature_field)
	return 0;
    return 1;
}

int WaveAttestation::operator != (const WaveAttestation & that) const {
    return !(operator ==(that));
}

WaveAttestation::tbs & WaveAttestation::get_tbs() {
    return tbs_field;
}

const WaveAttestation::tbs & WaveAttestation::get_tbs() const {
    return tbs_field;
}

void WaveAttestation::set_tbs(const tbs & tbs_val) {
    tbs_field = tbs_val;
}

WaveAttestation::outerSignature & WaveAttestation::get_outerSignature() {
    return outerSignature_field;
}

const WaveAttestation::outerSignature & WaveAttestation::get_outerSignature() const {
    return outerSignature_field;
}

void WaveAttestation::set_outerSignature(const outerSignature & outerSignature_val) {
    outerSignature_field = outerSignature_val;
}

/* Auxiliary data structures and functions for class __seqof4 */

class __seqof4_member {
public:
    __seqof4_member *next;
    __seqof4::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof4_member();
    __seqof4_member(const __seqof4::component & val);
};

void *__seqof4_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof4_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof4_member::__seqof4_member() {
}

__seqof4_member::__seqof4_member(const __seqof4::component & val) {
    value = val;
}

static void *__seqof4_copy(void *that) {
    return new __seqof4_member(((__seqof4_member *)that)->value);
}

static void __seqof4_destroy(void *that) {
    delete (__seqof4_member *)that;
}

static int __seqof4_compare(void *val1, void *val2) {
    return (((__seqof4_member *)val1)->value == ((__seqof4_member *)val2)->value);
}

/* Constructors */

__seqof4::__seqof4() {
}

__seqof4::__seqof4(const __seqof4 & that) {
    OSSTRY {
	do_copy(that, &__seqof4_copy);
    } OSSCLEAN(__seqof4)
}

/* Destructor */

__seqof4::~__seqof4() {
    do_destroy(&__seqof4_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof4 & __seqof4::operator = (const __seqof4 & that) {
    do_destroy(&__seqof4_destroy);
    do_copy(that, &__seqof4_copy);
    return *this;
}

int __seqof4::operator == (const __seqof4 & that) const {
    return do_compare(that, &__seqof4_compare);
}

int __seqof4::operator != (const __seqof4 & that) const {
    return !do_compare(that, &__seqof4_compare);
}

/* Locate ("At" etc) methods */

__seqof4::component *__seqof4::at(OssIndex pos) {
    return &((__seqof4_member *)pos)->value;
}

const __seqof4::component *__seqof4::at(OssIndex pos) const {
    return &((__seqof4_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof4::prepend(const component & val) {
    __seqof4_member *newrec = new __seqof4_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof4::prepend(__seqof4 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof4::insert_after(OssIndex pos, const component & val) {
    __seqof4_member *newrec = new __seqof4_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof4::insert_after(OssIndex pos, __seqof4 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof4::remove_front() {
    __seqof4_member *extr = (__seqof4_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof4_destroy(extr);
    return 0;
}

int __seqof4::remove_after(OssIndex pos) {
    __seqof4_member *extr = (__seqof4_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof4_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof4 *__seqof4::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof4 *)do_extract_after(begin, end);
}

void *__seq9::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq9::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq9::__seq9() {
    memset(this, 0, sizeof(__seq9));
}

__seq9::__seq9(const __seq9 & that) {
    OSSTRY {
	verifyingKey_field = that.verifyingKey_field;
	keys_field = that.keys_field;
	validity_field = that.validity_field;
	revocations_field = that.revocations_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(__seq9)
}

__seq9::__seq9(const verifyingKey & verifyingKey_val, const keys & keys_val, const validity & validity_val, 
    const revocations & revocations_val, const extensions & extensions_val) {
    OSSTRY {
	verifyingKey_field = verifyingKey_val;
	keys_field = keys_val;
	validity_field = validity_val;
	revocations_field = revocations_val;
	extensions_field = extensions_val;
    } OSSCLEAN(__seq9)
}

__seq9 & __seq9::operator = (const __seq9 & that) {
    if (this == &that)
	return *this;
    verifyingKey_field = that.verifyingKey_field;
    keys_field = that.keys_field;
    validity_field = that.validity_field;
    revocations_field = that.revocations_field;
    extensions_field = that.extensions_field;
    return *this;
}

int __seq9::operator == (const __seq9 & that) const {
    if (verifyingKey_field != that.verifyingKey_field)
	return 0;
    if (keys_field != that.keys_field)
	return 0;
    if (validity_field != that.validity_field)
	return 0;
    if (revocations_field != that.revocations_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    return 1;
}

int __seq9::operator != (const __seq9 & that) const {
    return !(operator ==(that));
}

__seq9::verifyingKey & __seq9::get_verifyingKey() {
    return verifyingKey_field;
}

const __seq9::verifyingKey & __seq9::get_verifyingKey() const {
    return verifyingKey_field;
}

void __seq9::set_verifyingKey(const verifyingKey & verifyingKey_val) {
    verifyingKey_field = verifyingKey_val;
}

__seq9::keys & __seq9::get_keys() {
    return keys_field;
}

const __seq9::keys & __seq9::get_keys() const {
    return keys_field;
}

void __seq9::set_keys(const keys & keys_val) {
    keys_field = keys_val;
}

__seq9::validity & __seq9::get_validity() {
    return validity_field;
}

const __seq9::validity & __seq9::get_validity() const {
    return validity_field;
}

void __seq9::set_validity(const validity & validity_val) {
    validity_field = validity_val;
}

__seq9::revocations & __seq9::get_revocations() {
    return revocations_field;
}

const __seq9::revocations & __seq9::get_revocations() const {
    return revocations_field;
}

void __seq9::set_revocations(const revocations & revocations_val) {
    revocations_field = revocations_val;
}

__seq9::extensions & __seq9::get_extensions() {
    return extensions_field;
}

const __seq9::extensions & __seq9::get_extensions() const {
    return extensions_field;
}

void __seq9::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

void *WaveEntity::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveEntity::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveEntity::WaveEntity() {
    memset(this, 0, sizeof(WaveEntity));
}

WaveEntity::WaveEntity(const WaveEntity & that) {
    OSSTRY {
	tbs_field = that.tbs_field;
	signature_field = that.signature_field;
    } OSSCLEAN(WaveEntity)
}

WaveEntity::WaveEntity(const tbs & tbs_val, const signature & signature_val) {
    OSSTRY {
	tbs_field = tbs_val;
	signature_field = signature_val;
    } OSSCLEAN(WaveEntity)
}

WaveEntity & WaveEntity::operator = (const WaveEntity & that) {
    if (this == &that)
	return *this;
    tbs_field = that.tbs_field;
    signature_field = that.signature_field;
    return *this;
}

int WaveEntity::operator == (const WaveEntity & that) const {
    if (tbs_field != that.tbs_field)
	return 0;
    if (signature_field != that.signature_field)
	return 0;
    return 1;
}

int WaveEntity::operator != (const WaveEntity & that) const {
    return !(operator ==(that));
}

WaveEntity::tbs & WaveEntity::get_tbs() {
    return tbs_field;
}

const WaveEntity::tbs & WaveEntity::get_tbs() const {
    return tbs_field;
}

void WaveEntity::set_tbs(const tbs & tbs_val) {
    tbs_field = tbs_val;
}

WaveEntity::signature & WaveEntity::get_signature() {
    return signature_field;
}

const WaveEntity::signature & WaveEntity::get_signature() const {
    return signature_field;
}

void WaveEntity::set_signature(const signature & signature_val) {
    signature_field = signature_val;
}

/* Auxiliary data structures and functions for class __seqof11 */

class __seqof11_member {
public:
    __seqof11_member *next;
    __seqof11::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof11_member();
    __seqof11_member(const __seqof11::component & val);
};

void *__seqof11_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof11_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof11_member::__seqof11_member() {
}

__seqof11_member::__seqof11_member(const __seqof11::component & val) {
    value = val;
}

static void *__seqof11_copy(void *that) {
    return new __seqof11_member(((__seqof11_member *)that)->value);
}

static void __seqof11_destroy(void *that) {
    delete (__seqof11_member *)that;
}

static int __seqof11_compare(void *val1, void *val2) {
    return (((__seqof11_member *)val1)->value == ((__seqof11_member *)val2)->value);
}

/* Constructors */

__seqof11::__seqof11() {
}

__seqof11::__seqof11(const __seqof11 & that) {
    OSSTRY {
	do_copy(that, &__seqof11_copy);
    } OSSCLEAN(__seqof11)
}

/* Destructor */

__seqof11::~__seqof11() {
    do_destroy(&__seqof11_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof11 & __seqof11::operator = (const __seqof11 & that) {
    do_destroy(&__seqof11_destroy);
    do_copy(that, &__seqof11_copy);
    return *this;
}

int __seqof11::operator == (const __seqof11 & that) const {
    return do_compare(that, &__seqof11_compare);
}

int __seqof11::operator != (const __seqof11 & that) const {
    return !do_compare(that, &__seqof11_compare);
}

/* Locate ("At" etc) methods */

__seqof11::component *__seqof11::at(OssIndex pos) {
    return &((__seqof11_member *)pos)->value;
}

const __seqof11::component *__seqof11::at(OssIndex pos) const {
    return &((__seqof11_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof11::prepend(const component & val) {
    __seqof11_member *newrec = new __seqof11_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof11::prepend(__seqof11 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof11::insert_after(OssIndex pos, const component & val) {
    __seqof11_member *newrec = new __seqof11_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof11::insert_after(OssIndex pos, __seqof11 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof11::remove_front() {
    __seqof11_member *extr = (__seqof11_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof11_destroy(extr);
    return 0;
}

int __seqof11::remove_after(OssIndex pos) {
    __seqof11_member *extr = (__seqof11_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof11_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof11 *__seqof11::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof11 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __seqof12 */

class __seqof12_member {
public:
    __seqof12_member *next;
    __seqof12::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof12_member();
    __seqof12_member(const __seqof12::component & val);
};

void *__seqof12_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof12_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof12_member::__seqof12_member() {
}

__seqof12_member::__seqof12_member(const __seqof12::component & val) {
    value = val;
}

static void *__seqof12_copy(void *that) {
    return new __seqof12_member(((__seqof12_member *)that)->value);
}

static void __seqof12_destroy(void *that) {
    delete (__seqof12_member *)that;
}

static int __seqof12_compare(void *val1, void *val2) {
    return (((__seqof12_member *)val1)->value == ((__seqof12_member *)val2)->value);
}

/* Constructors */

__seqof12::__seqof12() {
}

__seqof12::__seqof12(const __seqof12 & that) {
    OSSTRY {
	do_copy(that, &__seqof12_copy);
    } OSSCLEAN(__seqof12)
}

/* Destructor */

__seqof12::~__seqof12() {
    do_destroy(&__seqof12_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof12 & __seqof12::operator = (const __seqof12 & that) {
    do_destroy(&__seqof12_destroy);
    do_copy(that, &__seqof12_copy);
    return *this;
}

int __seqof12::operator == (const __seqof12 & that) const {
    return do_compare(that, &__seqof12_compare);
}

int __seqof12::operator != (const __seqof12 & that) const {
    return !do_compare(that, &__seqof12_compare);
}

/* Locate ("At" etc) methods */

__seqof12::component *__seqof12::at(OssIndex pos) {
    return &((__seqof12_member *)pos)->value;
}

const __seqof12::component *__seqof12::at(OssIndex pos) const {
    return &((__seqof12_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof12::prepend(const component & val) {
    __seqof12_member *newrec = new __seqof12_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof12::prepend(__seqof12 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof12::insert_after(OssIndex pos, const component & val) {
    __seqof12_member *newrec = new __seqof12_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof12::insert_after(OssIndex pos, __seqof12 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof12::remove_front() {
    __seqof12_member *extr = (__seqof12_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof12_destroy(extr);
    return 0;
}

int __seqof12::remove_after(OssIndex pos) {
    __seqof12_member *extr = (__seqof12_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof12_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof12 *__seqof12::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof12 *)do_extract_after(begin, end);
}

void *WaveExplicitProof::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveExplicitProof::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveExplicitProof::WaveExplicitProof() {
    memset(this, 0, sizeof(WaveExplicitProof));
}

WaveExplicitProof::WaveExplicitProof(const WaveExplicitProof & that) {
    OSSTRY {
	attestations_field = that.attestations_field;
	paths_field = that.paths_field;
	entities_field = that.entities_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(WaveExplicitProof)
}

WaveExplicitProof::WaveExplicitProof(const attestations & attestations_val, const paths & paths_val, 
    const entities & entities_val, const extensions & extensions_val) {
    OSSTRY {
	attestations_field = attestations_val;
	paths_field = paths_val;
	entities_field = entities_val;
	extensions_field = extensions_val;
    } OSSCLEAN(WaveExplicitProof)
}

WaveExplicitProof & WaveExplicitProof::operator = (const WaveExplicitProof & that) {
    if (this == &that)
	return *this;
    attestations_field = that.attestations_field;
    paths_field = that.paths_field;
    entities_field = that.entities_field;
    extensions_field = that.extensions_field;
    return *this;
}

int WaveExplicitProof::operator == (const WaveExplicitProof & that) const {
    if (attestations_field != that.attestations_field)
	return 0;
    if (paths_field != that.paths_field)
	return 0;
    if (entities_field != that.entities_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    return 1;
}

int WaveExplicitProof::operator != (const WaveExplicitProof & that) const {
    return !(operator ==(that));
}

WaveExplicitProof::attestations & WaveExplicitProof::get_attestations() {
    return attestations_field;
}

const WaveExplicitProof::attestations & WaveExplicitProof::get_attestations() const {
    return attestations_field;
}

void WaveExplicitProof::set_attestations(const attestations & attestations_val) {
    attestations_field = attestations_val;
}

WaveExplicitProof::paths & WaveExplicitProof::get_paths() {
    return paths_field;
}

const WaveExplicitProof::paths & WaveExplicitProof::get_paths() const {
    return paths_field;
}

void WaveExplicitProof::set_paths(const paths & paths_val) {
    paths_field = paths_val;
}

WaveExplicitProof::entities & WaveExplicitProof::get_entities() {
    return entities_field;
}

const WaveExplicitProof::entities & WaveExplicitProof::get_entities() const {
    return entities_field;
}

void WaveExplicitProof::set_entities(const entities & entities_val) {
    entities_field = entities_val;
}

WaveExplicitProof::extensions & WaveExplicitProof::get_extensions() {
    return extensions_field;
}

const WaveExplicitProof::extensions & WaveExplicitProof::get_extensions() const {
    return extensions_field;
}

void WaveExplicitProof::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

/* Auxiliary data structures and functions for class __seqof5 */

class __seqof5_member {
public:
    __seqof5_member *next;
    __seqof5::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof5_member();
    __seqof5_member(const __seqof5::component & val);
};

void *__seqof5_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof5_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof5_member::__seqof5_member() {
}

__seqof5_member::__seqof5_member(const __seqof5::component & val) {
    value = val;
}

static void *__seqof5_copy(void *that) {
    return new __seqof5_member(((__seqof5_member *)that)->value);
}

static void __seqof5_destroy(void *that) {
    delete (__seqof5_member *)that;
}

static int __seqof5_compare(void *val1, void *val2) {
    return (((__seqof5_member *)val1)->value == ((__seqof5_member *)val2)->value);
}

/* Constructors */

__seqof5::__seqof5() {
}

__seqof5::__seqof5(const __seqof5 & that) {
    OSSTRY {
	do_copy(that, &__seqof5_copy);
    } OSSCLEAN(__seqof5)
}

/* Destructor */

__seqof5::~__seqof5() {
    do_destroy(&__seqof5_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof5 & __seqof5::operator = (const __seqof5 & that) {
    do_destroy(&__seqof5_destroy);
    do_copy(that, &__seqof5_copy);
    return *this;
}

int __seqof5::operator == (const __seqof5 & that) const {
    return do_compare(that, &__seqof5_compare);
}

int __seqof5::operator != (const __seqof5 & that) const {
    return !do_compare(that, &__seqof5_compare);
}

/* Locate ("At" etc) methods */

__seqof5::component *__seqof5::at(OssIndex pos) {
    return &((__seqof5_member *)pos)->value;
}

const __seqof5::component *__seqof5::at(OssIndex pos) const {
    return &((__seqof5_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof5::prepend(const component & val) {
    __seqof5_member *newrec = new __seqof5_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof5::prepend(__seqof5 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof5::insert_after(OssIndex pos, const component & val) {
    __seqof5_member *newrec = new __seqof5_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof5::insert_after(OssIndex pos, __seqof5 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof5::remove_front() {
    __seqof5_member *extr = (__seqof5_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof5_destroy(extr);
    return 0;
}

int __seqof5::remove_after(OssIndex pos) {
    __seqof5_member *extr = (__seqof5_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof5_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof5 *__seqof5::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof5 *)do_extract_after(begin, end);
}

void *EntityKeyring::operator new(size_t size) {
    return ossNewFunc(size);
}

void EntityKeyring::operator delete(void *ptr) {
    asn1Free(ptr);
}

EntityKeyring::EntityKeyring() {
    memset(this, 0, sizeof(EntityKeyring));
}

EntityKeyring::EntityKeyring(const EntityKeyring & that) {
    OSSTRY {
	keys_field = that.keys_field;
    } OSSCLEAN(EntityKeyring)
}

EntityKeyring::EntityKeyring(const keys & keys_val) {
    OSSTRY {
	keys_field = keys_val;
    } OSSCLEAN(EntityKeyring)
}

EntityKeyring & EntityKeyring::operator = (const EntityKeyring & that) {
    if (this == &that)
	return *this;
    keys_field = that.keys_field;
    return *this;
}

int EntityKeyring::operator == (const EntityKeyring & that) const {
    if (keys_field != that.keys_field)
	return 0;
    return 1;
}

int EntityKeyring::operator != (const EntityKeyring & that) const {
    return !(operator ==(that));
}

EntityKeyring::keys & EntityKeyring::get_keys() {
    return keys_field;
}

const EntityKeyring::keys & EntityKeyring::get_keys() const {
    return keys_field;
}

void EntityKeyring::set_keys(const keys & keys_val) {
    keys_field = keys_val;
}

void *KeyringAESCiphertext::operator new(size_t size) {
    return ossNewFunc(size);
}

void KeyringAESCiphertext::operator delete(void *ptr) {
    asn1Free(ptr);
}

KeyringAESCiphertext::KeyringAESCiphertext() {
    memset(this, 0, sizeof(KeyringAESCiphertext));
}

KeyringAESCiphertext::KeyringAESCiphertext(const KeyringAESCiphertext & that) {
    OSSTRY {
	ciphertext_field = that.ciphertext_field;
	salt_field = that.salt_field;
	iterations_field = that.iterations_field;
    } OSSCLEAN(KeyringAESCiphertext)
}

KeyringAESCiphertext::KeyringAESCiphertext(const ciphertext & ciphertext_val, const salt & salt_val, 
    iterations iterations_val) {
    OSSTRY {
	ciphertext_field = ciphertext_val;
	salt_field = salt_val;
	iterations_field = iterations_val;
    } OSSCLEAN(KeyringAESCiphertext)
}

KeyringAESCiphertext & KeyringAESCiphertext::operator = (const KeyringAESCiphertext & that) {
    if (this == &that)
	return *this;
    ciphertext_field = that.ciphertext_field;
    salt_field = that.salt_field;
    iterations_field = that.iterations_field;
    return *this;
}

int KeyringAESCiphertext::operator == (const KeyringAESCiphertext & that) const {
    if (ciphertext_field != that.ciphertext_field)
	return 0;
    if (salt_field != that.salt_field)
	return 0;
    if (iterations_field != that.iterations_field)
	return 0;
    return 1;
}

int KeyringAESCiphertext::operator != (const KeyringAESCiphertext & that) const {
    return !(operator ==(that));
}

KeyringAESCiphertext::ciphertext & KeyringAESCiphertext::get_ciphertext() {
    return ciphertext_field;
}

const KeyringAESCiphertext::ciphertext & KeyringAESCiphertext::get_ciphertext() const {
    return ciphertext_field;
}

void KeyringAESCiphertext::set_ciphertext(const ciphertext & ciphertext_val) {
    ciphertext_field = ciphertext_val;
}

KeyringAESCiphertext::salt & KeyringAESCiphertext::get_salt() {
    return salt_field;
}

const KeyringAESCiphertext::salt & KeyringAESCiphertext::get_salt() const {
    return salt_field;
}

void KeyringAESCiphertext::set_salt(const salt & salt_val) {
    salt_field = salt_val;
}

KeyringAESCiphertext::iterations & KeyringAESCiphertext::get_iterations() {
    return iterations_field;
}

KeyringAESCiphertext::iterations KeyringAESCiphertext::get_iterations() const {
    return iterations_field;
}

void KeyringAESCiphertext::set_iterations(iterations iterations_val) {
    iterations_field = iterations_val;
}

EntityKeyringSchemes_Type::EntityKeyringSchemes_Type()
{
}

EntityKeyringSchemes_Type::EntityKeyringSchemes_Type(const EntityKeyringSchemes_Type & that)
{
    operator =(that);
}

EntityKeyringSchemes_Type::~EntityKeyringSchemes_Type()
{
    cleanup_decoded();
}

EntityKeyringSchemes_Type & EntityKeyringSchemes_Type::operator = (const EntityKeyringSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int EntityKeyringSchemes_Type::operator == (const EntityKeyringSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int EntityKeyringSchemes_Type::operator != (const EntityKeyringSchemes_Type & that) const
{
    return !(operator ==(that));
}

int EntityKeyringSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int EntityKeyringSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int EntityKeyringSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int EntityKeyringSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int EntityKeyringSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

EntityKeyring *EntityKeyringSchemes_Type::get_EntityKeyring()
{
    if (pdunum == 6)
	return (EntityKeyring *)decoded;
    else
	return NULL;
}

const EntityKeyring *EntityKeyringSchemes_Type::get_EntityKeyring() const
{
    if (pdunum == 6)
	return (const EntityKeyring *)decoded;
    else
	return NULL;
}

void EntityKeyringSchemes_Type::set_EntityKeyring(const EntityKeyring & data)
{
    void *copy;

    copy = new EntityKeyring(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 6;
	decoded = copy;
    }
}

EntityKeyring *EntityKeyringSchemes_Type::release_EntityKeyring()
{
    pdunum = 0;
    decoded = NULL;
    return get_EntityKeyring();
}

void EntityKeyringSchemes_Type::set_EntityKeyring(EntityKeyring *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 6;
    decoded = data;
}

KeyringAESCiphertext *EntityKeyringSchemes_Type::get_KeyringAESCiphertext()
{
    if (pdunum == 37)
	return (KeyringAESCiphertext *)decoded;
    else
	return NULL;
}

const KeyringAESCiphertext *EntityKeyringSchemes_Type::get_KeyringAESCiphertext() const
{
    if (pdunum == 37)
	return (const KeyringAESCiphertext *)decoded;
    else
	return NULL;
}

void EntityKeyringSchemes_Type::set_KeyringAESCiphertext(const KeyringAESCiphertext & data)
{
    void *copy;

    copy = new KeyringAESCiphertext(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 37;
	decoded = copy;
    }
}

KeyringAESCiphertext *EntityKeyringSchemes_Type::release_KeyringAESCiphertext()
{
    pdunum = 0;
    decoded = NULL;
    return get_KeyringAESCiphertext();
}

void EntityKeyringSchemes_Type::set_KeyringAESCiphertext(KeyringAESCiphertext *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 37;
    decoded = data;
}

void EntityKeyringSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq10::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq10::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq10::__seq10() {
    memset(this, 0, sizeof(__seq10));
}

__seq10::__seq10(const __seq10 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq10)
}

__seq10::__seq10(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq10)
}

__seq10 & __seq10::operator = (const __seq10 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq10::operator == (const __seq10 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq10::operator != (const __seq10 & that) const {
    return !(operator ==(that));
}

__seq10::type_id & __seq10::get_type_id() {
    return type_id_field;
}

const __seq10::type_id & __seq10::get_type_id() const {
    return type_id_field;
}

void __seq10::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq10::value & __seq10::get_value() {
    return value_field;
}

const __seq10::value & __seq10::get_value() const {
    return value_field;
}

void __seq10::set_value(const value & value_val) {
    value_field = value_val;
}

void *WaveEntitySecret::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveEntitySecret::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveEntitySecret::WaveEntitySecret() {
    memset(this, 0, sizeof(WaveEntitySecret));
}

WaveEntitySecret::WaveEntitySecret(const WaveEntitySecret & that) {
    OSSTRY {
	entity_field = that.entity_field;
	keyring_field = that.keyring_field;
    } OSSCLEAN(WaveEntitySecret)
}

WaveEntitySecret::WaveEntitySecret(const entity & entity_val, const keyring & keyring_val) {
    OSSTRY {
	entity_field = entity_val;
	keyring_field = keyring_val;
    } OSSCLEAN(WaveEntitySecret)
}

WaveEntitySecret & WaveEntitySecret::operator = (const WaveEntitySecret & that) {
    if (this == &that)
	return *this;
    entity_field = that.entity_field;
    keyring_field = that.keyring_field;
    return *this;
}

int WaveEntitySecret::operator == (const WaveEntitySecret & that) const {
    if (entity_field != that.entity_field)
	return 0;
    if (keyring_field != that.keyring_field)
	return 0;
    return 1;
}

int WaveEntitySecret::operator != (const WaveEntitySecret & that) const {
    return !(operator ==(that));
}

WaveEntitySecret::entity & WaveEntitySecret::get_entity() {
    return entity_field;
}

const WaveEntitySecret::entity & WaveEntitySecret::get_entity() const {
    return entity_field;
}

void WaveEntitySecret::set_entity(const entity & entity_val) {
    entity_field = entity_val;
}

WaveEntitySecret::keyring & WaveEntitySecret::get_keyring() {
    return keyring_field;
}

const WaveEntitySecret::keyring & WaveEntitySecret::get_keyring() const {
    return keyring_field;
}

void WaveEntitySecret::set_keyring(const keyring & keyring_val) {
    keyring_field = keyring_val;
}

WaveObjects_Type::WaveObjects_Type()
{
}

WaveObjects_Type::WaveObjects_Type(const WaveObjects_Type & that)
{
    operator =(that);
}

WaveObjects_Type::~WaveObjects_Type()
{
    cleanup_decoded();
}

WaveObjects_Type & WaveObjects_Type::operator = (const WaveObjects_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int WaveObjects_Type::operator == (const WaveObjects_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int WaveObjects_Type::operator != (const WaveObjects_Type & that) const
{
    return !(operator ==(that));
}

int WaveObjects_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int WaveObjects_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int WaveObjects_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int WaveObjects_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int WaveObjects_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

WaveAttestation *WaveObjects_Type::get_WaveAttestation()
{
    if (pdunum == 2)
	return (WaveAttestation *)decoded;
    else
	return NULL;
}

const WaveAttestation *WaveObjects_Type::get_WaveAttestation() const
{
    if (pdunum == 2)
	return (const WaveAttestation *)decoded;
    else
	return NULL;
}

void WaveObjects_Type::set_WaveAttestation(const WaveAttestation & data)
{
    void *copy;

    copy = new WaveAttestation(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 2;
	decoded = copy;
    }
}

WaveAttestation *WaveObjects_Type::release_WaveAttestation()
{
    pdunum = 0;
    decoded = NULL;
    return get_WaveAttestation();
}

void WaveObjects_Type::set_WaveAttestation(WaveAttestation *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 2;
    decoded = data;
}

WaveEntity *WaveObjects_Type::get_WaveEntity()
{
    if (pdunum == 4)
	return (WaveEntity *)decoded;
    else
	return NULL;
}

const WaveEntity *WaveObjects_Type::get_WaveEntity() const
{
    if (pdunum == 4)
	return (const WaveEntity *)decoded;
    else
	return NULL;
}

void WaveObjects_Type::set_WaveEntity(const WaveEntity & data)
{
    void *copy;

    copy = new WaveEntity(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 4;
	decoded = copy;
    }
}

WaveEntity *WaveObjects_Type::release_WaveEntity()
{
    pdunum = 0;
    decoded = NULL;
    return get_WaveEntity();
}

void WaveObjects_Type::set_WaveEntity(WaveEntity *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 4;
    decoded = data;
}

WaveExplicitProof *WaveObjects_Type::get_WaveExplicitProof()
{
    if (pdunum == 8)
	return (WaveExplicitProof *)decoded;
    else
	return NULL;
}

const WaveExplicitProof *WaveObjects_Type::get_WaveExplicitProof() const
{
    if (pdunum == 8)
	return (const WaveExplicitProof *)decoded;
    else
	return NULL;
}

void WaveObjects_Type::set_WaveExplicitProof(const WaveExplicitProof & data)
{
    void *copy;

    copy = new WaveExplicitProof(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 8;
	decoded = copy;
    }
}

WaveExplicitProof *WaveObjects_Type::release_WaveExplicitProof()
{
    pdunum = 0;
    decoded = NULL;
    return get_WaveExplicitProof();
}

void WaveObjects_Type::set_WaveExplicitProof(WaveExplicitProof *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 8;
    decoded = data;
}

WaveEntitySecret *WaveObjects_Type::get_WaveEntitySecret()
{
    if (pdunum == 5)
	return (WaveEntitySecret *)decoded;
    else
	return NULL;
}

const WaveEntitySecret *WaveObjects_Type::get_WaveEntitySecret() const
{
    if (pdunum == 5)
	return (const WaveEntitySecret *)decoded;
    else
	return NULL;
}

void WaveObjects_Type::set_WaveEntitySecret(const WaveEntitySecret & data)
{
    void *copy;

    copy = new WaveEntitySecret(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 5;
	decoded = copy;
    }
}

WaveEntitySecret *WaveObjects_Type::release_WaveEntitySecret()
{
    pdunum = 0;
    decoded = NULL;
    return get_WaveEntitySecret();
}

void WaveObjects_Type::set_WaveEntitySecret(WaveEntitySecret *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 5;
    decoded = data;
}

void WaveObjects_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *WaveWireObject::operator new(size_t size) {
    return ossNewFunc(size);
}

void WaveWireObject::operator delete(void *ptr) {
    asn1Free(ptr);
}

WaveWireObject::WaveWireObject() {
    memset(this, 0, sizeof(WaveWireObject));
}

WaveWireObject::WaveWireObject(const WaveWireObject & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(WaveWireObject)
}

WaveWireObject::WaveWireObject(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(WaveWireObject)
}

WaveWireObject & WaveWireObject::operator = (const WaveWireObject & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int WaveWireObject::operator == (const WaveWireObject & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int WaveWireObject::operator != (const WaveWireObject & that) const {
    return !(operator ==(that));
}

WaveWireObject::type_id & WaveWireObject::get_type_id() {
    return type_id_field;
}

const WaveWireObject::type_id & WaveWireObject::get_type_id() const {
    return type_id_field;
}

void WaveWireObject::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

WaveWireObject::value & WaveWireObject::get_value() {
    return value_field;
}

const WaveWireObject::value & WaveWireObject::get_value() const {
    return value_field;
}

void WaveWireObject::set_value(const value & value_val) {
    value_field = value_val;
}

void *CommitmentRevocationOption::operator new(size_t size) {
    return ossNewFunc(size);
}

void CommitmentRevocationOption::operator delete(void *ptr) {
    asn1Free(ptr);
}

CommitmentRevocationOption::CommitmentRevocationOption() {
    memset(this, 0, sizeof(CommitmentRevocationOption));
}

CommitmentRevocationOption::CommitmentRevocationOption(const CommitmentRevocationOption & that) {
    OSSTRY {
	hash_field = that.hash_field;
	location_field = that.location_field;
    } OSSCLEAN(CommitmentRevocationOption)
}

CommitmentRevocationOption::CommitmentRevocationOption(const hash & hash_val, const location & location_val) {
    OSSTRY {
	hash_field = hash_val;
	location_field = location_val;
    } OSSCLEAN(CommitmentRevocationOption)
}

CommitmentRevocationOption & CommitmentRevocationOption::operator = (const CommitmentRevocationOption & that) {
    if (this == &that)
	return *this;
    hash_field = that.hash_field;
    location_field = that.location_field;
    return *this;
}

int CommitmentRevocationOption::operator == (const CommitmentRevocationOption & that) const {
    if (hash_field != that.hash_field)
	return 0;
    if (location_field != that.location_field)
	return 0;
    return 1;
}

int CommitmentRevocationOption::operator != (const CommitmentRevocationOption & that) const {
    return !(operator ==(that));
}

CommitmentRevocationOption::hash & CommitmentRevocationOption::get_hash() {
    return hash_field;
}

const CommitmentRevocationOption::hash & CommitmentRevocationOption::get_hash() const {
    return hash_field;
}

void CommitmentRevocationOption::set_hash(const hash & hash_val) {
    hash_field = hash_val;
}

CommitmentRevocationOption::location & CommitmentRevocationOption::get_location() {
    return location_field;
}

const CommitmentRevocationOption::location & CommitmentRevocationOption::get_location() const {
    return location_field;
}

void CommitmentRevocationOption::set_location(const location & location_val) {
    location_field = location_val;
}

RevocationSchemes_Type::RevocationSchemes_Type()
{
}

RevocationSchemes_Type::RevocationSchemes_Type(const RevocationSchemes_Type & that)
{
    operator =(that);
}

RevocationSchemes_Type::~RevocationSchemes_Type()
{
    cleanup_decoded();
}

RevocationSchemes_Type & RevocationSchemes_Type::operator = (const RevocationSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int RevocationSchemes_Type::operator == (const RevocationSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int RevocationSchemes_Type::operator != (const RevocationSchemes_Type & that) const
{
    return !(operator ==(that));
}

int RevocationSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int RevocationSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int RevocationSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int RevocationSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int RevocationSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

CommitmentRevocationOption *RevocationSchemes_Type::get_CommitmentRevocationOption()
{
    if (pdunum == 23)
	return (CommitmentRevocationOption *)decoded;
    else
	return NULL;
}

const CommitmentRevocationOption *RevocationSchemes_Type::get_CommitmentRevocationOption() const
{
    if (pdunum == 23)
	return (const CommitmentRevocationOption *)decoded;
    else
	return NULL;
}

void RevocationSchemes_Type::set_CommitmentRevocationOption(const CommitmentRevocationOption & data)
{
    void *copy;

    copy = new CommitmentRevocationOption(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 23;
	decoded = copy;
    }
}

CommitmentRevocationOption *RevocationSchemes_Type::release_CommitmentRevocationOption()
{
    pdunum = 0;
    decoded = NULL;
    return get_CommitmentRevocationOption();
}

void RevocationSchemes_Type::set_CommitmentRevocationOption(CommitmentRevocationOption *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 23;
    decoded = data;
}

void RevocationSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *__seq1::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seq1::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seq1::__seq1() {
    memset(this, 0, sizeof(__seq1));
}

__seq1::__seq1(const __seq1 & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(__seq1)
}

__seq1::__seq1(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(__seq1)
}

__seq1 & __seq1::operator = (const __seq1 & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int __seq1::operator == (const __seq1 & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int __seq1::operator != (const __seq1 & that) const {
    return !(operator ==(that));
}

__seq1::type_id & __seq1::get_type_id() {
    return type_id_field;
}

const __seq1::type_id & __seq1::get_type_id() const {
    return type_id_field;
}

void __seq1::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

__seq1::value & __seq1::get_value() {
    return value_field;
}

const __seq1::value & __seq1::get_value() const {
    return value_field;
}

void __seq1::set_value(const value & value_val) {
    value_field = value_val;
}

void *RevocationOption::operator new(size_t size) {
    return ossNewFunc(size);
}

void RevocationOption::operator delete(void *ptr) {
    asn1Free(ptr);
}

RevocationOption::RevocationOption() {
    memset(this, 0, sizeof(RevocationOption));
}

RevocationOption::RevocationOption(const RevocationOption & that) {
    OSSTRY {
	critical_field = that.critical_field;
	scheme_field = that.scheme_field;
    } OSSCLEAN(RevocationOption)
}

RevocationOption::RevocationOption(critical critical_val, const scheme & scheme_val) {
    OSSTRY {
	critical_field = critical_val;
	scheme_field = scheme_val;
    } OSSCLEAN(RevocationOption)
}

RevocationOption & RevocationOption::operator = (const RevocationOption & that) {
    if (this == &that)
	return *this;
    critical_field = that.critical_field;
    scheme_field = that.scheme_field;
    return *this;
}

int RevocationOption::operator == (const RevocationOption & that) const {
    if (critical_field != that.critical_field)
	return 0;
    if (scheme_field != that.scheme_field)
	return 0;
    return 1;
}

int RevocationOption::operator != (const RevocationOption & that) const {
    return !(operator ==(that));
}

RevocationOption::critical & RevocationOption::get_critical() {
    return critical_field;
}

RevocationOption::critical RevocationOption::get_critical() const {
    return critical_field;
}

void RevocationOption::set_critical(critical critical_val) {
    critical_field = critical_val;
}

RevocationOption::scheme & RevocationOption::get_scheme() {
    return scheme_field;
}

const RevocationOption::scheme & RevocationOption::get_scheme() const {
    return scheme_field;
}

void RevocationOption::set_scheme(const scheme & scheme_val) {
    scheme_field = scheme_val;
}

void *Extension::operator new(size_t size) {
    return ossNewFunc(size);
}

void Extension::operator delete(void *ptr) {
    asn1Free(ptr);
}

Extension::Extension() {
    memset(this, 0, sizeof(Extension));
}

Extension::Extension(const Extension & that) {
    OSSTRY {
	extnID_field = that.extnID_field;
	critical_field = that.critical_field;
	value_field = that.value_field;
    } OSSCLEAN(Extension)
}

Extension::Extension(const extnID & extnID_val, critical critical_val, const value & value_val) {
    OSSTRY {
	extnID_field = extnID_val;
	critical_field = critical_val;
	value_field = value_val;
    } OSSCLEAN(Extension)
}

Extension & Extension::operator = (const Extension & that) {
    if (this == &that)
	return *this;
    extnID_field = that.extnID_field;
    critical_field = that.critical_field;
    value_field = that.value_field;
    return *this;
}

int Extension::operator == (const Extension & that) const {
    if (extnID_field != that.extnID_field)
	return 0;
    if (critical_field != that.critical_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int Extension::operator != (const Extension & that) const {
    return !(operator ==(that));
}

Extension::extnID & Extension::get_extnID() {
    return extnID_field;
}

const Extension::extnID & Extension::get_extnID() const {
    return extnID_field;
}

void Extension::set_extnID(const extnID & extnID_val) {
    extnID_field = extnID_val;
}

Extension::critical & Extension::get_critical() {
    return critical_field;
}

Extension::critical Extension::get_critical() const {
    return critical_field;
}

void Extension::set_critical(critical critical_val) {
    critical_field = critical_val;
}

Extension::value & Extension::get_value() {
    return value_field;
}

const Extension::value & Extension::get_value() const {
    return value_field;
}

void Extension::set_value(const value & value_val) {
    value_field = value_val;
}

EntitySecretKeySchemes_Type::EntitySecretKeySchemes_Type()
{
}

EntitySecretKeySchemes_Type::EntitySecretKeySchemes_Type(const EntitySecretKeySchemes_Type & that)
{
    operator =(that);
}

EntitySecretKeySchemes_Type::~EntitySecretKeySchemes_Type()
{
    cleanup_decoded();
}

EntitySecretKeySchemes_Type & EntitySecretKeySchemes_Type::operator = (const EntitySecretKeySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int EntitySecretKeySchemes_Type::operator == (const EntitySecretKeySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int EntitySecretKeySchemes_Type::operator != (const EntitySecretKeySchemes_Type & that) const
{
    return !(operator ==(that));
}

int EntitySecretKeySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int EntitySecretKeySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int EntitySecretKeySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int EntitySecretKeySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int EntitySecretKeySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

Private_Ed25519 *EntitySecretKeySchemes_Type::get_Private_Ed25519()
{
    if (pdunum == 25)
	return (Private_Ed25519 *)decoded;
    else
	return NULL;
}

const Private_Ed25519 *EntitySecretKeySchemes_Type::get_Private_Ed25519() const
{
    if (pdunum == 25)
	return (const Private_Ed25519 *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Private_Ed25519(const Private_Ed25519 & data)
{
    void *copy;

    copy = new Private_Ed25519(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 25;
	decoded = copy;
    }
}

Private_Ed25519 *EntitySecretKeySchemes_Type::release_Private_Ed25519()
{
    pdunum = 0;
    decoded = NULL;
    return get_Private_Ed25519();
}

void EntitySecretKeySchemes_Type::set_Private_Ed25519(Private_Ed25519 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 25;
    decoded = data;
}

Private_Curve25519 *EntitySecretKeySchemes_Type::get_Private_Curve25519()
{
    if (pdunum == 26)
	return (Private_Curve25519 *)decoded;
    else
	return NULL;
}

const Private_Curve25519 *EntitySecretKeySchemes_Type::get_Private_Curve25519() const
{
    if (pdunum == 26)
	return (const Private_Curve25519 *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Private_Curve25519(const Private_Curve25519 & data)
{
    void *copy;

    copy = new Private_Curve25519(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 26;
	decoded = copy;
    }
}

Private_Curve25519 *EntitySecretKeySchemes_Type::release_Private_Curve25519()
{
    pdunum = 0;
    decoded = NULL;
    return get_Private_Curve25519();
}

void EntitySecretKeySchemes_Type::set_Private_Curve25519(Private_Curve25519 *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 26;
    decoded = data;
}

Private_BN256_OAQUE *EntitySecretKeySchemes_Type::get_Private_BN256_OAQUE()
{
    if (pdunum == 27)
	return (Private_BN256_OAQUE *)decoded;
    else
	return NULL;
}

const Private_BN256_OAQUE *EntitySecretKeySchemes_Type::get_Private_BN256_OAQUE() const
{
    if (pdunum == 27)
	return (const Private_BN256_OAQUE *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Private_BN256_OAQUE(const Private_BN256_OAQUE & data)
{
    void *copy;

    copy = new Private_BN256_OAQUE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 27;
	decoded = copy;
    }
}

Private_BN256_OAQUE *EntitySecretKeySchemes_Type::release_Private_BN256_OAQUE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Private_BN256_OAQUE();
}

void EntitySecretKeySchemes_Type::set_Private_BN256_OAQUE(Private_BN256_OAQUE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 27;
    decoded = data;
}

Master_BN256_OAQUE *EntitySecretKeySchemes_Type::get_Master_BN256_OAQUE()
{
    if (pdunum == 29)
	return (Master_BN256_OAQUE *)decoded;
    else
	return NULL;
}

const Master_BN256_OAQUE *EntitySecretKeySchemes_Type::get_Master_BN256_OAQUE() const
{
    if (pdunum == 29)
	return (const Master_BN256_OAQUE *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Master_BN256_OAQUE(const Master_BN256_OAQUE & data)
{
    void *copy;

    copy = new Master_BN256_OAQUE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 29;
	decoded = copy;
    }
}

Master_BN256_OAQUE *EntitySecretKeySchemes_Type::release_Master_BN256_OAQUE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Master_BN256_OAQUE();
}

void EntitySecretKeySchemes_Type::set_Master_BN256_OAQUE(Master_BN256_OAQUE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 29;
    decoded = data;
}

Master_BN256_IBE *EntitySecretKeySchemes_Type::get_Master_BN256_IBE()
{
    if (pdunum == 30)
	return (Master_BN256_IBE *)decoded;
    else
	return NULL;
}

const Master_BN256_IBE *EntitySecretKeySchemes_Type::get_Master_BN256_IBE() const
{
    if (pdunum == 30)
	return (const Master_BN256_IBE *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Master_BN256_IBE(const Master_BN256_IBE & data)
{
    void *copy;

    copy = new Master_BN256_IBE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 30;
	decoded = copy;
    }
}

Master_BN256_IBE *EntitySecretKeySchemes_Type::release_Master_BN256_IBE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Master_BN256_IBE();
}

void EntitySecretKeySchemes_Type::set_Master_BN256_IBE(Master_BN256_IBE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 30;
    decoded = data;
}

Private_BN256_IBE *EntitySecretKeySchemes_Type::get_Private_BN256_IBE()
{
    if (pdunum == 28)
	return (Private_BN256_IBE *)decoded;
    else
	return NULL;
}

const Private_BN256_IBE *EntitySecretKeySchemes_Type::get_Private_BN256_IBE() const
{
    if (pdunum == 28)
	return (const Private_BN256_IBE *)decoded;
    else
	return NULL;
}

void EntitySecretKeySchemes_Type::set_Private_BN256_IBE(const Private_BN256_IBE & data)
{
    void *copy;

    copy = new Private_BN256_IBE(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 28;
	decoded = copy;
    }
}

Private_BN256_IBE *EntitySecretKeySchemes_Type::release_Private_BN256_IBE()
{
    pdunum = 0;
    decoded = NULL;
    return get_Private_BN256_IBE();
}

void EntitySecretKeySchemes_Type::set_Private_BN256_IBE(Private_BN256_IBE *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 28;
    decoded = data;
}

void EntitySecretKeySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *EntityPrivateKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void EntityPrivateKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

EntityPrivateKey::EntityPrivateKey() {
    memset(this, 0, sizeof(EntityPrivateKey));
}

EntityPrivateKey::EntityPrivateKey(const EntityPrivateKey & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(EntityPrivateKey)
}

EntityPrivateKey::EntityPrivateKey(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(EntityPrivateKey)
}

EntityPrivateKey & EntityPrivateKey::operator = (const EntityPrivateKey & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int EntityPrivateKey::operator == (const EntityPrivateKey & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int EntityPrivateKey::operator != (const EntityPrivateKey & that) const {
    return !(operator ==(that));
}

EntityPrivateKey::type_id & EntityPrivateKey::get_type_id() {
    return type_id_field;
}

const EntityPrivateKey::type_id & EntityPrivateKey::get_type_id() const {
    return type_id_field;
}

void EntityPrivateKey::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

EntityPrivateKey::value & EntityPrivateKey::get_value() {
    return value_field;
}

const EntityPrivateKey::value & EntityPrivateKey::get_value() const {
    return value_field;
}

void EntityPrivateKey::set_value(const value & value_val) {
    value_field = value_val;
}

void *EntityKeyringEntry::operator new(size_t size) {
    return ossNewFunc(size);
}

void EntityKeyringEntry::operator delete(void *ptr) {
    asn1Free(ptr);
}

EntityKeyringEntry::EntityKeyringEntry() {
    memset(this, 0, sizeof(EntityKeyringEntry));
}

EntityKeyringEntry::EntityKeyringEntry(const EntityKeyringEntry & that) {
    OSSTRY {
	EntityKeyringEntry_public_field = that.EntityKeyringEntry_public_field;
	secret_field = that.secret_field;
    } OSSCLEAN(EntityKeyringEntry)
}

EntityKeyringEntry::EntityKeyringEntry(const EntityKeyringEntry_public & EntityKeyringEntry_public_val, 
    const secret & secret_val) {
    OSSTRY {
	EntityKeyringEntry_public_field = EntityKeyringEntry_public_val;
	secret_field = secret_val;
    } OSSCLEAN(EntityKeyringEntry)
}

EntityKeyringEntry & EntityKeyringEntry::operator = (const EntityKeyringEntry & that) {
    if (this == &that)
	return *this;
    EntityKeyringEntry_public_field = that.EntityKeyringEntry_public_field;
    secret_field = that.secret_field;
    return *this;
}

int EntityKeyringEntry::operator == (const EntityKeyringEntry & that) const {
    if (EntityKeyringEntry_public_field != that.EntityKeyringEntry_public_field)
	return 0;
    if (secret_field != that.secret_field)
	return 0;
    return 1;
}

int EntityKeyringEntry::operator != (const EntityKeyringEntry & that) const {
    return !(operator ==(that));
}

EntityKeyringEntry::EntityKeyringEntry_public & EntityKeyringEntry::get_EntityKeyringEntry_public() {
    return EntityKeyringEntry_public_field;
}

const EntityKeyringEntry::EntityKeyringEntry_public & EntityKeyringEntry::get_EntityKeyringEntry_public() const {
    return EntityKeyringEntry_public_field;
}

void EntityKeyringEntry::set_EntityKeyringEntry_public(const EntityKeyringEntry_public & EntityKeyringEntry_public_val) {
    EntityKeyringEntry_public_field = EntityKeyringEntry_public_val;
}

EntityKeyringEntry::secret & EntityKeyringEntry::get_secret() {
    return secret_field;
}

const EntityKeyringEntry::secret & EntityKeyringEntry::get_secret() const {
    return secret_field;
}

void EntityKeyringEntry::set_secret(const secret & secret_val) {
    secret_field = secret_val;
}

PolicyAddendumSchemes_Type::PolicyAddendumSchemes_Type()
{
}

PolicyAddendumSchemes_Type::PolicyAddendumSchemes_Type(const PolicyAddendumSchemes_Type & that)
{
    operator =(that);
}

PolicyAddendumSchemes_Type::~PolicyAddendumSchemes_Type()
{
    cleanup_decoded();
}

PolicyAddendumSchemes_Type & PolicyAddendumSchemes_Type::operator = (const PolicyAddendumSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int PolicyAddendumSchemes_Type::operator == (const PolicyAddendumSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int PolicyAddendumSchemes_Type::operator != (const PolicyAddendumSchemes_Type & that) const
{
    return !(operator ==(that));
}

int PolicyAddendumSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int PolicyAddendumSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int PolicyAddendumSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int PolicyAddendumSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int PolicyAddendumSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

EntityKeyringEntry *PolicyAddendumSchemes_Type::get_EntityKeyringEntry()
{
    if (pdunum == 7)
	return (EntityKeyringEntry *)decoded;
    else
	return NULL;
}

const EntityKeyringEntry *PolicyAddendumSchemes_Type::get_EntityKeyringEntry() const
{
    if (pdunum == 7)
	return (const EntityKeyringEntry *)decoded;
    else
	return NULL;
}

void PolicyAddendumSchemes_Type::set_EntityKeyringEntry(const EntityKeyringEntry & data)
{
    void *copy;

    copy = new EntityKeyringEntry(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 7;
	decoded = copy;
    }
}

EntityKeyringEntry *PolicyAddendumSchemes_Type::release_EntityKeyringEntry()
{
    pdunum = 0;
    decoded = NULL;
    return get_EntityKeyringEntry();
}

void PolicyAddendumSchemes_Type::set_EntityKeyringEntry(EntityKeyringEntry *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 7;
    decoded = data;
}

void PolicyAddendumSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *PolicyAddendum::operator new(size_t size) {
    return ossNewFunc(size);
}

void PolicyAddendum::operator delete(void *ptr) {
    asn1Free(ptr);
}

PolicyAddendum::PolicyAddendum() {
    memset(this, 0, sizeof(PolicyAddendum));
}

PolicyAddendum::PolicyAddendum(const PolicyAddendum & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(PolicyAddendum)
}

PolicyAddendum::PolicyAddendum(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(PolicyAddendum)
}

PolicyAddendum & PolicyAddendum::operator = (const PolicyAddendum & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int PolicyAddendum::operator == (const PolicyAddendum & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int PolicyAddendum::operator != (const PolicyAddendum & that) const {
    return !(operator ==(that));
}

PolicyAddendum::type_id & PolicyAddendum::get_type_id() {
    return type_id_field;
}

const PolicyAddendum::type_id & PolicyAddendum::get_type_id() const {
    return type_id_field;
}

void PolicyAddendum::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

PolicyAddendum::value & PolicyAddendum::get_value() {
    return value_field;
}

const PolicyAddendum::value & PolicyAddendum::get_value() const {
    return value_field;
}

void PolicyAddendum::set_value(const value & value_val) {
    value_field = value_val;
}

AttestationVerifierKeySchemes_Type::AttestationVerifierKeySchemes_Type()
{
}

AttestationVerifierKeySchemes_Type::AttestationVerifierKeySchemes_Type(const AttestationVerifierKeySchemes_Type & that)
{
    operator =(that);
}

AttestationVerifierKeySchemes_Type::~AttestationVerifierKeySchemes_Type()
{
    cleanup_decoded();
}

AttestationVerifierKeySchemes_Type & AttestationVerifierKeySchemes_Type::operator = (const AttestationVerifierKeySchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int AttestationVerifierKeySchemes_Type::operator == (const AttestationVerifierKeySchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int AttestationVerifierKeySchemes_Type::operator != (const AttestationVerifierKeySchemes_Type & that) const
{
    return !(operator ==(that));
}

int AttestationVerifierKeySchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int AttestationVerifierKeySchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int AttestationVerifierKeySchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int AttestationVerifierKeySchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int AttestationVerifierKeySchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

AVKeyAES128_GCM *AttestationVerifierKeySchemes_Type::get_AVKeyAES128_GCM()
{
    if (pdunum == 24)
	return (AVKeyAES128_GCM *)decoded;
    else
	return NULL;
}

const AVKeyAES128_GCM *AttestationVerifierKeySchemes_Type::get_AVKeyAES128_GCM() const
{
    if (pdunum == 24)
	return (const AVKeyAES128_GCM *)decoded;
    else
	return NULL;
}

void AttestationVerifierKeySchemes_Type::set_AVKeyAES128_GCM(const AVKeyAES128_GCM & data)
{
    void *copy;

    copy = new AVKeyAES128_GCM(data);
    if (copy) {
	cleanup_encoded();
	cleanup_decoded();
	pdunum = 24;
	decoded = copy;
    }
}

AVKeyAES128_GCM *AttestationVerifierKeySchemes_Type::release_AVKeyAES128_GCM()
{
    pdunum = 0;
    decoded = NULL;
    return get_AVKeyAES128_GCM();
}

void AttestationVerifierKeySchemes_Type::set_AVKeyAES128_GCM(AVKeyAES128_GCM *data)
{
    cleanup_encoded();
    cleanup_decoded();
    pdunum = 24;
    decoded = data;
}

void AttestationVerifierKeySchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *AttestationVerifierKey::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttestationVerifierKey::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttestationVerifierKey::AttestationVerifierKey() {
    memset(this, 0, sizeof(AttestationVerifierKey));
}

AttestationVerifierKey::AttestationVerifierKey(const AttestationVerifierKey & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(AttestationVerifierKey)
}

AttestationVerifierKey::AttestationVerifierKey(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(AttestationVerifierKey)
}

AttestationVerifierKey & AttestationVerifierKey::operator = (const AttestationVerifierKey & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int AttestationVerifierKey::operator == (const AttestationVerifierKey & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int AttestationVerifierKey::operator != (const AttestationVerifierKey & that) const {
    return !(operator ==(that));
}

AttestationVerifierKey::type_id & AttestationVerifierKey::get_type_id() {
    return type_id_field;
}

const AttestationVerifierKey::type_id & AttestationVerifierKey::get_type_id() const {
    return type_id_field;
}

void AttestationVerifierKey::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

AttestationVerifierKey::value & AttestationVerifierKey::get_value() {
    return value_field;
}

const AttestationVerifierKey::value & AttestationVerifierKey::get_value() const {
    return value_field;
}

void AttestationVerifierKey::set_value(const value & value_val) {
    value_field = value_val;
}

RevocationCheckSchemes_Type::RevocationCheckSchemes_Type()
{
}

RevocationCheckSchemes_Type::RevocationCheckSchemes_Type(const RevocationCheckSchemes_Type & that)
{
    operator =(that);
}

RevocationCheckSchemes_Type::~RevocationCheckSchemes_Type()
{
    cleanup_decoded();
}

RevocationCheckSchemes_Type & RevocationCheckSchemes_Type::operator = (const RevocationCheckSchemes_Type & that)
{
    int result;
    void *copy = NULL;
    unsigned char *enccopy;

    if (this == &that)
	return *this;

    if (that.pdunum) {
	result = objects_Table.copy((void *)that.decoded, &copy, that.pdunum);
	if (result)
	    return *this;
    }
    OSSTRY {
	result = copy_encoded(that.encoded.buffer, that.encoded.size, &enccopy);
    } OSSCLEANUP ( if (copy) asn1Free(copy); )
    if (result) {
	if (copy)
	    asn1Free(copy);
	return *this;
    }
    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = that.pdunum;
    encoded.buffer = enccopy;
    encoded.size = that.encoded.size;
    return *this;
}

int RevocationCheckSchemes_Type::operator == (const RevocationCheckSchemes_Type & that) const
{
    if (equal_helper(that)) {
	if (!pdunum)
	    return 1;
	else
	    return objects_Table.equal((void *)decoded, (void *)that.decoded, pdunum);
    } else
	return 0;
}

int RevocationCheckSchemes_Type::operator != (const RevocationCheckSchemes_Type & that) const
{
    return !(operator ==(that));
}

int RevocationCheckSchemes_Type::set_decoded(PDU & pdu)
{
    int result;
    int index;
    void *copy;

    index = pdu.get_index();
    if (!index)
	return 0;

    result = objects_Table.copy(pdu.get_raw_data(), &copy, index);
    if (result)
	return result;

    cleanup_encoded();
    cleanup_decoded();
    decoded = copy;
    pdunum = index;
    return 0;
}

int RevocationCheckSchemes_Type::grab_decoded(PDU & pdu)
{
    int index;

    index = pdu.get_index();
    if (!index)
	return 0;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (pdu.is_constant())
	return oss_call_error_cond(OSS_UNSUPPORTED_OPERATION);
#endif

    cleanup_encoded();
    cleanup_decoded();
    pdunum = index;
    decoded = pdu.get_raw_data();
    pdu.release_data();
    return 0;
}

int RevocationCheckSchemes_Type::set_encoded(const EncodedBuffer & data)
{
    OSS_UINT32 newsize = data.get_data_size();
    unsigned char *copy;
    int result;

    result = copy_encoded((unsigned char *)data.get_data(), newsize, &copy);
    if (result)
	return result;
    cleanup_encoded();
    cleanup_decoded();
    encoded.buffer = copy;
    encoded.size = newsize;
    return 0;
}

int RevocationCheckSchemes_Type::grab_encoded(EncodedBuffer & data)
{
    cleanup_encoded();
    cleanup_decoded();
    encoded.size = data.get_data_size();
    encoded.buffer = (unsigned char *)data.release_data();
    return 0;
}

int RevocationCheckSchemes_Type::encode(OssControl & control)
{
    int result = encode_helper(control);

    if (result)
	return result;
    cleanup_decoded();
    return 0;
}

void RevocationCheckSchemes_Type::cleanup_decoded()
{
    if (pdunum && decoded) {
	objects_Table.destroy(decoded, pdunum);
	decoded = NULL;
	pdunum = 0;
    }
}

void *RevocationCheck::operator new(size_t size) {
    return ossNewFunc(size);
}

void RevocationCheck::operator delete(void *ptr) {
    asn1Free(ptr);
}

RevocationCheck::RevocationCheck() {
    memset(this, 0, sizeof(RevocationCheck));
}

RevocationCheck::RevocationCheck(const RevocationCheck & that) {
    OSSTRY {
	type_id_field = that.type_id_field;
	value_field = that.value_field;
    } OSSCLEAN(RevocationCheck)
}

RevocationCheck::RevocationCheck(const type_id & type_id_val, const value & value_val) {
    OSSTRY {
	type_id_field = type_id_val;
	value_field = value_val;
    } OSSCLEAN(RevocationCheck)
}

RevocationCheck & RevocationCheck::operator = (const RevocationCheck & that) {
    if (this == &that)
	return *this;
    type_id_field = that.type_id_field;
    value_field = that.value_field;
    return *this;
}

int RevocationCheck::operator == (const RevocationCheck & that) const {
    if (type_id_field != that.type_id_field)
	return 0;
    if (value_field != that.value_field)
	return 0;
    return 1;
}

int RevocationCheck::operator != (const RevocationCheck & that) const {
    return !(operator ==(that));
}

RevocationCheck::type_id & RevocationCheck::get_type_id() {
    return type_id_field;
}

const RevocationCheck::type_id & RevocationCheck::get_type_id() const {
    return type_id_field;
}

void RevocationCheck::set_type_id(const type_id & type_id_val) {
    type_id_field = type_id_val;
}

RevocationCheck::value & RevocationCheck::get_value() {
    return value_field;
}

const RevocationCheck::value & RevocationCheck::get_value() const {
    return value_field;
}

void RevocationCheck::set_value(const value & value_val) {
    value_field = value_val;
}

/* Auxiliary data structures and functions for class __seqof6 */

class __seqof6_member {
public:
    __seqof6_member *next;
    __seqof6::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof6_member();
    __seqof6_member(const __seqof6::component & val);
};

void *__seqof6_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof6_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof6_member::__seqof6_member() {
}

__seqof6_member::__seqof6_member(const __seqof6::component & val) {
    value = val;
}

static void *__seqof6_copy(void *that) {
    return new __seqof6_member(((__seqof6_member *)that)->value);
}

static void __seqof6_destroy(void *that) {
    delete (__seqof6_member *)that;
}

static int __seqof6_compare(void *val1, void *val2) {
    return (((__seqof6_member *)val1)->value == ((__seqof6_member *)val2)->value);
}

/* Constructors */

__seqof6::__seqof6() {
}

__seqof6::__seqof6(const __seqof6 & that) {
    OSSTRY {
	do_copy(that, &__seqof6_copy);
    } OSSCLEAN(__seqof6)
}

/* Destructor */

__seqof6::~__seqof6() {
    do_destroy(&__seqof6_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof6 & __seqof6::operator = (const __seqof6 & that) {
    do_destroy(&__seqof6_destroy);
    do_copy(that, &__seqof6_copy);
    return *this;
}

int __seqof6::operator == (const __seqof6 & that) const {
    return do_compare(that, &__seqof6_compare);
}

int __seqof6::operator != (const __seqof6 & that) const {
    return !do_compare(that, &__seqof6_compare);
}

/* Locate ("At" etc) methods */

__seqof6::component *__seqof6::at(OssIndex pos) {
    return &((__seqof6_member *)pos)->value;
}

const __seqof6::component *__seqof6::at(OssIndex pos) const {
    return &((__seqof6_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof6::prepend(const component & val) {
    __seqof6_member *newrec = new __seqof6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof6::prepend(__seqof6 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof6::insert_after(OssIndex pos, const component & val) {
    __seqof6_member *newrec = new __seqof6_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof6::insert_after(OssIndex pos, __seqof6 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof6::remove_front() {
    __seqof6_member *extr = (__seqof6_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof6_destroy(extr);
    return 0;
}

int __seqof6::remove_after(OssIndex pos) {
    __seqof6_member *extr = (__seqof6_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof6_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof6 *__seqof6::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof6 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __seqof7 */

class __seqof7_member {
public:
    __seqof7_member *next;
    __seqof7::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof7_member();
    __seqof7_member(const __seqof7::component & val);
};

void *__seqof7_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof7_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof7_member::__seqof7_member() {
}

__seqof7_member::__seqof7_member(const __seqof7::component & val) {
    value = val;
}

static void *__seqof7_copy(void *that) {
    return new __seqof7_member(((__seqof7_member *)that)->value);
}

static void __seqof7_destroy(void *that) {
    delete (__seqof7_member *)that;
}

static int __seqof7_compare(void *val1, void *val2) {
    return (((__seqof7_member *)val1)->value == ((__seqof7_member *)val2)->value);
}

/* Constructors */

__seqof7::__seqof7() {
}

__seqof7::__seqof7(const __seqof7 & that) {
    OSSTRY {
	do_copy(that, &__seqof7_copy);
    } OSSCLEAN(__seqof7)
}

/* Destructor */

__seqof7::~__seqof7() {
    do_destroy(&__seqof7_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof7 & __seqof7::operator = (const __seqof7 & that) {
    do_destroy(&__seqof7_destroy);
    do_copy(that, &__seqof7_copy);
    return *this;
}

int __seqof7::operator == (const __seqof7 & that) const {
    return do_compare(that, &__seqof7_compare);
}

int __seqof7::operator != (const __seqof7 & that) const {
    return !do_compare(that, &__seqof7_compare);
}

/* Locate ("At" etc) methods */

__seqof7::component *__seqof7::at(OssIndex pos) {
    return &((__seqof7_member *)pos)->value;
}

const __seqof7::component *__seqof7::at(OssIndex pos) const {
    return &((__seqof7_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof7::prepend(const component & val) {
    __seqof7_member *newrec = new __seqof7_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof7::prepend(__seqof7 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof7::insert_after(OssIndex pos, const component & val) {
    __seqof7_member *newrec = new __seqof7_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof7::insert_after(OssIndex pos, __seqof7 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof7::remove_front() {
    __seqof7_member *extr = (__seqof7_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof7_destroy(extr);
    return 0;
}

int __seqof7::remove_after(OssIndex pos) {
    __seqof7_member *extr = (__seqof7_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof7_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof7 *__seqof7::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof7 *)do_extract_after(begin, end);
}

/* Auxiliary data structures and functions for class __seqof8 */

class __seqof8_member {
public:
    __seqof8_member *next;
    __seqof8::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof8_member();
    __seqof8_member(const __seqof8::component & val);
};

void *__seqof8_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof8_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof8_member::__seqof8_member() {
}

__seqof8_member::__seqof8_member(const __seqof8::component & val) {
    value = val;
}

static void *__seqof8_copy(void *that) {
    return new __seqof8_member(((__seqof8_member *)that)->value);
}

static void __seqof8_destroy(void *that) {
    delete (__seqof8_member *)that;
}

static int __seqof8_compare(void *val1, void *val2) {
    return (((__seqof8_member *)val1)->value == ((__seqof8_member *)val2)->value);
}

/* Constructors */

__seqof8::__seqof8() {
}

__seqof8::__seqof8(const __seqof8 & that) {
    OSSTRY {
	do_copy(that, &__seqof8_copy);
    } OSSCLEAN(__seqof8)
}

/* Destructor */

__seqof8::~__seqof8() {
    do_destroy(&__seqof8_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof8 & __seqof8::operator = (const __seqof8 & that) {
    do_destroy(&__seqof8_destroy);
    do_copy(that, &__seqof8_copy);
    return *this;
}

int __seqof8::operator == (const __seqof8 & that) const {
    return do_compare(that, &__seqof8_compare);
}

int __seqof8::operator != (const __seqof8 & that) const {
    return !do_compare(that, &__seqof8_compare);
}

/* Locate ("At" etc) methods */

__seqof8::component *__seqof8::at(OssIndex pos) {
    return &((__seqof8_member *)pos)->value;
}

const __seqof8::component *__seqof8::at(OssIndex pos) const {
    return &((__seqof8_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof8::prepend(const component & val) {
    __seqof8_member *newrec = new __seqof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof8::prepend(__seqof8 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof8::insert_after(OssIndex pos, const component & val) {
    __seqof8_member *newrec = new __seqof8_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof8::insert_after(OssIndex pos, __seqof8 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof8::remove_front() {
    __seqof8_member *extr = (__seqof8_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof8_destroy(extr);
    return 0;
}

int __seqof8::remove_after(OssIndex pos) {
    __seqof8_member *extr = (__seqof8_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof8_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof8 *__seqof8::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof8 *)do_extract_after(begin, end);
}

void *AttestationReference::operator new(size_t size) {
    return ossNewFunc(size);
}

void AttestationReference::operator delete(void *ptr) {
    asn1Free(ptr);
}

AttestationReference::AttestationReference() {
    memset(this, 0, sizeof(AttestationReference));
}

AttestationReference::AttestationReference(const AttestationReference & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	hash_field = that.hash_field;
	content_field = that.content_field;
	location_field = that.location_field;
	keys_field = that.keys_field;
	revocationChecks_field = that.revocationChecks_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(AttestationReference)
}

AttestationReference::AttestationReference(const hash & hash_val, const content & content_val, 
    const location & location_val, const keys & keys_val, const revocationChecks & revocationChecks_val, 
    const extensions & extensions_val) {
    OSSTRY {
	bit_mask = 0x80;
	hash_field = hash_val;
	content_field = content_val;
	location_field = location_val;
	keys_field = keys_val;
	revocationChecks_field = revocationChecks_val;
	extensions_field = extensions_val;
    } OSSCLEAN(AttestationReference)
}

AttestationReference::AttestationReference(const hash & hash_val, const location & location_val, 
    const keys & keys_val, const revocationChecks & revocationChecks_val, const extensions & extensions_val) {
    OSSTRY {
	bit_mask = 0;
	hash_field = hash_val;
	location_field = location_val;
	keys_field = keys_val;
	revocationChecks_field = revocationChecks_val;
	extensions_field = extensions_val;
    } OSSCLEAN(AttestationReference)
}

AttestationReference & AttestationReference::operator = (const AttestationReference & that) {
    if (this == &that)
	return *this;
    this->~AttestationReference();
    bit_mask = that.bit_mask;
    hash_field = that.hash_field;
    content_field = that.content_field;
    location_field = that.location_field;
    keys_field = that.keys_field;
    revocationChecks_field = that.revocationChecks_field;
    extensions_field = that.extensions_field;
    return *this;
}

int AttestationReference::operator == (const AttestationReference & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (hash_field != that.hash_field)
	return 0;
    if (bit_mask & 0x80) {
	if (content_field != that.content_field)
	    return 0;
    }
    if (location_field != that.location_field)
	return 0;
    if (keys_field != that.keys_field)
	return 0;
    if (revocationChecks_field != that.revocationChecks_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    return 1;
}

int AttestationReference::operator != (const AttestationReference & that) const {
    return !(operator ==(that));
}

AttestationReference::hash & AttestationReference::get_hash() {
    return hash_field;
}

const AttestationReference::hash & AttestationReference::get_hash() const {
    return hash_field;
}

void AttestationReference::set_hash(const hash & hash_val) {
    hash_field = hash_val;
}

AttestationReference::content *AttestationReference::get_content() {
    if (bit_mask & 0x80)
	return &content_field;
    else
	return 0;
}

const AttestationReference::content *AttestationReference::get_content() const {
    if (bit_mask & 0x80)
	return &content_field;
    else
	return 0;
}

void AttestationReference::set_content(const content & content_val) {
    bit_mask |= 0x80;
    content_field = content_val;
}

int AttestationReference::content_is_present() const {
    return !!(bit_mask & 0x80);
}

void AttestationReference::omit_content() {
    content_field.~OssString();
    bit_mask &= ~0x80;
}

AttestationReference::location & AttestationReference::get_location() {
    return location_field;
}

const AttestationReference::location & AttestationReference::get_location() const {
    return location_field;
}

void AttestationReference::set_location(const location & location_val) {
    location_field = location_val;
}

AttestationReference::keys & AttestationReference::get_keys() {
    return keys_field;
}

const AttestationReference::keys & AttestationReference::get_keys() const {
    return keys_field;
}

void AttestationReference::set_keys(const keys & keys_val) {
    keys_field = keys_val;
}

AttestationReference::revocationChecks & AttestationReference::get_revocationChecks() {
    return revocationChecks_field;
}

const AttestationReference::revocationChecks & AttestationReference::get_revocationChecks() const {
    return revocationChecks_field;
}

void AttestationReference::set_revocationChecks(const revocationChecks & revocationChecks_val) {
    revocationChecks_field = revocationChecks_val;
}

AttestationReference::extensions & AttestationReference::get_extensions() {
    return extensions_field;
}

const AttestationReference::extensions & AttestationReference::get_extensions() const {
    return extensions_field;
}

void AttestationReference::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

void *RTreeStatement::operator new(size_t size) {
    return ossNewFunc(size);
}

void RTreeStatement::operator delete(void *ptr) {
    asn1Free(ptr);
}

RTreeStatement::RTreeStatement() {
    memset(this, 0, sizeof(RTreeStatement));
}

RTreeStatement::RTreeStatement(const RTreeStatement & that) {
    OSSTRY {
	bit_mask = that.bit_mask;
	permissionSet_field = that.permissionSet_field;
	permissions_field = that.permissions_field;
	resource_field = that.resource_field;
	comment_field = that.comment_field;
    } OSSCLEAN(RTreeStatement)
}

RTreeStatement::RTreeStatement(const permissionSet & permissionSet_val, const permissions & permissions_val, 
    const resource & resource_val, const comment & comment_val) {
    OSSTRY {
	bit_mask = 0x80;
	permissionSet_field = permissionSet_val;
	permissions_field = permissions_val;
	resource_field = resource_val;
	comment_field = comment_val;
    } OSSCLEAN(RTreeStatement)
}

RTreeStatement::RTreeStatement(const permissionSet & permissionSet_val, const permissions & permissions_val, 
    const resource & resource_val) {
    OSSTRY {
	bit_mask = 0;
	permissionSet_field = permissionSet_val;
	permissions_field = permissions_val;
	resource_field = resource_val;
    } OSSCLEAN(RTreeStatement)
}

RTreeStatement & RTreeStatement::operator = (const RTreeStatement & that) {
    if (this == &that)
	return *this;
    this->~RTreeStatement();
    bit_mask = that.bit_mask;
    permissionSet_field = that.permissionSet_field;
    permissions_field = that.permissions_field;
    resource_field = that.resource_field;
    comment_field = that.comment_field;
    return *this;
}

int RTreeStatement::operator == (const RTreeStatement & that) const {
    if (bit_mask != that.bit_mask)
	return 0;
    if (permissionSet_field != that.permissionSet_field)
	return 0;
    if (permissions_field != that.permissions_field)
	return 0;
    if (resource_field != that.resource_field)
	return 0;
    if (bit_mask & 0x80) {
	if (comment_field != that.comment_field)
	    return 0;
    }
    return 1;
}

int RTreeStatement::operator != (const RTreeStatement & that) const {
    return !(operator ==(that));
}

RTreeStatement::permissionSet & RTreeStatement::get_permissionSet() {
    return permissionSet_field;
}

const RTreeStatement::permissionSet & RTreeStatement::get_permissionSet() const {
    return permissionSet_field;
}

void RTreeStatement::set_permissionSet(const permissionSet & permissionSet_val) {
    permissionSet_field = permissionSet_val;
}

RTreeStatement::permissions & RTreeStatement::get_permissions() {
    return permissions_field;
}

const RTreeStatement::permissions & RTreeStatement::get_permissions() const {
    return permissions_field;
}

void RTreeStatement::set_permissions(const permissions & permissions_val) {
    permissions_field = permissions_val;
}

RTreeStatement::resource & RTreeStatement::get_resource() {
    return resource_field;
}

const RTreeStatement::resource & RTreeStatement::get_resource() const {
    return resource_field;
}

void RTreeStatement::set_resource(const resource & resource_val) {
    resource_field = resource_val;
}

RTreeStatement::comment *RTreeStatement::get_comment() {
    if (bit_mask & 0x80)
	return &comment_field;
    else
	return 0;
}

const RTreeStatement::comment *RTreeStatement::get_comment() const {
    if (bit_mask & 0x80)
	return &comment_field;
    else
	return 0;
}

void RTreeStatement::set_comment(const comment & comment_val) {
    bit_mask |= 0x80;
    comment_field = comment_val;
}

int RTreeStatement::comment_is_present() const {
    return !!(bit_mask & 0x80);
}

void RTreeStatement::omit_comment() {
    comment_field.~OssString();
    bit_mask &= ~0x80;
}

void *WR1Envelope::operator new(size_t size) {
    return ossNewFunc(size);
}

void WR1Envelope::operator delete(void *ptr) {
    asn1Free(ptr);
}

WR1Envelope::WR1Envelope() {
    memset(this, 0, sizeof(WR1Envelope));
}

WR1Envelope::WR1Envelope(const WR1Envelope & that) {
    OSSTRY {
	bodyKeys_oaque_field = that.bodyKeys_oaque_field;
	partition_field = that.partition_field;
    } OSSCLEAN(WR1Envelope)
}

WR1Envelope::WR1Envelope(const bodyKeys_oaque & bodyKeys_oaque_val, const partition & partition_val) {
    OSSTRY {
	bodyKeys_oaque_field = bodyKeys_oaque_val;
	partition_field = partition_val;
    } OSSCLEAN(WR1Envelope)
}

WR1Envelope & WR1Envelope::operator = (const WR1Envelope & that) {
    if (this == &that)
	return *this;
    bodyKeys_oaque_field = that.bodyKeys_oaque_field;
    partition_field = that.partition_field;
    return *this;
}

int WR1Envelope::operator == (const WR1Envelope & that) const {
    if (bodyKeys_oaque_field != that.bodyKeys_oaque_field)
	return 0;
    if (partition_field != that.partition_field)
	return 0;
    return 1;
}

int WR1Envelope::operator != (const WR1Envelope & that) const {
    return !(operator ==(that));
}

WR1Envelope::bodyKeys_oaque & WR1Envelope::get_bodyKeys_oaque() {
    return bodyKeys_oaque_field;
}

const WR1Envelope::bodyKeys_oaque & WR1Envelope::get_bodyKeys_oaque() const {
    return bodyKeys_oaque_field;
}

void WR1Envelope::set_bodyKeys_oaque(const bodyKeys_oaque & bodyKeys_oaque_val) {
    bodyKeys_oaque_field = bodyKeys_oaque_val;
}

WR1Envelope::partition & WR1Envelope::get_partition() {
    return partition_field;
}

const WR1Envelope::partition & WR1Envelope::get_partition() const {
    return partition_field;
}

void WR1Envelope::set_partition(const partition & partition_val) {
    partition_field = partition_val;
}

void *WR1ProverBody::operator new(size_t size) {
    return ossNewFunc(size);
}

void WR1ProverBody::operator delete(void *ptr) {
    asn1Free(ptr);
}

WR1ProverBody::WR1ProverBody() {
    memset(this, 0, sizeof(WR1ProverBody));
}

WR1ProverBody::WR1ProverBody(const WR1ProverBody & that) {
    OSSTRY {
	addendums_field = that.addendums_field;
	extensions_field = that.extensions_field;
    } OSSCLEAN(WR1ProverBody)
}

WR1ProverBody::WR1ProverBody(const addendums & addendums_val, const extensions & extensions_val) {
    OSSTRY {
	addendums_field = addendums_val;
	extensions_field = extensions_val;
    } OSSCLEAN(WR1ProverBody)
}

WR1ProverBody & WR1ProverBody::operator = (const WR1ProverBody & that) {
    if (this == &that)
	return *this;
    addendums_field = that.addendums_field;
    extensions_field = that.extensions_field;
    return *this;
}

int WR1ProverBody::operator == (const WR1ProverBody & that) const {
    if (addendums_field != that.addendums_field)
	return 0;
    if (extensions_field != that.extensions_field)
	return 0;
    return 1;
}

int WR1ProverBody::operator != (const WR1ProverBody & that) const {
    return !(operator ==(that));
}

WR1ProverBody::addendums & WR1ProverBody::get_addendums() {
    return addendums_field;
}

const WR1ProverBody::addendums & WR1ProverBody::get_addendums() const {
    return addendums_field;
}

void WR1ProverBody::set_addendums(const addendums & addendums_val) {
    addendums_field = addendums_val;
}

WR1ProverBody::extensions & WR1ProverBody::get_extensions() {
    return extensions_field;
}

const WR1ProverBody::extensions & WR1ProverBody::get_extensions() const {
    return extensions_field;
}

void WR1ProverBody::set_extensions(const extensions & extensions_val) {
    extensions_field = extensions_val;
}

void *WR1VerifierBody::operator new(size_t size) {
    return ossNewFunc(size);
}

void WR1VerifierBody::operator delete(void *ptr) {
    asn1Free(ptr);
}

WR1VerifierBody::WR1VerifierBody() {
    memset(this, 0, sizeof(WR1VerifierBody));
}

WR1VerifierBody::WR1VerifierBody(const WR1VerifierBody & that) {
    OSSTRY {
	attestationVerifierBody_field = that.attestationVerifierBody_field;
    } OSSCLEAN(WR1VerifierBody)
}

WR1VerifierBody::WR1VerifierBody(const attestationVerifierBody & attestationVerifierBody_val) {
    OSSTRY {
	attestationVerifierBody_field = attestationVerifierBody_val;
    } OSSCLEAN(WR1VerifierBody)
}

WR1VerifierBody & WR1VerifierBody::operator = (const WR1VerifierBody & that) {
    if (this == &that)
	return *this;
    attestationVerifierBody_field = that.attestationVerifierBody_field;
    return *this;
}

int WR1VerifierBody::operator == (const WR1VerifierBody & that) const {
    if (attestationVerifierBody_field != that.attestationVerifierBody_field)
	return 0;
    return 1;
}

int WR1VerifierBody::operator != (const WR1VerifierBody & that) const {
    return !(operator ==(that));
}

WR1VerifierBody::attestationVerifierBody & WR1VerifierBody::get_attestationVerifierBody() {
    return attestationVerifierBody_field;
}

const WR1VerifierBody::attestationVerifierBody & WR1VerifierBody::get_attestationVerifierBody() const {
    return attestationVerifierBody_field;
}

void WR1VerifierBody::set_attestationVerifierBody(const attestationVerifierBody & attestationVerifierBody_val) {
    attestationVerifierBody_field = attestationVerifierBody_val;
}

/* Universal PDU class */

objects_PDU::objects_PDU() {
}

void objects_PDU::set_WaveWireObject(WaveWireObject & d) {
    index = 1;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveWireObject *objects_PDU::get_WaveWireObject() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 1 && !constant)
#else
    if (index == 1)
#endif
	return (WaveWireObject *)data;
    else
	return 0;
}

void objects_PDU::set_WaveAttestation(WaveAttestation & d) {
    index = 2;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveAttestation *objects_PDU::get_WaveAttestation() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 2 && !constant)
#else
    if (index == 2)
#endif
	return (WaveAttestation *)data;
    else
	return 0;
}

void objects_PDU::set_AttestationBody(AttestationBody & d) {
    index = 3;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttestationBody *objects_PDU::get_AttestationBody() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 3 && !constant)
#else
    if (index == 3)
#endif
	return (AttestationBody *)data;
    else
	return 0;
}

void objects_PDU::set_WaveEntity(WaveEntity & d) {
    index = 4;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveEntity *objects_PDU::get_WaveEntity() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 4 && !constant)
#else
    if (index == 4)
#endif
	return (WaveEntity *)data;
    else
	return 0;
}

void objects_PDU::set_WaveEntitySecret(WaveEntitySecret & d) {
    index = 5;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveEntitySecret *objects_PDU::get_WaveEntitySecret() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 5 && !constant)
#else
    if (index == 5)
#endif
	return (WaveEntitySecret *)data;
    else
	return 0;
}

void objects_PDU::set_EntityKeyring(EntityKeyring & d) {
    index = 6;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EntityKeyring *objects_PDU::get_EntityKeyring() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 6 && !constant)
#else
    if (index == 6)
#endif
	return (EntityKeyring *)data;
    else
	return 0;
}

void objects_PDU::set_EntityKeyringEntry(EntityKeyringEntry & d) {
    index = 7;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EntityKeyringEntry *objects_PDU::get_EntityKeyringEntry() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 7 && !constant)
#else
    if (index == 7)
#endif
	return (EntityKeyringEntry *)data;
    else
	return 0;
}

void objects_PDU::set_WaveExplicitProof(WaveExplicitProof & d) {
    index = 8;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveExplicitProof *objects_PDU::get_WaveExplicitProof() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 8 && !constant)
#else
    if (index == 8)
#endif
	return (WaveExplicitProof *)data;
    else
	return 0;
}

void objects_PDU::set_RTreePolicy(RTreePolicy & d) {
    index = 9;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

RTreePolicy *objects_PDU::get_RTreePolicy() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 9 && !constant)
#else
    if (index == 9)
#endif
	return (RTreePolicy *)data;
    else
	return 0;
}

void objects_PDU::set_HashSha3_256(HashSha3_256 & d) {
    index = 10;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashSha3_256 *objects_PDU::get_HashSha3_256() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 10 && !constant)
#else
    if (index == 10)
#endif
	return (HashSha3_256 *)data;
    else
	return 0;
}

void objects_PDU::set_HashSha_256(HashSha_256 & d) {
    index = 11;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashSha_256 *objects_PDU::get_HashSha_256() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 11 && !constant)
#else
    if (index == 11)
#endif
	return (HashSha_256 *)data;
    else
	return 0;
}

void objects_PDU::set_HashKeccak_256(HashKeccak_256 & d) {
    index = 12;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashKeccak_256 *objects_PDU::get_HashKeccak_256() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 12 && !constant)
#else
    if (index == 12)
#endif
	return (HashKeccak_256 *)data;
    else
	return 0;
}

void objects_PDU::set_LocationURL(LocationURL & d) {
    index = 13;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocationURL *objects_PDU::get_LocationURL() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 13 && !constant)
#else
    if (index == 13)
#endif
	return (LocationURL *)data;
    else
	return 0;
}

void objects_PDU::set_LocationEthereum(LocationEthereum & d) {
    index = 14;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocationEthereum *objects_PDU::get_LocationEthereum() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 14 && !constant)
#else
    if (index == 14)
#endif
	return (LocationEthereum *)data;
    else
	return 0;
}

void objects_PDU::set_PSKBodyCiphertext(PSKBodyCiphertext & d) {
    index = 15;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PSKBodyCiphertext *objects_PDU::get_PSKBodyCiphertext() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 15 && !constant)
#else
    if (index == 15)
#endif
	return (PSKBodyCiphertext *)data;
    else
	return 0;
}

void objects_PDU::set_WR1BodyCiphertext(WR1BodyCiphertext & d) {
    index = 16;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1BodyCiphertext *objects_PDU::get_WR1BodyCiphertext() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 16 && !constant)
#else
    if (index == 16)
#endif
	return (WR1BodyCiphertext *)data;
    else
	return 0;
}

void objects_PDU::set_WR1Envelope(WR1Envelope & d) {
    index = 17;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1Envelope *objects_PDU::get_WR1Envelope() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 17 && !constant)
#else
    if (index == 17)
#endif
	return (WR1Envelope *)data;
    else
	return 0;
}

void objects_PDU::set_WR1ProverBody(WR1ProverBody & d) {
    index = 18;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1ProverBody *objects_PDU::get_WR1ProverBody() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 18 && !constant)
#else
    if (index == 18)
#endif
	return (WR1ProverBody *)data;
    else
	return 0;
}

void objects_PDU::set_WR1VerifierBody(WR1VerifierBody & d) {
    index = 19;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1VerifierBody *objects_PDU::get_WR1VerifierBody() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 19 && !constant)
#else
    if (index == 19)
#endif
	return (WR1VerifierBody *)data;
    else
	return 0;
}

void objects_PDU::set_Ed25519OuterSignature(Ed25519OuterSignature & d) {
    index = 20;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Ed25519OuterSignature *objects_PDU::get_Ed25519OuterSignature() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 20 && !constant)
#else
    if (index == 20)
#endif
	return (Ed25519OuterSignature *)data;
    else
	return 0;
}

void objects_PDU::set_SignedOuterKey(SignedOuterKey & d) {
    index = 21;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SignedOuterKey *objects_PDU::get_SignedOuterKey() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 21 && !constant)
#else
    if (index == 21)
#endif
	return (SignedOuterKey *)data;
    else
	return 0;
}

void objects_PDU::set_TrustLevel(TrustLevel & d) {
    index = 22;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TrustLevel *objects_PDU::get_TrustLevel() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 22 && !constant)
#else
    if (index == 22)
#endif
	return (TrustLevel *)data;
    else
	return 0;
}

void objects_PDU::set_CommitmentRevocationOption(CommitmentRevocationOption & d) {
    index = 23;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommitmentRevocationOption *objects_PDU::get_CommitmentRevocationOption() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 23 && !constant)
#else
    if (index == 23)
#endif
	return (CommitmentRevocationOption *)data;
    else
	return 0;
}

void objects_PDU::set_AVKeyAES128_GCM(AVKeyAES128_GCM & d) {
    index = 24;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AVKeyAES128_GCM *objects_PDU::get_AVKeyAES128_GCM() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 24 && !constant)
#else
    if (index == 24)
#endif
	return (AVKeyAES128_GCM *)data;
    else
	return 0;
}

void objects_PDU::set_Private_Ed25519(Private_Ed25519 & d) {
    index = 25;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_Ed25519 *objects_PDU::get_Private_Ed25519() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 25 && !constant)
#else
    if (index == 25)
#endif
	return (Private_Ed25519 *)data;
    else
	return 0;
}

void objects_PDU::set_Private_Curve25519(Private_Curve25519 & d) {
    index = 26;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_Curve25519 *objects_PDU::get_Private_Curve25519() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 26 && !constant)
#else
    if (index == 26)
#endif
	return (Private_Curve25519 *)data;
    else
	return 0;
}

void objects_PDU::set_Private_BN256_OAQUE(Private_BN256_OAQUE & d) {
    index = 27;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_BN256_OAQUE *objects_PDU::get_Private_BN256_OAQUE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 27 && !constant)
#else
    if (index == 27)
#endif
	return (Private_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_Private_BN256_IBE(Private_BN256_IBE & d) {
    index = 28;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_BN256_IBE *objects_PDU::get_Private_BN256_IBE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 28 && !constant)
#else
    if (index == 28)
#endif
	return (Private_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_Master_BN256_OAQUE(Master_BN256_OAQUE & d) {
    index = 29;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Master_BN256_OAQUE *objects_PDU::get_Master_BN256_OAQUE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 29 && !constant)
#else
    if (index == 29)
#endif
	return (Master_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_Master_BN256_IBE(Master_BN256_IBE & d) {
    index = 30;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Master_BN256_IBE *objects_PDU::get_Master_BN256_IBE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 30 && !constant)
#else
    if (index == 30)
#endif
	return (Master_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_Public_Ed25519(Public_Ed25519 & d) {
    index = 31;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_Ed25519 *objects_PDU::get_Public_Ed25519() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 31 && !constant)
#else
    if (index == 31)
#endif
	return (Public_Ed25519 *)data;
    else
	return 0;
}

void objects_PDU::set_Public_Curve25519(Public_Curve25519 & d) {
    index = 32;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_Curve25519 *objects_PDU::get_Public_Curve25519() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 32 && !constant)
#else
    if (index == 32)
#endif
	return (Public_Curve25519 *)data;
    else
	return 0;
}

void objects_PDU::set_Public_OAQUE(Public_OAQUE & d) {
    index = 33;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_OAQUE *objects_PDU::get_Public_OAQUE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 33 && !constant)
#else
    if (index == 33)
#endif
	return (Public_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_Params_BN256_OAQUE(Params_BN256_OAQUE & d) {
    index = 34;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Params_BN256_OAQUE *objects_PDU::get_Params_BN256_OAQUE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 34 && !constant)
#else
    if (index == 34)
#endif
	return (Params_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_Params_BN256_IBE(Params_BN256_IBE & d) {
    index = 35;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Params_BN256_IBE *objects_PDU::get_Params_BN256_IBE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 35 && !constant)
#else
    if (index == 35)
#endif
	return (Params_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_Public_BN256_IBE(Public_BN256_IBE & d) {
    index = 36;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_BN256_IBE *objects_PDU::get_Public_BN256_IBE() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 36 && !constant)
#else
    if (index == 36)
#endif
	return (Public_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_KeyringAESCiphertext(KeyringAESCiphertext & d) {
    index = 37;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KeyringAESCiphertext *objects_PDU::get_KeyringAESCiphertext() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 37 && !constant)
#else
    if (index == 37)
#endif
	return (KeyringAESCiphertext *)data;
    else
	return 0;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
void objects_PDU::set_const_WaveWireObject(const WaveWireObject & d) {
    index = 1;
    data = (void *)&d;
    constant = 1;
}

const WaveWireObject *objects_PDU::get_const_WaveWireObject() const {
    if (index == 1)
	return (const WaveWireObject *)data;
    else
	return 0;
}

void objects_PDU::set_const_WaveAttestation(const WaveAttestation & d) {
    index = 2;
    data = (void *)&d;
    constant = 1;
}

const WaveAttestation *objects_PDU::get_const_WaveAttestation() const {
    if (index == 2)
	return (const WaveAttestation *)data;
    else
	return 0;
}

void objects_PDU::set_const_AttestationBody(const AttestationBody & d) {
    index = 3;
    data = (void *)&d;
    constant = 1;
}

const AttestationBody *objects_PDU::get_const_AttestationBody() const {
    if (index == 3)
	return (const AttestationBody *)data;
    else
	return 0;
}

void objects_PDU::set_const_WaveEntity(const WaveEntity & d) {
    index = 4;
    data = (void *)&d;
    constant = 1;
}

const WaveEntity *objects_PDU::get_const_WaveEntity() const {
    if (index == 4)
	return (const WaveEntity *)data;
    else
	return 0;
}

void objects_PDU::set_const_WaveEntitySecret(const WaveEntitySecret & d) {
    index = 5;
    data = (void *)&d;
    constant = 1;
}

const WaveEntitySecret *objects_PDU::get_const_WaveEntitySecret() const {
    if (index == 5)
	return (const WaveEntitySecret *)data;
    else
	return 0;
}

void objects_PDU::set_const_EntityKeyring(const EntityKeyring & d) {
    index = 6;
    data = (void *)&d;
    constant = 1;
}

const EntityKeyring *objects_PDU::get_const_EntityKeyring() const {
    if (index == 6)
	return (const EntityKeyring *)data;
    else
	return 0;
}

void objects_PDU::set_const_EntityKeyringEntry(const EntityKeyringEntry & d) {
    index = 7;
    data = (void *)&d;
    constant = 1;
}

const EntityKeyringEntry *objects_PDU::get_const_EntityKeyringEntry() const {
    if (index == 7)
	return (const EntityKeyringEntry *)data;
    else
	return 0;
}

void objects_PDU::set_const_WaveExplicitProof(const WaveExplicitProof & d) {
    index = 8;
    data = (void *)&d;
    constant = 1;
}

const WaveExplicitProof *objects_PDU::get_const_WaveExplicitProof() const {
    if (index == 8)
	return (const WaveExplicitProof *)data;
    else
	return 0;
}

void objects_PDU::set_const_RTreePolicy(const RTreePolicy & d) {
    index = 9;
    data = (void *)&d;
    constant = 1;
}

const RTreePolicy *objects_PDU::get_const_RTreePolicy() const {
    if (index == 9)
	return (const RTreePolicy *)data;
    else
	return 0;
}

void objects_PDU::set_const_HashSha3_256(const HashSha3_256 & d) {
    index = 10;
    data = (void *)&d;
    constant = 1;
}

const HashSha3_256 *objects_PDU::get_const_HashSha3_256() const {
    if (index == 10)
	return (const HashSha3_256 *)data;
    else
	return 0;
}

void objects_PDU::set_const_HashSha_256(const HashSha_256 & d) {
    index = 11;
    data = (void *)&d;
    constant = 1;
}

const HashSha_256 *objects_PDU::get_const_HashSha_256() const {
    if (index == 11)
	return (const HashSha_256 *)data;
    else
	return 0;
}

void objects_PDU::set_const_HashKeccak_256(const HashKeccak_256 & d) {
    index = 12;
    data = (void *)&d;
    constant = 1;
}

const HashKeccak_256 *objects_PDU::get_const_HashKeccak_256() const {
    if (index == 12)
	return (const HashKeccak_256 *)data;
    else
	return 0;
}

void objects_PDU::set_const_LocationURL(const LocationURL & d) {
    index = 13;
    data = (void *)&d;
    constant = 1;
}

const LocationURL *objects_PDU::get_const_LocationURL() const {
    if (index == 13)
	return (const LocationURL *)data;
    else
	return 0;
}

void objects_PDU::set_const_LocationEthereum(const LocationEthereum & d) {
    index = 14;
    data = (void *)&d;
    constant = 1;
}

const LocationEthereum *objects_PDU::get_const_LocationEthereum() const {
    if (index == 14)
	return (const LocationEthereum *)data;
    else
	return 0;
}

void objects_PDU::set_const_PSKBodyCiphertext(const PSKBodyCiphertext & d) {
    index = 15;
    data = (void *)&d;
    constant = 1;
}

const PSKBodyCiphertext *objects_PDU::get_const_PSKBodyCiphertext() const {
    if (index == 15)
	return (const PSKBodyCiphertext *)data;
    else
	return 0;
}

void objects_PDU::set_const_WR1BodyCiphertext(const WR1BodyCiphertext & d) {
    index = 16;
    data = (void *)&d;
    constant = 1;
}

const WR1BodyCiphertext *objects_PDU::get_const_WR1BodyCiphertext() const {
    if (index == 16)
	return (const WR1BodyCiphertext *)data;
    else
	return 0;
}

void objects_PDU::set_const_WR1Envelope(const WR1Envelope & d) {
    index = 17;
    data = (void *)&d;
    constant = 1;
}

const WR1Envelope *objects_PDU::get_const_WR1Envelope() const {
    if (index == 17)
	return (const WR1Envelope *)data;
    else
	return 0;
}

void objects_PDU::set_const_WR1ProverBody(const WR1ProverBody & d) {
    index = 18;
    data = (void *)&d;
    constant = 1;
}

const WR1ProverBody *objects_PDU::get_const_WR1ProverBody() const {
    if (index == 18)
	return (const WR1ProverBody *)data;
    else
	return 0;
}

void objects_PDU::set_const_WR1VerifierBody(const WR1VerifierBody & d) {
    index = 19;
    data = (void *)&d;
    constant = 1;
}

const WR1VerifierBody *objects_PDU::get_const_WR1VerifierBody() const {
    if (index == 19)
	return (const WR1VerifierBody *)data;
    else
	return 0;
}

void objects_PDU::set_const_Ed25519OuterSignature(const Ed25519OuterSignature & d) {
    index = 20;
    data = (void *)&d;
    constant = 1;
}

const Ed25519OuterSignature *objects_PDU::get_const_Ed25519OuterSignature() const {
    if (index == 20)
	return (const Ed25519OuterSignature *)data;
    else
	return 0;
}

void objects_PDU::set_const_SignedOuterKey(const SignedOuterKey & d) {
    index = 21;
    data = (void *)&d;
    constant = 1;
}

const SignedOuterKey *objects_PDU::get_const_SignedOuterKey() const {
    if (index == 21)
	return (const SignedOuterKey *)data;
    else
	return 0;
}

void objects_PDU::set_const_TrustLevel(const TrustLevel & d) {
    index = 22;
    data = (void *)&d;
    constant = 1;
}

const TrustLevel *objects_PDU::get_const_TrustLevel() const {
    if (index == 22)
	return (const TrustLevel *)data;
    else
	return 0;
}

void objects_PDU::set_const_CommitmentRevocationOption(const CommitmentRevocationOption & d) {
    index = 23;
    data = (void *)&d;
    constant = 1;
}

const CommitmentRevocationOption *objects_PDU::get_const_CommitmentRevocationOption() const {
    if (index == 23)
	return (const CommitmentRevocationOption *)data;
    else
	return 0;
}

void objects_PDU::set_const_AVKeyAES128_GCM(const AVKeyAES128_GCM & d) {
    index = 24;
    data = (void *)&d;
    constant = 1;
}

const AVKeyAES128_GCM *objects_PDU::get_const_AVKeyAES128_GCM() const {
    if (index == 24)
	return (const AVKeyAES128_GCM *)data;
    else
	return 0;
}

void objects_PDU::set_const_Private_Ed25519(const Private_Ed25519 & d) {
    index = 25;
    data = (void *)&d;
    constant = 1;
}

const Private_Ed25519 *objects_PDU::get_const_Private_Ed25519() const {
    if (index == 25)
	return (const Private_Ed25519 *)data;
    else
	return 0;
}

void objects_PDU::set_const_Private_Curve25519(const Private_Curve25519 & d) {
    index = 26;
    data = (void *)&d;
    constant = 1;
}

const Private_Curve25519 *objects_PDU::get_const_Private_Curve25519() const {
    if (index == 26)
	return (const Private_Curve25519 *)data;
    else
	return 0;
}

void objects_PDU::set_const_Private_BN256_OAQUE(const Private_BN256_OAQUE & d) {
    index = 27;
    data = (void *)&d;
    constant = 1;
}

const Private_BN256_OAQUE *objects_PDU::get_const_Private_BN256_OAQUE() const {
    if (index == 27)
	return (const Private_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Private_BN256_IBE(const Private_BN256_IBE & d) {
    index = 28;
    data = (void *)&d;
    constant = 1;
}

const Private_BN256_IBE *objects_PDU::get_const_Private_BN256_IBE() const {
    if (index == 28)
	return (const Private_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Master_BN256_OAQUE(const Master_BN256_OAQUE & d) {
    index = 29;
    data = (void *)&d;
    constant = 1;
}

const Master_BN256_OAQUE *objects_PDU::get_const_Master_BN256_OAQUE() const {
    if (index == 29)
	return (const Master_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Master_BN256_IBE(const Master_BN256_IBE & d) {
    index = 30;
    data = (void *)&d;
    constant = 1;
}

const Master_BN256_IBE *objects_PDU::get_const_Master_BN256_IBE() const {
    if (index == 30)
	return (const Master_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Public_Ed25519(const Public_Ed25519 & d) {
    index = 31;
    data = (void *)&d;
    constant = 1;
}

const Public_Ed25519 *objects_PDU::get_const_Public_Ed25519() const {
    if (index == 31)
	return (const Public_Ed25519 *)data;
    else
	return 0;
}

void objects_PDU::set_const_Public_Curve25519(const Public_Curve25519 & d) {
    index = 32;
    data = (void *)&d;
    constant = 1;
}

const Public_Curve25519 *objects_PDU::get_const_Public_Curve25519() const {
    if (index == 32)
	return (const Public_Curve25519 *)data;
    else
	return 0;
}

void objects_PDU::set_const_Public_OAQUE(const Public_OAQUE & d) {
    index = 33;
    data = (void *)&d;
    constant = 1;
}

const Public_OAQUE *objects_PDU::get_const_Public_OAQUE() const {
    if (index == 33)
	return (const Public_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Params_BN256_OAQUE(const Params_BN256_OAQUE & d) {
    index = 34;
    data = (void *)&d;
    constant = 1;
}

const Params_BN256_OAQUE *objects_PDU::get_const_Params_BN256_OAQUE() const {
    if (index == 34)
	return (const Params_BN256_OAQUE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Params_BN256_IBE(const Params_BN256_IBE & d) {
    index = 35;
    data = (void *)&d;
    constant = 1;
}

const Params_BN256_IBE *objects_PDU::get_const_Params_BN256_IBE() const {
    if (index == 35)
	return (const Params_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_const_Public_BN256_IBE(const Public_BN256_IBE & d) {
    index = 36;
    data = (void *)&d;
    constant = 1;
}

const Public_BN256_IBE *objects_PDU::get_const_Public_BN256_IBE() const {
    if (index == 36)
	return (const Public_BN256_IBE *)data;
    else
	return 0;
}

void objects_PDU::set_const_KeyringAESCiphertext(const KeyringAESCiphertext & d) {
    index = 37;
    data = (void *)&d;
    constant = 1;
}

const KeyringAESCiphertext *objects_PDU::get_const_KeyringAESCiphertext() const {
    if (index == 37)
	return (const KeyringAESCiphertext *)data;
    else
	return 0;
}

#endif
/* Specific PDU classes */

WaveWireObject_PDU::WaveWireObject_PDU() {
}

void WaveWireObject_PDU::set_data(WaveWireObject & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveWireObject *WaveWireObject_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveWireObject *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveWireObject_PDU::set_const_data(const WaveWireObject & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveWireObject *WaveWireObject_PDU::get_const_data() const {
    return (const WaveWireObject *)data;
}

#endif

OssTypeIndex WaveWireObject_PDU::get_index() const {
    return 1;
}

WaveAttestation_PDU::WaveAttestation_PDU() {
}

void WaveAttestation_PDU::set_data(WaveAttestation & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveAttestation *WaveAttestation_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveAttestation *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveAttestation_PDU::set_const_data(const WaveAttestation & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveAttestation *WaveAttestation_PDU::get_const_data() const {
    return (const WaveAttestation *)data;
}

#endif

OssTypeIndex WaveAttestation_PDU::get_index() const {
    return 2;
}

AttestationBody_PDU::AttestationBody_PDU() {
}

void AttestationBody_PDU::set_data(AttestationBody & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AttestationBody *AttestationBody_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AttestationBody *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AttestationBody_PDU::set_const_data(const AttestationBody & d) {
    data = (void *)&d;
    constant = 1;
}

const AttestationBody *AttestationBody_PDU::get_const_data() const {
    return (const AttestationBody *)data;
}

#endif

OssTypeIndex AttestationBody_PDU::get_index() const {
    return 3;
}

WaveEntity_PDU::WaveEntity_PDU() {
}

void WaveEntity_PDU::set_data(WaveEntity & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveEntity *WaveEntity_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveEntity *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveEntity_PDU::set_const_data(const WaveEntity & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveEntity *WaveEntity_PDU::get_const_data() const {
    return (const WaveEntity *)data;
}

#endif

OssTypeIndex WaveEntity_PDU::get_index() const {
    return 4;
}

WaveEntitySecret_PDU::WaveEntitySecret_PDU() {
}

void WaveEntitySecret_PDU::set_data(WaveEntitySecret & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveEntitySecret *WaveEntitySecret_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveEntitySecret *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveEntitySecret_PDU::set_const_data(const WaveEntitySecret & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveEntitySecret *WaveEntitySecret_PDU::get_const_data() const {
    return (const WaveEntitySecret *)data;
}

#endif

OssTypeIndex WaveEntitySecret_PDU::get_index() const {
    return 5;
}

EntityKeyring_PDU::EntityKeyring_PDU() {
}

void EntityKeyring_PDU::set_data(EntityKeyring & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EntityKeyring *EntityKeyring_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EntityKeyring *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EntityKeyring_PDU::set_const_data(const EntityKeyring & d) {
    data = (void *)&d;
    constant = 1;
}

const EntityKeyring *EntityKeyring_PDU::get_const_data() const {
    return (const EntityKeyring *)data;
}

#endif

OssTypeIndex EntityKeyring_PDU::get_index() const {
    return 6;
}

EntityKeyringEntry_PDU::EntityKeyringEntry_PDU() {
}

void EntityKeyringEntry_PDU::set_data(EntityKeyringEntry & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

EntityKeyringEntry *EntityKeyringEntry_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (EntityKeyringEntry *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void EntityKeyringEntry_PDU::set_const_data(const EntityKeyringEntry & d) {
    data = (void *)&d;
    constant = 1;
}

const EntityKeyringEntry *EntityKeyringEntry_PDU::get_const_data() const {
    return (const EntityKeyringEntry *)data;
}

#endif

OssTypeIndex EntityKeyringEntry_PDU::get_index() const {
    return 7;
}

WaveExplicitProof_PDU::WaveExplicitProof_PDU() {
}

void WaveExplicitProof_PDU::set_data(WaveExplicitProof & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WaveExplicitProof *WaveExplicitProof_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WaveExplicitProof *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WaveExplicitProof_PDU::set_const_data(const WaveExplicitProof & d) {
    data = (void *)&d;
    constant = 1;
}

const WaveExplicitProof *WaveExplicitProof_PDU::get_const_data() const {
    return (const WaveExplicitProof *)data;
}

#endif

OssTypeIndex WaveExplicitProof_PDU::get_index() const {
    return 8;
}

RTreePolicy_PDU::RTreePolicy_PDU() {
}

void RTreePolicy_PDU::set_data(RTreePolicy & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

RTreePolicy *RTreePolicy_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (RTreePolicy *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void RTreePolicy_PDU::set_const_data(const RTreePolicy & d) {
    data = (void *)&d;
    constant = 1;
}

const RTreePolicy *RTreePolicy_PDU::get_const_data() const {
    return (const RTreePolicy *)data;
}

#endif

OssTypeIndex RTreePolicy_PDU::get_index() const {
    return 9;
}

HashSha3_256_PDU::HashSha3_256_PDU() {
}

void HashSha3_256_PDU::set_data(HashSha3_256 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashSha3_256 *HashSha3_256_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HashSha3_256 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HashSha3_256_PDU::set_const_data(const HashSha3_256 & d) {
    data = (void *)&d;
    constant = 1;
}

const HashSha3_256 *HashSha3_256_PDU::get_const_data() const {
    return (const HashSha3_256 *)data;
}

#endif

OssTypeIndex HashSha3_256_PDU::get_index() const {
    return 10;
}

HashSha_256_PDU::HashSha_256_PDU() {
}

void HashSha_256_PDU::set_data(HashSha_256 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashSha_256 *HashSha_256_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HashSha_256 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HashSha_256_PDU::set_const_data(const HashSha_256 & d) {
    data = (void *)&d;
    constant = 1;
}

const HashSha_256 *HashSha_256_PDU::get_const_data() const {
    return (const HashSha_256 *)data;
}

#endif

OssTypeIndex HashSha_256_PDU::get_index() const {
    return 11;
}

HashKeccak_256_PDU::HashKeccak_256_PDU() {
}

void HashKeccak_256_PDU::set_data(HashKeccak_256 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

HashKeccak_256 *HashKeccak_256_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (HashKeccak_256 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void HashKeccak_256_PDU::set_const_data(const HashKeccak_256 & d) {
    data = (void *)&d;
    constant = 1;
}

const HashKeccak_256 *HashKeccak_256_PDU::get_const_data() const {
    return (const HashKeccak_256 *)data;
}

#endif

OssTypeIndex HashKeccak_256_PDU::get_index() const {
    return 12;
}

LocationURL_PDU::LocationURL_PDU() {
}

void LocationURL_PDU::set_data(LocationURL & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocationURL *LocationURL_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (LocationURL *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void LocationURL_PDU::set_const_data(const LocationURL & d) {
    data = (void *)&d;
    constant = 1;
}

const LocationURL *LocationURL_PDU::get_const_data() const {
    return (const LocationURL *)data;
}

#endif

OssTypeIndex LocationURL_PDU::get_index() const {
    return 13;
}

LocationEthereum_PDU::LocationEthereum_PDU() {
}

void LocationEthereum_PDU::set_data(LocationEthereum & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

LocationEthereum *LocationEthereum_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (LocationEthereum *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void LocationEthereum_PDU::set_const_data(const LocationEthereum & d) {
    data = (void *)&d;
    constant = 1;
}

const LocationEthereum *LocationEthereum_PDU::get_const_data() const {
    return (const LocationEthereum *)data;
}

#endif

OssTypeIndex LocationEthereum_PDU::get_index() const {
    return 14;
}

PSKBodyCiphertext_PDU::PSKBodyCiphertext_PDU() {
}

void PSKBodyCiphertext_PDU::set_data(PSKBodyCiphertext & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

PSKBodyCiphertext *PSKBodyCiphertext_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (PSKBodyCiphertext *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void PSKBodyCiphertext_PDU::set_const_data(const PSKBodyCiphertext & d) {
    data = (void *)&d;
    constant = 1;
}

const PSKBodyCiphertext *PSKBodyCiphertext_PDU::get_const_data() const {
    return (const PSKBodyCiphertext *)data;
}

#endif

OssTypeIndex PSKBodyCiphertext_PDU::get_index() const {
    return 15;
}

WR1BodyCiphertext_PDU::WR1BodyCiphertext_PDU() {
}

void WR1BodyCiphertext_PDU::set_data(WR1BodyCiphertext & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1BodyCiphertext *WR1BodyCiphertext_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WR1BodyCiphertext *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WR1BodyCiphertext_PDU::set_const_data(const WR1BodyCiphertext & d) {
    data = (void *)&d;
    constant = 1;
}

const WR1BodyCiphertext *WR1BodyCiphertext_PDU::get_const_data() const {
    return (const WR1BodyCiphertext *)data;
}

#endif

OssTypeIndex WR1BodyCiphertext_PDU::get_index() const {
    return 16;
}

WR1Envelope_PDU::WR1Envelope_PDU() {
}

void WR1Envelope_PDU::set_data(WR1Envelope & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1Envelope *WR1Envelope_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WR1Envelope *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WR1Envelope_PDU::set_const_data(const WR1Envelope & d) {
    data = (void *)&d;
    constant = 1;
}

const WR1Envelope *WR1Envelope_PDU::get_const_data() const {
    return (const WR1Envelope *)data;
}

#endif

OssTypeIndex WR1Envelope_PDU::get_index() const {
    return 17;
}

WR1ProverBody_PDU::WR1ProverBody_PDU() {
}

void WR1ProverBody_PDU::set_data(WR1ProverBody & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1ProverBody *WR1ProverBody_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WR1ProverBody *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WR1ProverBody_PDU::set_const_data(const WR1ProverBody & d) {
    data = (void *)&d;
    constant = 1;
}

const WR1ProverBody *WR1ProverBody_PDU::get_const_data() const {
    return (const WR1ProverBody *)data;
}

#endif

OssTypeIndex WR1ProverBody_PDU::get_index() const {
    return 18;
}

WR1VerifierBody_PDU::WR1VerifierBody_PDU() {
}

void WR1VerifierBody_PDU::set_data(WR1VerifierBody & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

WR1VerifierBody *WR1VerifierBody_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (WR1VerifierBody *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void WR1VerifierBody_PDU::set_const_data(const WR1VerifierBody & d) {
    data = (void *)&d;
    constant = 1;
}

const WR1VerifierBody *WR1VerifierBody_PDU::get_const_data() const {
    return (const WR1VerifierBody *)data;
}

#endif

OssTypeIndex WR1VerifierBody_PDU::get_index() const {
    return 19;
}

Ed25519OuterSignature_PDU::Ed25519OuterSignature_PDU() {
}

void Ed25519OuterSignature_PDU::set_data(Ed25519OuterSignature & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Ed25519OuterSignature *Ed25519OuterSignature_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Ed25519OuterSignature *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Ed25519OuterSignature_PDU::set_const_data(const Ed25519OuterSignature & d) {
    data = (void *)&d;
    constant = 1;
}

const Ed25519OuterSignature *Ed25519OuterSignature_PDU::get_const_data() const {
    return (const Ed25519OuterSignature *)data;
}

#endif

OssTypeIndex Ed25519OuterSignature_PDU::get_index() const {
    return 20;
}

SignedOuterKey_PDU::SignedOuterKey_PDU() {
}

void SignedOuterKey_PDU::set_data(SignedOuterKey & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

SignedOuterKey *SignedOuterKey_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (SignedOuterKey *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void SignedOuterKey_PDU::set_const_data(const SignedOuterKey & d) {
    data = (void *)&d;
    constant = 1;
}

const SignedOuterKey *SignedOuterKey_PDU::get_const_data() const {
    return (const SignedOuterKey *)data;
}

#endif

OssTypeIndex SignedOuterKey_PDU::get_index() const {
    return 21;
}

TrustLevel_PDU::TrustLevel_PDU() {
}

void TrustLevel_PDU::set_data(TrustLevel & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

TrustLevel *TrustLevel_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (TrustLevel *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void TrustLevel_PDU::set_const_data(const TrustLevel & d) {
    data = (void *)&d;
    constant = 1;
}

const TrustLevel *TrustLevel_PDU::get_const_data() const {
    return (const TrustLevel *)data;
}

#endif

OssTypeIndex TrustLevel_PDU::get_index() const {
    return 22;
}

CommitmentRevocationOption_PDU::CommitmentRevocationOption_PDU() {
}

void CommitmentRevocationOption_PDU::set_data(CommitmentRevocationOption & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

CommitmentRevocationOption *CommitmentRevocationOption_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (CommitmentRevocationOption *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void CommitmentRevocationOption_PDU::set_const_data(const CommitmentRevocationOption & d) {
    data = (void *)&d;
    constant = 1;
}

const CommitmentRevocationOption *CommitmentRevocationOption_PDU::get_const_data() const {
    return (const CommitmentRevocationOption *)data;
}

#endif

OssTypeIndex CommitmentRevocationOption_PDU::get_index() const {
    return 23;
}

AVKeyAES128_GCM_PDU::AVKeyAES128_GCM_PDU() {
}

void AVKeyAES128_GCM_PDU::set_data(AVKeyAES128_GCM & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AVKeyAES128_GCM *AVKeyAES128_GCM_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AVKeyAES128_GCM *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AVKeyAES128_GCM_PDU::set_const_data(const AVKeyAES128_GCM & d) {
    data = (void *)&d;
    constant = 1;
}

const AVKeyAES128_GCM *AVKeyAES128_GCM_PDU::get_const_data() const {
    return (const AVKeyAES128_GCM *)data;
}

#endif

OssTypeIndex AVKeyAES128_GCM_PDU::get_index() const {
    return 24;
}

Private_Ed25519_PDU::Private_Ed25519_PDU() {
}

void Private_Ed25519_PDU::set_data(Private_Ed25519 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_Ed25519 *Private_Ed25519_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Private_Ed25519 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Private_Ed25519_PDU::set_const_data(const Private_Ed25519 & d) {
    data = (void *)&d;
    constant = 1;
}

const Private_Ed25519 *Private_Ed25519_PDU::get_const_data() const {
    return (const Private_Ed25519 *)data;
}

#endif

OssTypeIndex Private_Ed25519_PDU::get_index() const {
    return 25;
}

Private_Curve25519_PDU::Private_Curve25519_PDU() {
}

void Private_Curve25519_PDU::set_data(Private_Curve25519 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_Curve25519 *Private_Curve25519_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Private_Curve25519 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Private_Curve25519_PDU::set_const_data(const Private_Curve25519 & d) {
    data = (void *)&d;
    constant = 1;
}

const Private_Curve25519 *Private_Curve25519_PDU::get_const_data() const {
    return (const Private_Curve25519 *)data;
}

#endif

OssTypeIndex Private_Curve25519_PDU::get_index() const {
    return 26;
}

Private_BN256_OAQUE_PDU::Private_BN256_OAQUE_PDU() {
}

void Private_BN256_OAQUE_PDU::set_data(Private_BN256_OAQUE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_BN256_OAQUE *Private_BN256_OAQUE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Private_BN256_OAQUE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Private_BN256_OAQUE_PDU::set_const_data(const Private_BN256_OAQUE & d) {
    data = (void *)&d;
    constant = 1;
}

const Private_BN256_OAQUE *Private_BN256_OAQUE_PDU::get_const_data() const {
    return (const Private_BN256_OAQUE *)data;
}

#endif

OssTypeIndex Private_BN256_OAQUE_PDU::get_index() const {
    return 27;
}

Private_BN256_IBE_PDU::Private_BN256_IBE_PDU() {
}

void Private_BN256_IBE_PDU::set_data(Private_BN256_IBE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Private_BN256_IBE *Private_BN256_IBE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Private_BN256_IBE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Private_BN256_IBE_PDU::set_const_data(const Private_BN256_IBE & d) {
    data = (void *)&d;
    constant = 1;
}

const Private_BN256_IBE *Private_BN256_IBE_PDU::get_const_data() const {
    return (const Private_BN256_IBE *)data;
}

#endif

OssTypeIndex Private_BN256_IBE_PDU::get_index() const {
    return 28;
}

Master_BN256_OAQUE_PDU::Master_BN256_OAQUE_PDU() {
}

void Master_BN256_OAQUE_PDU::set_data(Master_BN256_OAQUE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Master_BN256_OAQUE *Master_BN256_OAQUE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Master_BN256_OAQUE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Master_BN256_OAQUE_PDU::set_const_data(const Master_BN256_OAQUE & d) {
    data = (void *)&d;
    constant = 1;
}

const Master_BN256_OAQUE *Master_BN256_OAQUE_PDU::get_const_data() const {
    return (const Master_BN256_OAQUE *)data;
}

#endif

OssTypeIndex Master_BN256_OAQUE_PDU::get_index() const {
    return 29;
}

Master_BN256_IBE_PDU::Master_BN256_IBE_PDU() {
}

void Master_BN256_IBE_PDU::set_data(Master_BN256_IBE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Master_BN256_IBE *Master_BN256_IBE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Master_BN256_IBE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Master_BN256_IBE_PDU::set_const_data(const Master_BN256_IBE & d) {
    data = (void *)&d;
    constant = 1;
}

const Master_BN256_IBE *Master_BN256_IBE_PDU::get_const_data() const {
    return (const Master_BN256_IBE *)data;
}

#endif

OssTypeIndex Master_BN256_IBE_PDU::get_index() const {
    return 30;
}

Public_Ed25519_PDU::Public_Ed25519_PDU() {
}

void Public_Ed25519_PDU::set_data(Public_Ed25519 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_Ed25519 *Public_Ed25519_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Public_Ed25519 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Public_Ed25519_PDU::set_const_data(const Public_Ed25519 & d) {
    data = (void *)&d;
    constant = 1;
}

const Public_Ed25519 *Public_Ed25519_PDU::get_const_data() const {
    return (const Public_Ed25519 *)data;
}

#endif

OssTypeIndex Public_Ed25519_PDU::get_index() const {
    return 31;
}

Public_Curve25519_PDU::Public_Curve25519_PDU() {
}

void Public_Curve25519_PDU::set_data(Public_Curve25519 & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_Curve25519 *Public_Curve25519_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Public_Curve25519 *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Public_Curve25519_PDU::set_const_data(const Public_Curve25519 & d) {
    data = (void *)&d;
    constant = 1;
}

const Public_Curve25519 *Public_Curve25519_PDU::get_const_data() const {
    return (const Public_Curve25519 *)data;
}

#endif

OssTypeIndex Public_Curve25519_PDU::get_index() const {
    return 32;
}

Public_OAQUE_PDU::Public_OAQUE_PDU() {
}

void Public_OAQUE_PDU::set_data(Public_OAQUE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_OAQUE *Public_OAQUE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Public_OAQUE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Public_OAQUE_PDU::set_const_data(const Public_OAQUE & d) {
    data = (void *)&d;
    constant = 1;
}

const Public_OAQUE *Public_OAQUE_PDU::get_const_data() const {
    return (const Public_OAQUE *)data;
}

#endif

OssTypeIndex Public_OAQUE_PDU::get_index() const {
    return 33;
}

Params_BN256_OAQUE_PDU::Params_BN256_OAQUE_PDU() {
}

void Params_BN256_OAQUE_PDU::set_data(Params_BN256_OAQUE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Params_BN256_OAQUE *Params_BN256_OAQUE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Params_BN256_OAQUE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Params_BN256_OAQUE_PDU::set_const_data(const Params_BN256_OAQUE & d) {
    data = (void *)&d;
    constant = 1;
}

const Params_BN256_OAQUE *Params_BN256_OAQUE_PDU::get_const_data() const {
    return (const Params_BN256_OAQUE *)data;
}

#endif

OssTypeIndex Params_BN256_OAQUE_PDU::get_index() const {
    return 34;
}

Params_BN256_IBE_PDU::Params_BN256_IBE_PDU() {
}

void Params_BN256_IBE_PDU::set_data(Params_BN256_IBE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Params_BN256_IBE *Params_BN256_IBE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Params_BN256_IBE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Params_BN256_IBE_PDU::set_const_data(const Params_BN256_IBE & d) {
    data = (void *)&d;
    constant = 1;
}

const Params_BN256_IBE *Params_BN256_IBE_PDU::get_const_data() const {
    return (const Params_BN256_IBE *)data;
}

#endif

OssTypeIndex Params_BN256_IBE_PDU::get_index() const {
    return 35;
}

Public_BN256_IBE_PDU::Public_BN256_IBE_PDU() {
}

void Public_BN256_IBE_PDU::set_data(Public_BN256_IBE & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

Public_BN256_IBE *Public_BN256_IBE_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (Public_BN256_IBE *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void Public_BN256_IBE_PDU::set_const_data(const Public_BN256_IBE & d) {
    data = (void *)&d;
    constant = 1;
}

const Public_BN256_IBE *Public_BN256_IBE_PDU::get_const_data() const {
    return (const Public_BN256_IBE *)data;
}

#endif

OssTypeIndex Public_BN256_IBE_PDU::get_index() const {
    return 36;
}

KeyringAESCiphertext_PDU::KeyringAESCiphertext_PDU() {
}

void KeyringAESCiphertext_PDU::set_data(KeyringAESCiphertext & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

KeyringAESCiphertext *KeyringAESCiphertext_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (KeyringAESCiphertext *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void KeyringAESCiphertext_PDU::set_const_data(const KeyringAESCiphertext & d) {
    data = (void *)&d;
    constant = 1;
}

const KeyringAESCiphertext *KeyringAESCiphertext_PDU::get_const_data() const {
    return (const KeyringAESCiphertext *)data;
}

#endif

OssTypeIndex KeyringAESCiphertext_PDU::get_index() const {
    return 37;
}

/* Control object class */

objects_Control::objects_Control() : OssControl(&objects_Table, objects_TableType::internal) {
}

objects_Control::objects_Control(const objects_Control & that) : OssControl(that) {
}


/* ASN.1 data initialization */
static unsigned char _v1[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55 };
static OSSC::COssEncOID _v0 = {
    8,
    _v1
};

const OssEncOID& wave_id = (const OssEncOID&)_v0;

static unsigned char _v3[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02 };
static OSSC::COssEncOID _v2 = {
    9,
    _v3
};

const OssEncOID& wave_object = (const OssEncOID&)_v2;

static unsigned char _v5[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x01 };
static OSSC::COssEncOID _v4 = {
    10,
    _v5
};

const OssEncOID& attestation_id = (const OssEncOID&)_v4;

static unsigned char _v7[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x02 };
static OSSC::COssEncOID _v6 = {
    10,
    _v7
};

const OssEncOID& entity_id = (const OssEncOID&)_v6;

static unsigned char _v9[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x03 };
static OSSC::COssEncOID _v8 = {
    10,
    _v9
};

const OssEncOID& explicit_proof_id = (const OssEncOID&)_v8;

static unsigned char _v11[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x04 };
static OSSC::COssEncOID _v10 = {
    10,
    _v11
};

const OssEncOID& entity_secret_id = (const OssEncOID&)_v10;

static unsigned char _v13[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03 };
static OSSC::COssEncOID _v12 = {
    9,
    _v13
};

const OssEncOID& attestation_body_scheme = (const OssEncOID&)_v12;

static unsigned char _v15[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x01 };
static OSSC::COssEncOID _v14 = {
    10,
    _v15
};

const OssEncOID& unencrypted_body_scheme = (const OssEncOID&)_v14;

static unsigned char _v17[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x02 };
static OSSC::COssEncOID _v16 = {
    10,
    _v17
};

const OssEncOID& wr1_body_scheme_v1 = (const OssEncOID&)_v16;

static unsigned char _v19[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x03 };
static OSSC::COssEncOID _v18 = {
    10,
    _v19
};

const OssEncOID& psk_body_scheme = (const OssEncOID&)_v18;

static unsigned char _v21[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x04 };
static OSSC::COssEncOID _v20 = {
    9,
    _v21
};

const OssEncOID& attestation_verifier_key_scheme = (const OssEncOID&)_v20;

static unsigned char _v23[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x04, 0x01 };
static OSSC::COssEncOID _v22 = {
    10,
    _v23
};

const OssEncOID& attestation_verifier_key_aes128_gcm = (const OssEncOID&)_v22;

static unsigned char _v25[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x05 };
static OSSC::COssEncOID _v24 = {
    9,
    _v25
};

const OssEncOID& outer_signature_scheme = (const OssEncOID&)_v24;

static unsigned char _v27[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x05, 0x01 };
static OSSC::COssEncOID _v26 = {
    10,
    _v27
};

const OssEncOID& ephemeral_ed25519 = (const OssEncOID&)_v26;

static unsigned char _v29[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x06 };
static OSSC::COssEncOID _v28 = {
    9,
    _v29
};

const OssEncOID& outer_signature_binding_scheme = (const OssEncOID&)_v28;

static unsigned char _v31[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x06, 0x01 };
static OSSC::COssEncOID _v30 = {
    10,
    _v31
};

const OssEncOID& signed_outer_key = (const OssEncOID&)_v30;

static unsigned char _v33[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x07 };
static OSSC::COssEncOID _v32 = {
    9,
    _v33
};

const OssEncOID& revocation_check_schemes = (const OssEncOID&)_v32;

static unsigned char _v35[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x08 };
static OSSC::COssEncOID _v34 = {
    9,
    _v35
};

const OssEncOID& location_scheme = (const OssEncOID&)_v34;

static unsigned char _v37[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x08, 0x01 };
static OSSC::COssEncOID _v36 = {
    10,
    _v37
};

const OssEncOID& location_url_id = (const OssEncOID&)_v36;

static unsigned char _v39[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x08, 0x02 };
static OSSC::COssEncOID _v38 = {
    10,
    _v39
};

const OssEncOID& location_ethereum_v1_id = (const OssEncOID&)_v38;

static unsigned char _v41[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09 };
static OSSC::COssEncOID _v40 = {
    9,
    _v41
};

const OssEncOID& hash_scheme = (const OssEncOID&)_v40;

static unsigned char _v43[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x01 };
static OSSC::COssEncOID _v42 = {
    10,
    _v43
};

const OssEncOID& sha3_256_id = (const OssEncOID&)_v42;

static unsigned char _v45[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x02 };
static OSSC::COssEncOID _v44 = {
    10,
    _v45
};

const OssEncOID& keccak_256_id = (const OssEncOID&)_v44;

static unsigned char _v47[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x03 };
static OSSC::COssEncOID _v46 = {
    10,
    _v47
};

const OssEncOID& sha_256_id = (const OssEncOID&)_v46;

static unsigned char _v49[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0A };
static OSSC::COssEncOID _v48 = {
    9,
    _v49
};

const OssEncOID& revocation_scheme = (const OssEncOID&)_v48;

static unsigned char _v51[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0A, 0x01 };
static OSSC::COssEncOID _v50 = {
    10,
    _v51
};

const OssEncOID& commitment_revocation_id = (const OssEncOID&)_v50;

static unsigned char _v53[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B };
static OSSC::COssEncOID _v52 = {
    9,
    _v53
};

const OssEncOID& entity_key_scheme = (const OssEncOID&)_v52;

static unsigned char _v55[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x01 };
static OSSC::COssEncOID _v54 = {
    10,
    _v55
};

const OssEncOID& ed25519_id = (const OssEncOID&)_v54;

static unsigned char _v57[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x02 };
static OSSC::COssEncOID _v56 = {
    10,
    _v57
};

const OssEncOID& curve25519_id = (const OssEncOID&)_v56;

static unsigned char _v59[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x03 };
static OSSC::COssEncOID _v58 = {
    10,
    _v59
};

const OssEncOID& oaque_bn256_s20_attributeset_id = (const OssEncOID&)_v58;

static unsigned char _v61[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x04 };
static OSSC::COssEncOID _v60 = {
    10,
    _v61
};

const OssEncOID& oaque_bn256_s20_params_id = (const OssEncOID&)_v60;

static unsigned char _v63[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x05 };
static OSSC::COssEncOID _v62 = {
    10,
    _v63
};

const OssEncOID& ibe_bn256_params_id = (const OssEncOID&)_v62;

static unsigned char _v65[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x06 };
static OSSC::COssEncOID _v64 = {
    10,
    _v65
};

const OssEncOID& ibe_bn256_public_id = (const OssEncOID&)_v64;

static unsigned char _v67[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0C };
static OSSC::COssEncOID _v66 = {
    9,
    _v67
};

const OssEncOID& policy_scheme = (const OssEncOID&)_v66;

static unsigned char _v69[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0C, 0x01 };
static OSSC::COssEncOID _v68 = {
    10,
    _v69
};

const OssEncOID& trust_level = (const OssEncOID&)_v68;

static unsigned char _v71[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0C, 0x02 };
static OSSC::COssEncOID _v70 = {
    10,
    _v71
};

const OssEncOID& resource_tree = (const OssEncOID&)_v70;

static unsigned char _v73[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D };
static OSSC::COssEncOID _v72 = {
    9,
    _v73
};

const OssEncOID& policy_addendum_scheme = (const OssEncOID&)_v72;

static unsigned char _v75[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x01 };
static OSSC::COssEncOID _v74 = {
    10,
    _v75
};

const OssEncOID& wr1_domain_visibility_key = (const OssEncOID&)_v74;

static unsigned char _v77[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x02 };
static OSSC::COssEncOID _v76 = {
    10,
    _v77
};

const OssEncOID& wr1_partition_key = (const OssEncOID&)_v76;

static unsigned char _v79[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x03 };
static OSSC::COssEncOID _v78 = {
    10,
    _v79
};

const OssEncOID& wr1_oaque_encryption_key = (const OssEncOID&)_v78;

static unsigned char _v81[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E };
static OSSC::COssEncOID _v80 = {
    9,
    _v81
};

const OssEncOID& entity_secret_key_scheme = (const OssEncOID&)_v80;

static unsigned char _v83[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x01 };
static OSSC::COssEncOID _v82 = {
    10,
    _v83
};

const OssEncOID& ed25519_secret_id = (const OssEncOID&)_v82;

static unsigned char _v85[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x02 };
static OSSC::COssEncOID _v84 = {
    10,
    _v85
};

const OssEncOID& curve25519_secret_id = (const OssEncOID&)_v84;

static unsigned char _v87[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x03 };
static OSSC::COssEncOID _v86 = {
    10,
    _v87
};

const OssEncOID& oaque_bn256_s20_private_key_id = (const OssEncOID&)_v86;

static unsigned char _v89[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x04 };
static OSSC::COssEncOID _v88 = {
    10,
    _v89
};

const OssEncOID& oaque_bn256_s20_master_key_id = (const OssEncOID&)_v88;

static unsigned char _v91[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x05 };
static OSSC::COssEncOID _v90 = {
    10,
    _v91
};

const OssEncOID& bn256_ibe_master_key_id = (const OssEncOID&)_v90;

static unsigned char _v93[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x06 };
static OSSC::COssEncOID _v92 = {
    10,
    _v93
};

const OssEncOID& bn256_ibe_private_key_id = (const OssEncOID&)_v92;

static unsigned char _v95[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0F };
static OSSC::COssEncOID _v94 = {
    9,
    _v95
};

const OssEncOID& entity_keyring_scheme = (const OssEncOID&)_v94;

static unsigned char _v97[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0F, 0x01 };
static OSSC::COssEncOID _v96 = {
    10,
    _v97
};

const OssEncOID& plaintext_keyring_id = (const OssEncOID&)_v96;

static unsigned char _v99[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0F, 0x02 };
static OSSC::COssEncOID _v98 = {
    10,
    _v99
};

const OssEncOID& aes128_gcm_pbkdf2 = (const OssEncOID&)_v98;


struct _TYPE_IDENTIFIER {
    OSSC::COssEncOID id;
    unsigned short Type;
};
static unsigned char _v101[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x01 };
static _TYPE_IDENTIFIER _v100 = {
    {
        10,
        _v101
    },
    2
};

static unsigned char _v103[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x02 };
static _TYPE_IDENTIFIER _v102 = {
    {
        10,
        _v103
    },
    4
};

static unsigned char _v105[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x03 };
static _TYPE_IDENTIFIER _v104 = {
    {
        10,
        _v105
    },
    8
};

static unsigned char _v107[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x02, 0x04 };
static _TYPE_IDENTIFIER _v106 = {
    {
        10,
        _v107
    },
    5
};

static unsigned char _v109[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x01 };
static _TYPE_IDENTIFIER _v108 = {
    {
        10,
        _v109
    },
    3
};

static unsigned char _v111[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x02 };
static _TYPE_IDENTIFIER _v110 = {
    {
        10,
        _v111
    },
    16
};

static unsigned char _v113[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x03, 0x03 };
static _TYPE_IDENTIFIER _v112 = {
    {
        10,
        _v113
    },
    15
};

static unsigned char _v115[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x04, 0x01 };
static _TYPE_IDENTIFIER _v114 = {
    {
        10,
        _v115
    },
    24
};

static unsigned char _v117[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x05, 0x01 };
static _TYPE_IDENTIFIER _v116 = {
    {
        10,
        _v117
    },
    20
};

static unsigned char _v119[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x06, 0x01 };
static _TYPE_IDENTIFIER _v118 = {
    {
        10,
        _v119
    },
    21
};

static unsigned char _v121[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x08, 0x01 };
static _TYPE_IDENTIFIER _v120 = {
    {
        10,
        _v121
    },
    13
};

static unsigned char _v123[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x08, 0x02 };
static _TYPE_IDENTIFIER _v122 = {
    {
        10,
        _v123
    },
    14
};

static unsigned char _v125[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x01 };
static _TYPE_IDENTIFIER _v124 = {
    {
        10,
        _v125
    },
    10
};

static unsigned char _v127[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x02 };
static _TYPE_IDENTIFIER _v126 = {
    {
        10,
        _v127
    },
    12
};

static unsigned char _v129[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x09, 0x03 };
static _TYPE_IDENTIFIER _v128 = {
    {
        10,
        _v129
    },
    11
};

static unsigned char _v131[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0A, 0x01 };
static _TYPE_IDENTIFIER _v130 = {
    {
        10,
        _v131
    },
    23
};

static unsigned char _v133[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x01 };
static _TYPE_IDENTIFIER _v132 = {
    {
        10,
        _v133
    },
    31
};

static unsigned char _v135[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x02 };
static _TYPE_IDENTIFIER _v134 = {
    {
        10,
        _v135
    },
    32
};

static unsigned char _v137[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x03 };
static _TYPE_IDENTIFIER _v136 = {
    {
        10,
        _v137
    },
    33
};

static unsigned char _v139[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x04 };
static _TYPE_IDENTIFIER _v138 = {
    {
        10,
        _v139
    },
    34
};

static unsigned char _v141[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x05 };
static _TYPE_IDENTIFIER _v140 = {
    {
        10,
        _v141
    },
    35
};

static unsigned char _v143[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0B, 0x06 };
static _TYPE_IDENTIFIER _v142 = {
    {
        10,
        _v143
    },
    36
};

static unsigned char _v145[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0C, 0x01 };
static _TYPE_IDENTIFIER _v144 = {
    {
        10,
        _v145
    },
    22
};

static unsigned char _v147[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0C, 0x02 };
static _TYPE_IDENTIFIER _v146 = {
    {
        10,
        _v147
    },
    9
};

static unsigned char _v149[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x01 };
static _TYPE_IDENTIFIER _v148 = {
    {
        10,
        _v149
    },
    7
};

static unsigned char _v151[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x02 };
static _TYPE_IDENTIFIER _v150 = {
    {
        10,
        _v151
    },
    7
};

static unsigned char _v153[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0D, 0x03 };
static _TYPE_IDENTIFIER _v152 = {
    {
        10,
        _v153
    },
    7
};

static unsigned char _v155[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x01 };
static _TYPE_IDENTIFIER _v154 = {
    {
        10,
        _v155
    },
    25
};

static unsigned char _v157[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x02 };
static _TYPE_IDENTIFIER _v156 = {
    {
        10,
        _v157
    },
    26
};

static unsigned char _v159[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x03 };
static _TYPE_IDENTIFIER _v158 = {
    {
        10,
        _v159
    },
    27
};

static unsigned char _v161[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x04 };
static _TYPE_IDENTIFIER _v160 = {
    {
        10,
        _v161
    },
    29
};

static unsigned char _v163[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x05 };
static _TYPE_IDENTIFIER _v162 = {
    {
        10,
        _v163
    },
    30
};

static unsigned char _v165[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0E, 0x06 };
static _TYPE_IDENTIFIER _v164 = {
    {
        10,
        _v165
    },
    28
};

static unsigned char _v167[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0F, 0x01 };
static _TYPE_IDENTIFIER _v166 = {
    {
        10,
        _v167
    },
    6
};

static unsigned char _v169[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x8F, 0x55, 0x0F, 0x02 };
static _TYPE_IDENTIFIER _v168 = {
    {
        10,
        _v169
    },
    37
};


#if !defined(OSS_SPARTAN_AWARE) || ((OSS_SPARTAN_AWARE + 0) < 2)
static ObjectSetEntry WaveObjects[] = {
    {&WaveObjects[1], (void*)&_v100},
    {&WaveObjects[2], &_v102},
    {&WaveObjects[3], &_v104},
    {NULL, (void*)&_v106}
};

static ObjectSetEntry AttestationBodySchemes[] = {
    {&AttestationBodySchemes[1], (void*)&_v108},
    {&AttestationBodySchemes[2], &_v110},
    {NULL, (void*)&_v112}
};

static ObjectSetEntry AttestationVerifierKeySchemes[] = {
    {NULL, (void*)&_v114}
};

static ObjectSetEntry OuterSignatureSchemes[] = {
    {NULL, (void*)&_v116}
};

static ObjectSetEntry OuterSignatureBindingSchemes[] = {
    {NULL, (void*)&_v118}
};

static ObjectSetEntry RevocationCheckSchemes[] = {
{NULL, NULL}};

static ObjectSetEntry LocationSchemes[] = {
    {&LocationSchemes[1], (void*)&_v120},
    {NULL, (void*)&_v122}
};

static ObjectSetEntry HashSchemes[] = {
    {&HashSchemes[1], (void*)&_v124},
    {&HashSchemes[2], &_v126},
    {NULL, (void*)&_v128}
};

static ObjectSetEntry RevocationSchemes[] = {
    {NULL, (void*)&_v130}
};

static ObjectSetEntry EntityKeySchemes[] = {
    {&EntityKeySchemes[1], (void*)&_v132},
    {&EntityKeySchemes[2], &_v134},
    {&EntityKeySchemes[3], &_v136},
    {&EntityKeySchemes[4], &_v138},
    {&EntityKeySchemes[5], &_v140},
    {NULL, (void*)&_v142}
};

static ObjectSetEntry PolicySchemes[] = {
    {&PolicySchemes[1], (void*)&_v144},
    {NULL, (void*)&_v146}
};

static ObjectSetEntry PolicyAddendumSchemes[] = {
    {&PolicyAddendumSchemes[1], (void*)&_v148},
    {&PolicyAddendumSchemes[2], &_v150},
    {NULL, (void*)&_v152}
};

static ObjectSetEntry EntitySecretKeySchemes[] = {
    {&EntitySecretKeySchemes[1], (void*)&_v154},
    {&EntitySecretKeySchemes[2], &_v156},
    {&EntitySecretKeySchemes[3], &_v158},
    {&EntitySecretKeySchemes[4], &_v160},
    {&EntitySecretKeySchemes[5], &_v162},
    {NULL, (void*)&_v164}
};

static ObjectSetEntry EntityKeyringSchemes[] = {
    {&EntityKeyringSchemes[1], (void*)&_v166},
    {NULL, (void*)&_v168}
};

#else /* OSS_SPARTAN_AWARE >= 2 */

#if ((OSS_SPARTAN_AWARE + 0) > 12)
static ObjectSetEntry const WaveObjects[] = {
    {(ObjectSetEntry *)&WaveObjects[1], &_v100, NULL, NULL},
    {(ObjectSetEntry *)&WaveObjects[2], &_v102, (ObjectSetEntry *)&WaveObjects[0], NULL},
    {(ObjectSetEntry *)&WaveObjects[3], &_v104, (ObjectSetEntry *)&WaveObjects[1], NULL},
    {NULL, &_v106, (ObjectSetEntry *)&WaveObjects[2], NULL}
};
static ObjectSetEntry const AttestationBodySchemes[] = {
    {(ObjectSetEntry *)&AttestationBodySchemes[1], &_v108, NULL, NULL},
    {(ObjectSetEntry *)&AttestationBodySchemes[2], &_v110, (ObjectSetEntry *)&AttestationBodySchemes[0], NULL},
    {NULL, &_v112, (ObjectSetEntry *)&AttestationBodySchemes[1], NULL}
};
static ObjectSetEntry const AttestationVerifierKeySchemes[] = {
    {NULL, &_v114, NULL, NULL}
};
static ObjectSetEntry const OuterSignatureSchemes[] = {
    {NULL, &_v116, NULL, NULL}
};
static ObjectSetEntry const OuterSignatureBindingSchemes[] = {
    {NULL, &_v118, NULL, NULL}
};
static ObjectSetEntry const RevocationCheckSchemes[] = {
{NULL, NULL, NULL, NULL}};
static ObjectSetEntry const LocationSchemes[] = {
    {(ObjectSetEntry *)&LocationSchemes[1], &_v120, NULL, NULL},
    {NULL, &_v122, (ObjectSetEntry *)&LocationSchemes[0], NULL}
};
static ObjectSetEntry const HashSchemes[] = {
    {(ObjectSetEntry *)&HashSchemes[1], &_v124, NULL, NULL},
    {(ObjectSetEntry *)&HashSchemes[2], &_v126, (ObjectSetEntry *)&HashSchemes[0], NULL},
    {NULL, &_v128, (ObjectSetEntry *)&HashSchemes[1], NULL}
};
static ObjectSetEntry const RevocationSchemes[] = {
    {NULL, &_v130, NULL, NULL}
};
static ObjectSetEntry const EntityKeySchemes[] = {
    {(ObjectSetEntry *)&EntityKeySchemes[1], &_v132, NULL, NULL},
    {(ObjectSetEntry *)&EntityKeySchemes[2], &_v134, (ObjectSetEntry *)&EntityKeySchemes[0], NULL},
    {(ObjectSetEntry *)&EntityKeySchemes[3], &_v136, (ObjectSetEntry *)&EntityKeySchemes[1], NULL},
    {(ObjectSetEntry *)&EntityKeySchemes[4], &_v138, (ObjectSetEntry *)&EntityKeySchemes[2], NULL},
    {(ObjectSetEntry *)&EntityKeySchemes[5], &_v140, (ObjectSetEntry *)&EntityKeySchemes[3], NULL},
    {NULL, &_v142, (ObjectSetEntry *)&EntityKeySchemes[4], NULL}
};
static ObjectSetEntry const PolicySchemes[] = {
    {(ObjectSetEntry *)&PolicySchemes[1], &_v144, NULL, NULL},
    {NULL, &_v146, (ObjectSetEntry *)&PolicySchemes[0], NULL}
};
static ObjectSetEntry const PolicyAddendumSchemes[] = {
    {(ObjectSetEntry *)&PolicyAddendumSchemes[1], &_v148, NULL, NULL},
    {(ObjectSetEntry *)&PolicyAddendumSchemes[2], &_v150, (ObjectSetEntry *)&PolicyAddendumSchemes[0], NULL},
    {NULL, &_v152, (ObjectSetEntry *)&PolicyAddendumSchemes[1], NULL}
};
static ObjectSetEntry const EntitySecretKeySchemes[] = {
    {(ObjectSetEntry *)&EntitySecretKeySchemes[1], &_v154, NULL, NULL},
    {(ObjectSetEntry *)&EntitySecretKeySchemes[2], &_v156, (ObjectSetEntry *)&EntitySecretKeySchemes[0], NULL},
    {(ObjectSetEntry *)&EntitySecretKeySchemes[3], &_v158, (ObjectSetEntry *)&EntitySecretKeySchemes[1], NULL},
    {(ObjectSetEntry *)&EntitySecretKeySchemes[4], &_v160, (ObjectSetEntry *)&EntitySecretKeySchemes[2], NULL},
    {(ObjectSetEntry *)&EntitySecretKeySchemes[5], &_v162, (ObjectSetEntry *)&EntitySecretKeySchemes[3], NULL},
    {NULL, &_v164, (ObjectSetEntry *)&EntitySecretKeySchemes[4], NULL}
};
static ObjectSetEntry const EntityKeyringSchemes[] = {
    {(ObjectSetEntry *)&EntityKeyringSchemes[1], &_v166, NULL, NULL},
    {NULL, &_v168, (ObjectSetEntry *)&EntityKeyringSchemes[0], NULL}
};
#else /* OSS_SPARTAN_AWARE <= 12 */
static ObjectSetEntry const WaveObjects[] = {
    {(ObjectSetEntry *)&WaveObjects[1], &_v100, NULL},
    {(ObjectSetEntry *)&WaveObjects[2], &_v102, (ObjectSetEntry *)&WaveObjects[0]},
    {(ObjectSetEntry *)&WaveObjects[3], &_v104, (ObjectSetEntry *)&WaveObjects[1]},
    {NULL, &_v106, (ObjectSetEntry *)&WaveObjects[2]}
};
static ObjectSetEntry const AttestationBodySchemes[] = {
    {(ObjectSetEntry *)&AttestationBodySchemes[1], &_v108, NULL},
    {(ObjectSetEntry *)&AttestationBodySchemes[2], &_v110, (ObjectSetEntry *)&AttestationBodySchemes[0]},
    {NULL, &_v112, (ObjectSetEntry *)&AttestationBodySchemes[1]}
};
static ObjectSetEntry const AttestationVerifierKeySchemes[] = {
    {NULL, &_v114, NULL}
};
static ObjectSetEntry const OuterSignatureSchemes[] = {
    {NULL, &_v116, NULL}
};
static ObjectSetEntry const OuterSignatureBindingSchemes[] = {
    {NULL, &_v118, NULL}
};
static ObjectSetEntry const RevocationCheckSchemes[] = {
{NULL, NULL, NULL}};
static ObjectSetEntry const LocationSchemes[] = {
    {(ObjectSetEntry *)&LocationSchemes[1], &_v120, NULL},
    {NULL, &_v122, (ObjectSetEntry *)&LocationSchemes[0]}
};
static ObjectSetEntry const HashSchemes[] = {
    {(ObjectSetEntry *)&HashSchemes[1], &_v124, NULL},
    {(ObjectSetEntry *)&HashSchemes[2], &_v126, (ObjectSetEntry *)&HashSchemes[0]},
    {NULL, &_v128, (ObjectSetEntry *)&HashSchemes[1]}
};
static ObjectSetEntry const RevocationSchemes[] = {
    {NULL, &_v130, NULL}
};
static ObjectSetEntry const EntityKeySchemes[] = {
    {(ObjectSetEntry *)&EntityKeySchemes[1], &_v132, NULL},
    {(ObjectSetEntry *)&EntityKeySchemes[2], &_v134, (ObjectSetEntry *)&EntityKeySchemes[0]},
    {(ObjectSetEntry *)&EntityKeySchemes[3], &_v136, (ObjectSetEntry *)&EntityKeySchemes[1]},
    {(ObjectSetEntry *)&EntityKeySchemes[4], &_v138, (ObjectSetEntry *)&EntityKeySchemes[2]},
    {(ObjectSetEntry *)&EntityKeySchemes[5], &_v140, (ObjectSetEntry *)&EntityKeySchemes[3]},
    {NULL, &_v142, (ObjectSetEntry *)&EntityKeySchemes[4]}
};
static ObjectSetEntry const PolicySchemes[] = {
    {(ObjectSetEntry *)&PolicySchemes[1], &_v144, NULL},
    {NULL, &_v146, (ObjectSetEntry *)&PolicySchemes[0]}
};
static ObjectSetEntry const PolicyAddendumSchemes[] = {
    {(ObjectSetEntry *)&PolicyAddendumSchemes[1], &_v148, NULL},
    {(ObjectSetEntry *)&PolicyAddendumSchemes[2], &_v150, (ObjectSetEntry *)&PolicyAddendumSchemes[0]},
    {NULL, &_v152, (ObjectSetEntry *)&PolicyAddendumSchemes[1]}
};
static ObjectSetEntry const EntitySecretKeySchemes[] = {
    {(ObjectSetEntry *)&EntitySecretKeySchemes[1], &_v154, NULL},
    {(ObjectSetEntry *)&EntitySecretKeySchemes[2], &_v156, (ObjectSetEntry *)&EntitySecretKeySchemes[0]},
    {(ObjectSetEntry *)&EntitySecretKeySchemes[3], &_v158, (ObjectSetEntry *)&EntitySecretKeySchemes[1]},
    {(ObjectSetEntry *)&EntitySecretKeySchemes[4], &_v160, (ObjectSetEntry *)&EntitySecretKeySchemes[2]},
    {(ObjectSetEntry *)&EntitySecretKeySchemes[5], &_v162, (ObjectSetEntry *)&EntitySecretKeySchemes[3]},
    {NULL, &_v164, (ObjectSetEntry *)&EntitySecretKeySchemes[4]}
};
static ObjectSetEntry const EntityKeyringSchemes[] = {
    {(ObjectSetEntry *)&EntityKeyringSchemes[1], &_v166, NULL},
    {NULL, &_v168, (ObjectSetEntry *)&EntityKeyringSchemes[0]}
};
#endif /* (OSS_SPARTAN_AWARE + 0) > 12 */

static unsigned short const _oss_OSet_info[] =  {
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
};
#endif /* !OSS_SPARTAN_AWARE || OSS_SPARTAN_AWARE < 2 */

/* Local control table initialization */
#ifdef OSS_SPARTAN_AWARE
#if ((OSS_SPARTAN_AWARE + 0) >= 3)
extern "C" void _oss_run_SOED_on_AMD64_LINUX_64_BIT(void);
static void _oss_post_init(struct ossGlobal *world);
#endif /* OSS_SPARTAN_AWARE >= 3 */
#endif /* OSS_SPARTAN_AWARE */

#ifdef OSS_SPARTAN_AWARE
#if ((OSS_SPARTAN_AWARE + 0) >= 12)
static unsigned char _privateFlags[] = {0x08,0x00,0x00};
#endif /* OSS_SPARTAN_AWARE >= 12 */
#endif /* OSS_SPARTAN_AWARE */

extern "C" void _ossinit_objects(struct ossGlobal *world) {
#ifdef OSS_SPARTAN_AWARE
#if ((OSS_SPARTAN_AWARE + 0) >= 3)
    _oss_run_SOED_on_AMD64_LINUX_64_BIT();
#endif /* OSS_SPARTAN_AWARE >= 3 */
#endif /* OSS_SPARTAN_AWARE */
#ifdef OSS_SPARTAN_AWARE
#if ((OSS_SPARTAN_AWARE + 0) >= 12)
    ossPrivateSetMoreFlags(world, 17, _privateFlags);
#endif /* OSS_SPARTAN_AWARE >= 12 */
#endif /* OSS_SPARTAN_AWARE */
    ossLinkBer(world);
    ossLinkDer(world);
#if !defined(OSS_SPARTAN_AWARE) || ((OSS_SPARTAN_AWARE + 0) < 8)
    ossLinkConstraint(world);
#else  /* OSS_SPARTAN_AWARE < 8 */
    ossLinkConstraintSpartanAware8(world);
#endif /* OSS_SPARTAN_AWARE < 8 */
#ifdef OSS_SPARTAN_AWARE
    ossLinkCmpValue(world);
#if ((OSS_SPARTAN_AWARE + 0) >= 2)
    ossInitObjectSetInfo(world, (unsigned short *)_oss_OSet_info);
#endif /* OSS_SPARTAN_AWARE >= 2 */
#endif /* OSS_SPARTAN_AWARE */

#ifdef OSS_SPARTAN_AWARE
#if ((OSS_SPARTAN_AWARE + 0) >= 3)
    _oss_post_init(world);
#endif /* OSS_SPARTAN_AWARE >= 3 */
#endif /* OSS_SPARTAN_AWARE */
}


static int const _v172[6] = {
  1, 2, 3, 4, 5, 6
};
static unsigned short const _v171[2] = {1, 4};

static const unsigned short _pduarray[] = {
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
    11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
    21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
    31, 32, 33, 34, 35, 36, 37, 0
};

static const struct etype _etypearray[] = {
    {-1, 0, 0, NULL, 0, 0, 0, 0, 0, 0, 0, 0},
    {-1, 1, 3, (char *)"WaveWireObject", 48, 2, 0, 0, 264, 0, 12, 0},
    {-1, 11, 13, (char *)"WaveAttestation", 208, 2, 0, 0, 264, 2, 12, 0},
    {-1, 11, 21, (char *)"AttestationBody", 232, 3, 0, 0, 8, 4, 12, 0},
    {-1, 11, 33, (char *)"WaveEntity", 112, 2, 0, 0, 8, 7, 12, 0},
    {-1, 11, 13, (char *)"WaveEntitySecret", 160, 2, 0, 0, 264, 9, 12, 0},
    {-1, 11, 41, (char *)"EntityKeyring", 8, 1, 0, 0, 8, 11, 12, 0},
    {-1, 11, 13, (char *)"EntityKeyringEntry", 104, 2, 0, 0, 8, 12, 12, 0},
    {-1, 11, 45, (char *)"WaveExplicitProof", 32, 4, 0, 0, 8, 14, 12, 0},
    {-1, 11, 61, (char *)"RTreePolicy", 64, 3, 0, 0, 8, 18, 12, 0},
    {-1, 73, 0, (char *)"HashSha3-256", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"HashSha-256", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"HashKeccak-256", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 11, 75, (char *)"LocationURL", 24, 2, 0, 0, 8, 21, 12, 0},
    {-1, 11, 83, (char *)"LocationEthereum", 8, 2, 0, 0, 8, 23, 12, 0},
    {-1, 11, 91, (char *)"PSKBodyCiphertext", 72, 2, 0, 0, 8, 25, 12, 0},
    {-1, 11, 99, (char *)"WR1BodyCiphertext", 80, 5, 0, 0, 8, 27, 12, 0},
    {-1, 11, 91, (char *)"WR1Envelope", 24, 2, 0, 0, 8, 32, 12, 0},
    {-1, 11, 119, (char *)"WR1ProverBody", 16, 2, 0, 0, 8, 34, 12, 0},
    {-1, 11, 41, (char *)"WR1VerifierBody", 216, 1, 0, 0, 8, 36, 12, 0},
    {-1, 11, 127, (char *)"Ed25519OuterSignature", 32, 2, 0, 0, 8, 37, 12, 0},
    {-1, 11, 33, (char *)"SignedOuterKey", 48, 2, 0, 0, 8, 39, 12, 0},
    {-1, 11, 135, (char *)"TrustLevel", 2, 1, 0, 0, 8, 41, 12, 0},
    {-1, 11, 139, (char *)"CommitmentRevocationOption", 96, 2, 0, 0, 8, 42, 12, 0},
    {-1, 73, 0, (char *)"AVKeyAES128-GCM", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Private-Ed25519", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Private-Curve25519", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Private-BN256-OAQUE", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Private-BN256-IBE", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Master-BN256-OAQUE", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Master-BN256-IBE", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Public-Ed25519", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Public-Curve25519", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 11, 91, (char *)"Public-OAQUE", 24, 2, 0, 0, 8, 44, 12, 0},
    {-1, 73, 0, (char *)"Params-BN256-OAQUE", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 73, 0, (char *)"Params-BN256-IBE", 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 11, 127, (char *)"Public-BN256-IBE", 32, 2, 0, 0, 8, 46, 12, 0},
    {-1, 11, 147, (char *)"KeyringAESCiphertext", 40, 3, 0, 0, 8, 48, 12, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 40, 0, 63, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 40, 0, 63, 0},
    {-1, 0, 0, NULL, 2, 0, 0, 0, 8, 0, 50, 0},
    {-1, 0, 0, (char *)"TYPE-IDENTIFIER", 24, 2, 0, 0, 8, 51, 49, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 3},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 4},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 7},
    {-1, 1, 3, (char *)"Hash", 48, 2, 0, 0, 264, 53, 12, 0},
    {-1, 1, 3, (char *)"EntityHash", 48, 2, 0, 0, 264, 53, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 8},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 11},
    {-1, 1, 3, (char *)"Location", 48, 2, 0, 0, 264, 55, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 12},
    {-1, 163, 0, NULL, 1, 0, 0, 0, 8, 0, 8, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 15},
    {-1, 1, 3, (char *)"_seq1", 48, 2, 0, 0, 40, 57, 12, 0},
    {-1, 11, 165, (char *)"RevocationOption", 56, 2, 0, 0, 264, 59, 12, 0},
    {-1, 73, 0, NULL, 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 11, 173, (char *)"Extension", 40, 3, 0, 0, 8, 61, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 16},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 19},
    {-1, 11, 0, (char *)"_seqof1", 8, 56, 4, 8, 40, 55, 18, 0},
    {-1, 11, 0, (char *)"_seqof2", 8, 40, 4, 8, 40, 57, 18, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 22},
    {-1, 1, 3, (char *)"_seq2", 48, 2, 0, 0, 40, 64, 12, 0},
    {-1, 11, 185, (char *)"_seq3", 160, 5, 0, 0, 40, 66, 12, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 23},
    {-1, 1, 3, (char *)"_seq4", 48, 2, 0, 0, 40, 71, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 24},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 27},
    {0, 205, 23, NULL, 1, 0, 8, 0, 9, 0, 24, 0},
    {-1, 11, 207, (char *)"_seq5", 16, 2, 0, 0, 40, 73, 12, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 30},
    {-1, 1, 3, (char *)"_seq6", 48, 2, 0, 0, 40, 75, 12, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 31},
    {-1, 1, 3, (char *)"_seq7", 48, 2, 0, 0, 40, 77, 12, 0},
    {-1, 11, 215, (char *)"AttestationVerifierBody", 216, 6, 0, 0, 264, 79, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 32},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 35},
    {-1, 1, 3, (char *)"PolicyAddendum", 48, 2, 0, 0, 264, 85, 12, 0},
    {-1, 11, 0, (char *)"_seqof3", 8, 48, 4, 8, 40, 78, 18, 0},
    {-1, 239, 0, (char *)"Capability", 4, 0, 4, 0, 8, 1, 0, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 36},
    {-1, 241, 0, (char *)"_setof1", 8, 8, 4, 8, 40, 80, 15, 0},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 39},
    {-1, 1, 3, (char *)"_seq8", 48, 2, 0, 0, 40, 87, 12, 0},
    {-1, 11, 243, (char *)"EntityPublicKey", 56, 2, 0, 0, 264, 89, 12, 0},
    {-1, 11, 0, (char *)"_seqof4", 8, 56, 4, 8, 40, 85, 18, 0},
    {-1, 11, 251, (char *)"_seq9", 96, 5, 0, 0, 40, 91, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 40},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 43},
    {-1, 1, 3, (char *)"_seq10", 48, 2, 0, 0, 40, 96, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 44},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 47},
    {-1, 1, 3, (char *)"EntityPrivateKey", 48, 2, 0, 0, 264, 98, 12, 0},
    {-1, 11, 0, (char *)"_seqof5", 8, 104, 4, 8, 40, 7, 18, 0},
    {-1, 1, 3, (char *)"AttestationHash", 48, 2, 0, 0, 264, 53, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 48},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 51},
    {-1, 1, 3, (char *)"AttestationVerifierKey", 48, 2, 0, 0, 264, 100, 12, 0},
    {-1, 161, 0, NULL, 32, 1574916, 0, 0, 72, 0, 51, 52},
    {-1, 159, 0, (char *)"OSSC::OBJECT_IDENTIFIER", 16, 4, 4, 8, 104, 0, 63, 55},
    {-1, 1, 3, (char *)"RevocationCheck", 48, 2, 0, 0, 264, 102, 12, 0},
    {-1, 271, 0, NULL, 16, 0, 4, 8, 8, 0, 20, 0},
    {-1, 274, 0, (char *)"_seqof6", 8, 48, 4, 8, 40, 50, 18, 0},
    {-1, 277, 0, (char *)"_seqof7", 8, 48, 4, 8, 40, 98, 18, 0},
    {-1, 280, 0, (char *)"_seqof8", 8, 48, 4, 8, 40, 101, 18, 0},
    {-1, 283, 0, (char *)"_seqof9", 8, 40, 4, 8, 40, 57, 18, 0},
    {-1, 11, 286, (char *)"AttestationReference", 104, 6, 1, 1, 8, 104, 12, 0},
    {-1, 11, 0, (char *)"_seqof11", 8, 104, 4, 8, 40, 107, 18, 0},
    {-1, 239, 0, NULL, 4, 0, 4, 0, 8, 0, 0, 0},
    {-1, 11, 0, (char *)"_seqof10", 8, 8, 4, 8, 40, 109, 18, 0},
    {-1, 11, 0, (char *)"_seqof12", 8, 8, 4, 8, 40, 110, 18, 0},
    {-1, 11, 0, (char *)"_seqof13", 8, 16, 4, 8, 40, 56, 18, 0},
    {-1, 312, 12, NULL, 16, 0, 4, 8, 8, 0, 25, 0},
    {-1, 11, 0, (char *)"_seqof14", 8, 16, 4, 8, 40, 113, 18, 0},
    {-1, 11, 314, (char *)"RTreeStatement", 96, 4, 1, 1, 8, 110, 12, 0},
    {-1, 11, 0, (char *)"_seqof15", 8, 96, 4, 8, 40, 115, 18, 0},
    {-1, 11, 330, (char *)"_seq11", 32, 2, 0, 0, 40, 114, 12, 0},
    {-1, 239, 0, NULL, 2, 65536, 2, 0, 200, 0, 55, 56}
};

static const struct ConstraintEntry _econstraintarray[] = {
    {0, 17, (char *)NULL + 0x20001},
    {0, 19, (char *)NULL + 0x330000},
    {0, 16, (char *)NULL + 0x34},
    {0, 16, (char *)NULL + 0x33},
    {0, 17, (char *)NULL + 0x60005},
    {0, 19, (char *)NULL + 0x330035},
    {0, 16, (char *)NULL + 0x70034},
    {0, 16, (char *)NULL + 0x70033},
    {0, 17, (char *)NULL + 0xa0009},
    {0, 19, (char *)NULL + 0x330037},
    {0, 16, (char *)NULL + 0x60034},
    {0, 16, (char *)NULL + 0x60033},
    {0, 17, (char *)NULL + 0xe000d},
    {0, 19, (char *)NULL + 0x330039},
    {0, 16, (char *)NULL + 0x80034},
    {0, 16, (char *)NULL + 0x80033},
    {0, 17, (char *)NULL + 0x120011},
    {0, 19, (char *)NULL + 0x330040},
    {0, 16, (char *)NULL + 0x10034},
    {0, 17, (char *)NULL + 0x150014},
    {0, 19, (char *)NULL + 0x330047},
    {0, 16, (char *)NULL + 0x30034},
    {0, 16, (char *)NULL + 0x10033},
    {0, 16, (char *)NULL + 0x30033},
    {0, 17, (char *)NULL + 0x1a0019},
    {0, 19, (char *)NULL + 0x33004b},
    {0, 16, (char *)NULL + 0xa0034},
    {0, 17, (char *)NULL + 0x1d001c},
    {0, 19, (char *)NULL + 0x33004d},
    {0, 16, (char *)NULL + 0x40034},
    {0, 16, (char *)NULL + 0xa0033},
    {0, 16, (char *)NULL + 0x40033},
    {0, 17, (char *)NULL + 0x220021},
    {0, 19, (char *)NULL + 0x330055},
    {0, 16, (char *)NULL + 0xb0034},
    {0, 16, (char *)NULL + 0xb0033},
    {0, 17, (char *)NULL + 0x260025},
    {0, 19, (char *)NULL + 0x330057},
    {0, 16, (char *)NULL + 0x90034},
    {0, 16, (char *)NULL + 0x90033},
    {0, 17, (char *)NULL + 0x2a0029},
    {0, 19, (char *)NULL + 0x330060},
    {0, 16, (char *)NULL + 0xd0034},
    {0, 16, (char *)NULL + 0xd0033},
    {0, 17, (char *)NULL + 0x2e002d},
    {0, 19, (char *)NULL + 0x330062},
    {0, 16, (char *)NULL + 0xc0034},
    {0, 16, (char *)NULL + 0xc0033},
    {0, 17, (char *)NULL + 0x320031},
    {0, 19, (char *)NULL + 0x330064},
    {0, 16, (char *)NULL + 0x20034},
    {0, 16, (char *)NULL + 0x20033},
    {0, 17, (char *)NULL + 0x360035},
    {0, 19, (char *)NULL + 0x330066},
    {0, 16, (char *)NULL + 0x50034},
    {0, 16, (char *)NULL + 0x50033},
    {5, 14, (void *)_v171},
    {0, 3, (void *)_v171}
};

static const struct efield _efieldarray[] = {
    {0, 43, -1, 9, 18},
    {16, 42, -1, 10, 2},
    {0, 64, -1, 11, 2},
    {160, 66, -1, 12, 2},
    {0, 75, -1, 13, 2},
    {216, 79, -1, 14, 2},
    {224, 61, -1, 15, 2},
    {0, 87, -1, 11, 2},
    {96, 56, -1, 16, 2},
    {0, 4, -1, 17, 2},
    {112, 90, -1, 18, 2},
    {0, 94, -1, 19, 2},
    {0, 85, -1, 20, 2},
    {56, 93, -1, 21, 2},
    {0, 108, -1, 22, 2},
    {8, 111, -1, 23, 2},
    {16, 112, -1, 24, 2},
    {24, 61, -1, 25, 2},
    {0, 47, -1, 26, 2},
    {48, 109, -1, 27, 2},
    {56, 116, -1, 28, 2},
    {0, 113, -1, 10, 2},
    {16, 109, -1, 29, 2},
    {0, 109, -1, 30, 2},
    {4, 109, -1, 31, 2},
    {0, 56, -1, 32, 2},
    {16, 85, -1, 33, 2},
    {0, 56, -1, 34, 2},
    {16, 56, -1, 35, 2},
    {32, 56, -1, 36, 2},
    {48, 56, -1, 37, 2},
    {64, 56, -1, 38, 2},
    {0, 56, -1, 39, 2},
    {16, 112, -1, 40, 2},
    {0, 79, -1, 41, 2},
    {8, 61, -1, 25, 2},
    {0, 75, -1, 42, 2},
    {0, 56, -1, 43, 2},
    {16, 56, -1, 16, 2},
    {0, 117, -1, 11, 2},
    {32, 56, -1, 16, 2},
    {0, 118, -1, 44, 2},
    {0, 46, -1, 45, 2},
    {48, 50, -1, 46, 2},
    {0, 34, -1, 47, 2},
    {16, 112, -1, 48, 2},
    {0, 35, -1, 47, 2},
    {16, 56, -1, 49, 2},
    {0, 56, -1, 50, 2},
    {16, 56, -1, 51, 2},
    {32, 109, -1, 52, 2},
    {0, 39, -1, 49, 66},
    {16, 40, -1, 53, 2},
    {0, 45, -1, 9, 18},
    {16, 44, -1, 10, 2},
    {0, 49, -1, 9, 18},
    {16, 48, -1, 10, 2},
    {0, 53, -1, 9, 18},
    {16, 51, -1, 10, 2},
    {0, 52, -1, 54, 2},
    {8, 54, -1, 55, 2},
    {0, 38, -1, 56, 2},
    {16, 52, -1, 54, 2},
    {24, 56, -1, 10, 2},
    {0, 62, -1, 9, 18},
    {16, 58, -1, 10, 2},
    {0, 47, -1, 57, 2},
    {48, 50, -1, 58, 2},
    {96, 60, -1, 59, 2},
    {104, 61, -1, 60, 2},
    {112, 63, -1, 61, 2},
    {0, 65, -1, 9, 18},
    {16, 59, -1, 10, 2},
    {0, 69, -1, 62, 2},
    {8, 69, -1, 63, 2},
    {0, 71, -1, 9, 18},
    {16, 67, -1, 10, 2},
    {0, 73, -1, 9, 18},
    {16, 68, -1, 10, 2},
    {0, 47, -1, 64, 2},
    {48, 50, -1, 65, 2},
    {96, 70, -1, 66, 2},
    {112, 72, -1, 67, 2},
    {160, 61, -1, 25, 2},
    {168, 74, -1, 68, 2},
    {0, 77, -1, 9, 18},
    {16, 76, -1, 10, 2},
    {0, 83, -1, 9, 18},
    {16, 81, -1, 10, 2},
    {0, 82, -1, 69, 2},
    {8, 84, -1, 70, 2},
    {0, 85, -1, 43, 2},
    {56, 86, -1, 19, 2},
    {64, 70, -1, 66, 2},
    {80, 60, -1, 59, 2},
    {88, 61, -1, 25, 2},
    {0, 89, -1, 9, 18},
    {16, 88, -1, 10, 2},
    {0, 92, -1, 9, 18},
    {16, 91, -1, 10, 2},
    {0, 97, -1, 9, 18},
    {16, 96, -1, 10, 2},
    {0, 100, -1, 9, 18},
    {16, 99, -1, 10, 2},
    {8, 95, -1, 45, 2},
    {56, 102, 0, 71, 3},
    {72, 103, -1, 46, 2},
    {80, 104, -1, 19, 2},
    {88, 105, -1, 72, 2},
    {96, 106, -1, 25, 2},
    {8, 47, -1, 73, 2},
    {56, 114, -1, 74, 2},
    {64, 113, -1, 75, 2},
    {80, 113, 0, 76, 3},
    {0, 38, -1, 77, 2},
    {16, 56, -1, 43, 2}
};

#ifdef OSS_SPARTAN_AWARE
#if ((OSS_SPARTAN_AWARE + 0) > 12)
typedef struct ExtParms {
    int           versId;
    const void    *xparm[7];
} ExtParms;
static ExtParms const extParms = {
    OSS_COMPILER_API_LEVEL,
    {NULL, NULL, NULL, NULL, NULL, NULL, (char *)NULL + 8}
};
#endif /* OSS_SPARTAN_AWARE  > 12 */
#endif /* OSS_SPARTAN_AWARE */

static void * const _enamearray[] = {
    NULL,
    (char *)NULL + 0x6, (void *)_v172,
    (void *)"certification", (void *)"attestation", (void *)"signing", (void *)"authentication", (void *)"authorization",
    (void *)"encryption",
    (void *)"type-id",
    (void *)"value",
    (void *)"tbs",
    (void *)"outerSignature",
    (void *)"verifierBody",
    (void *)"proverPolicyAddendums",
    (void *)"proverExtensions",
    (void *)"signature",
    (void *)"entity",
    (void *)"keyring",
    (void *)"keys",
    (void *)"public",
    (void *)"secret",
    (void *)"attestations",
    (void *)"paths",
    (void *)"entities",
    (void *)"extensions",
    (void *)"namespace",
    (void *)"indirections",
    (void *)"statements",
    (void *)"apiVersion",
    (void *)"chainID",
    (void *)"contractAddress",
    (void *)"attestationBodyCiphertext",
    (void *)"encryptedUnder",
    (void *)"verifierBodyCiphertext",
    (void *)"proverBodyCiphertext",
    (void *)"envelopeCiphertext",
    (void *)"envelopeKey-ibe-bn256",
    (void *)"envelopeKey-curve25519",
    (void *)"bodyKeys-oaque",
    (void *)"partition",
    (void *)"addendums",
    (void *)"attestationVerifierBody",
    (void *)"verifyingKey",
    (void *)"trust",
    (void *)"hash",
    (void *)"location",
    (void *)"params",
    (void *)"attributeset",
    (void *)"id",
    (void *)"ciphertext",
    (void *)"salt",
    (void *)"iterations",
    (void *)"Type",
    (void *)"critical",
    (void *)"scheme",
    (void *)"extnID",
    (void *)"subject",
    (void *)"subjectLocation",
    (void *)"revocations",
    (void *)"publicExtensions",
    (void *)"body",
    (void *)"notBefore",
    (void *)"notAfter",
    (void *)"attester",
    (void *)"attesterLocation",
    (void *)"validity",
    (void *)"policy",
    (void *)"outerSignatureBinding",
    (void *)"capabilityFlags",
    (void *)"key",
    (void *)"content",
    (void *)"revocationChecks",
    (void *)"permissionSet",
    (void *)"permissions",
    (void *)"resource",
    (void *)"comment",
    (void *)"outerSignatureScheme"
};

static const Etag _tagarray[] = {
    0, 1, 0x0008, 5, 8, 1, 0x0006, 1, 1, 0x8000,
    2, 1, 0x0010, 15, 18, 1, 0x0010, 1, 1, 0x0008,
    2, 24, 27, 30, 1, 0x0010, 1, 1, 0x0010, 2,
    1, 0x0010, 3, 35, 38, 1, 0x0010, 1, 1, 0x0004,
    2, 42, 1, 0x0010, 1, 49, 52, 55, 58, 1,
    0x0010, 1, 1, 0x0010, 2, 1, 0x0010, 3, 1, 0x0010,
    4, 64, 67, 70, 1, 0x0008, 1, 1, 0x0002, 2,
    1, 0x0010, 3, 1, 0x0004, 77, 80, 1, 0x000c, 1,
    1, 0x0002, 2, 85, 88, 1, 0x0002, 1, 1, 0x0002,
    2, 93, 96, 1, 0x0004, 1, 1, 0x0010, 2, 104,
    107, 110, 113, 116, 1, 0x0004, 1, 1, 0x0004, 2,
    1, 0x0004, 3, 1, 0x0004, 4, 1, 0x0004, 5, 121,
    124, 1, 0x0010, 1, 1, 0x0010, 2, 129, 132, 1,
    0x0004, 1, 1, 0x0004, 2, 136, 1, 0x0002, 1, 141,
    144, 1, 0x0008, 1, 1, 0x0008, 2, 150, 153, 156,
    1, 0x0004, 1, 1, 0x0004, 2, 1, 0x0002, 3, 1,
    0x0006, 1, 0x8000, 1, 0x0001, 167, 170, 1, 0x0001, 1,
    1, 0x0008, 2, 176, 179, 182, 1, 0x0006, 1, 1,
    0x0001, 2, 1, 0x0004, 3, 190, 193, 196, 199, 202,
    1, 0x0008, 1, 1, 0x0008, 2, 1, 0x0010, 3, 1,
    0x0010, 4, 1, 0x0008, 5, 1, 0x0017, 209, 212, 1,
    0x0017, 1, 1, 0x0017, 2, 221, 224, 227, 230, 233,
    236, 1, 0x0008, 1, 1, 0x0008, 2, 1, 0x0010, 3,
    1, 0x0008, 4, 1, 0x0010, 5, 1, 0x0008, 6, 1,
    0x0002, 1, 0x0011, 245, 248, 1, 0x0011, 1, 1, 0x0008,
    2, 256, 259, 262, 265, 268, 1, 0x0010, 1, 1,
    0x0010, 2, 1, 0x0010, 3, 1, 0x0010, 4, 1, 0x0010,
    5, 2, 0x8000, 0x0004, 2, 0x8001, 0x0010, 2, 0x8002, 0x0010,
    2, 0x8003, 0x0010, 2, 0x8004, 0x0010, 292, 295, 300, 303,
    306, 309, 1, 0x0008, 1, 2, 0x8000, 2, 0x8001, 3,
    1, 0x8001, 3, 1, 0x8002, 4, 1, 0x8003, 5, 1,
    0x8004, 6, 1, 0x000c, 318, 321, 324, 327, 1, 0x0008,
    1, 1, 0x0010, 2, 1, 0x000c, 3, 1, 0x000c, 4,
    332, 335, 1, 0x0006, 1, 1, 0x0004, 2
};

#if !defined(OSS_SPARTAN_AWARE) || ((OSS_SPARTAN_AWARE + 0) <= 5)
typedef struct OSetTableEntry {
    void *a;
    unsigned short b;
    void *c;
    unsigned short d;
} OSetTableEntry;
#endif /* OSS_SPARTAN_AWARE  <= 5 */

static struct OSetTableEntry const _objectsettable[] = {
#if defined(OSS_SPARTAN_AWARE) && ((OSS_SPARTAN_AWARE + 0) > 12)
    {(void *)WaveObjects, 41, NULL, 0, NULL, -1, -1},
    {(void *)AttestationBodySchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)AttestationVerifierKeySchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)OuterSignatureSchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)OuterSignatureBindingSchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)RevocationCheckSchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)LocationSchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)HashSchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)RevocationSchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)EntityKeySchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)PolicySchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)PolicyAddendumSchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)EntitySecretKeySchemes, 41, NULL, 0, NULL, -1, -1},
    {(void *)EntityKeyringSchemes, 41, NULL, 0, NULL, -1, -1}
#else
    {(void *)WaveObjects, 41, NULL, 0},
    {(void *)AttestationBodySchemes, 41, NULL, 0},
    {(void *)AttestationVerifierKeySchemes, 41, NULL, 0},
    {(void *)OuterSignatureSchemes, 41, NULL, 0},
    {(void *)OuterSignatureBindingSchemes, 41, NULL, 0},
    {(void *)RevocationCheckSchemes, 41, NULL, 0},
    {(void *)LocationSchemes, 41, NULL, 0},
    {(void *)HashSchemes, 41, NULL, 0},
    {(void *)RevocationSchemes, 41, NULL, 0},
    {(void *)EntityKeySchemes, 41, NULL, 0},
    {(void *)PolicySchemes, 41, NULL, 0},
    {(void *)PolicyAddendumSchemes, 41, NULL, 0},
    {(void *)EntitySecretKeySchemes, 41, NULL, 0},
    {(void *)EntityKeyringSchemes, 41, NULL, 0}
#endif /* OSS_SPARTAN_AWARE  > 12 */
};


#ifdef OSS_SPARTAN_AWARE
#if ((OSS_SPARTAN_AWARE + 0) >= 3)
static void _oss_post_init(struct ossGlobal *world) {
    static const unsigned char _oss_typeinfo[] = {
        0x00, 0x53, 0x34, 0xf0, 0x61, 0x00, 0xcc, 0x76, 0xaf, 0xbb,
        0x34, 0x2d, 0xaf, 0x31, 0x34, 0xf6, 0xb7, 0x84, 0x64, 0xb5,
        0x99, 0x78, 0x7a, 0x13, 0x5a, 0x52, 0x86, 0x74, 0xc3, 0xaf,
        0xe7, 0xc1, 0x3d, 0x4b, 0x84, 0xf4, 0xd8, 0xed, 0x95, 0xf9,
        0xc0, 0xf4, 0xa5, 0x50, 0x58, 0x12, 0x2e, 0xcc, 0x28, 0x80,
        0x69, 0x60, 0xdb, 0x2e, 0x3d, 0xe2, 0x82, 0x2b, 0xc4, 0x89,
        0xf6, 0xa8, 0x49, 0x42, 0x22, 0x69, 0x60, 0xb6, 0x44, 0xf4,
        0x36, 0x61, 0x0f, 0xa4, 0xf0, 0x7c, 0xaf, 0xd8, 0x74, 0x1f,
        0xf9, 0x07, 0x13, 0x22, 0x05
    };
    ossInitRootContext1(world, (unsigned char *)_oss_typeinfo);
#ifdef OSS_SPARTAN_AWARE
#if ((OSS_SPARTAN_AWARE + 0) > 12)
    ossSetExtParms(world, (void *)&extParms);
#endif /* OSS_SPARTAN_AWARE  > 12 */
#endif /* OSS_SPARTAN_AWARE */
}
#endif /* OSS_SPARTAN_AWARE >= 3 */
#endif /* OSS_SPARTAN_AWARE */

static const struct eheader _head = {_ossinit_objects, -1, 115, 2933, 37, 119,
    (unsigned short *)_pduarray, (struct etype *)_etypearray,
    (struct efield *)_efieldarray, (void **)_enamearray, (Etag *)_tagarray,
    (struct ConstraintEntry *)_econstraintarray, NULL, NULL, 0, (void *)_objectsettable, 14};

void *objects_TableType::internal = (void *)&_head;
